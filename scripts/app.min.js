! function r(e, n, t) {
  function o(i, f) {
    if (!n[i]) {
      if (!e[i]) {
        var c = "function" == typeof require && require;
        if (!f && c) return c(i, !0);
        if (u) return u(i, !0);
        var a = new Error("Cannot find module '" + i + "'");
        throw a.code = "MODULE_NOT_FOUND", a
      }
      var p = n[i] = {
        exports: {}
      };
      e[i][0].call(p.exports, function (r) {
        return o(e[i][1][r] || r)
      }, p, p.exports, r, e, n, t)
    }
    return n[i].exports
  }
  for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
  return o
}({
  1: [function (require, module, exports) {
    var global, factory;
    global = this, factory = function (exports, Popper, $) {
      "use strict";

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor
      }

      function _defineProperty(obj, key, value) {
        return key in obj ? Object.defineProperty(obj, key, {
          value: value,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : obj[key] = value, obj
      }

      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = null != arguments[i] ? arguments[i] : {},
            ownKeys = Object.keys(source);
          "function" == typeof Object.getOwnPropertySymbols && (ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable
          }))), ownKeys.forEach(function (key) {
            _defineProperty(target, key, source[key])
          })
        }
        return target
      }
      Popper = Popper && Popper.hasOwnProperty("default") ? Popper.default : Popper, $ = $ && $.hasOwnProperty("default") ? $.default : $;
      var TRANSITION_END = "transitionend";

      function transitionEndEmulator(duration) {
        var _this = this,
          called = !1;
        return $(this).one(Util.TRANSITION_END, function () {
          called = !0
        }), setTimeout(function () {
          called || Util.triggerTransitionEnd(_this)
        }, duration), this
      }
      var Util = {
        TRANSITION_END: "bsTransitionEnd",
        getUID: function (prefix) {
          for (; prefix += ~~(1e6 * Math.random()), document.getElementById(prefix););
          return prefix
        },
        getSelectorFromElement: function (element) {
          var selector = element.getAttribute("data-target");
          if (!selector || "#" === selector) {
            var hrefAttr = element.getAttribute("href");
            selector = hrefAttr && "#" !== hrefAttr ? hrefAttr.trim() : ""
          }
          return selector && document.querySelector(selector) ? selector : null
        },
        getTransitionDurationFromElement: function (element) {
          if (!element) return 0;
          var transitionDuration = $(element).css("transition-duration"),
            transitionDelay = $(element).css("transition-delay"),
            floatTransitionDuration = parseFloat(transitionDuration),
            floatTransitionDelay = parseFloat(transitionDelay);
          return floatTransitionDuration || floatTransitionDelay ? (transitionDuration = transitionDuration.split(",")[0], transitionDelay = transitionDelay.split(",")[0], 1e3 * (parseFloat(transitionDuration) + parseFloat(transitionDelay))) : 0
        },
        reflow: function (element) {
          return element.offsetHeight
        },
        triggerTransitionEnd: function (element) {
          $(element).trigger(TRANSITION_END)
        },
        supportsTransitionEnd: function () {
          return Boolean(TRANSITION_END)
        },
        isElement: function (obj) {
          return (obj[0] || obj).nodeType
        },
        typeCheckConfig: function (componentName, config, configTypes) {
          for (var property in configTypes)
            if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
              var expectedTypes = configTypes[property],
                value = config[property],
                valueType = value && Util.isElement(value) ? "element" : (obj = value, {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase());
              if (!new RegExp(expectedTypes).test(valueType)) throw new Error(componentName.toUpperCase() + ': Option "' + property + '" provided type "' + valueType + '" but expected type "' + expectedTypes + '".')
            }
          var obj
        },
        findShadowRoot: function (element) {
          if (!document.documentElement.attachShadow) return null;
          if ("function" == typeof element.getRootNode) {
            var root = element.getRootNode();
            return root instanceof ShadowRoot ? root : null
          }
          return element instanceof ShadowRoot ? element : element.parentNode ? Util.findShadowRoot(element.parentNode) : null
        }
      };
      $.fn.emulateTransitionEnd = transitionEndEmulator, $.event.special[Util.TRANSITION_END] = {
        bindType: TRANSITION_END,
        delegateType: TRANSITION_END,
        handle: function (event) {
          if ($(event.target).is(this)) return event.handleObj.handler.apply(this, arguments)
        }
      };
      var JQUERY_NO_CONFLICT = $.fn.alert,
        Event = {
          CLOSE: "close.bs.alert",
          CLOSED: "closed.bs.alert",
          CLICK_DATA_API: "click.bs.alert.data-api"
        },
        ClassName_ALERT = "alert",
        ClassName_FADE = "fade",
        ClassName_SHOW = "show",
        Alert = function () {
          function Alert(element) {
            this._element = element
          }
          var _proto = Alert.prototype;
          return _proto.close = function (element) {
            var rootElement = this._element;
            element && (rootElement = this._getRootElement(element)), this._triggerCloseEvent(rootElement).isDefaultPrevented() || this._removeElement(rootElement)
          }, _proto.dispose = function () {
            $.removeData(this._element, "bs.alert"), this._element = null
          }, _proto._getRootElement = function (element) {
            var selector = Util.getSelectorFromElement(element),
              parent = !1;
            return selector && (parent = document.querySelector(selector)), parent || (parent = $(element).closest("." + ClassName_ALERT)[0]), parent
          }, _proto._triggerCloseEvent = function (element) {
            var closeEvent = $.Event(Event.CLOSE);
            return $(element).trigger(closeEvent), closeEvent
          }, _proto._removeElement = function (element) {
            var _this = this;
            if ($(element).removeClass(ClassName_SHOW), $(element).hasClass(ClassName_FADE)) {
              var transitionDuration = Util.getTransitionDurationFromElement(element);
              $(element).one(Util.TRANSITION_END, function (event) {
                return _this._destroyElement(element, event)
              }).emulateTransitionEnd(transitionDuration)
            } else this._destroyElement(element)
          }, _proto._destroyElement = function (element) {
            $(element).detach().trigger(Event.CLOSED).remove()
          }, Alert._jQueryInterface = function (config) {
            return this.each(function () {
              var $element = $(this),
                data = $element.data("bs.alert");
              data || (data = new Alert(this), $element.data("bs.alert", data)), "close" === config && data[config](this)
            })
          }, Alert._handleDismiss = function (alertInstance) {
            return function (event) {
              event && event.preventDefault(), alertInstance.close(this)
            }
          }, _createClass(Alert, null, [{
            key: "VERSION",
            get: function () {
              return "4.2.1"
            }
          }]), Alert
        }();
      $(document).on(Event.CLICK_DATA_API, '[data-dismiss="alert"]', Alert._handleDismiss(new Alert)), $.fn.alert = Alert._jQueryInterface, $.fn.alert.Constructor = Alert, $.fn.alert.noConflict = function () {
        return $.fn.alert = JQUERY_NO_CONFLICT, Alert._jQueryInterface
      };
      var JQUERY_NO_CONFLICT$1 = $.fn.button,
        ClassName$1_ACTIVE = "active",
        ClassName$1_BUTTON = "btn",
        ClassName$1_FOCUS = "focus",
        Selector$1_DATA_TOGGLE_CARROT = '[data-toggle^="button"]',
        Selector$1_DATA_TOGGLE = '[data-toggle="buttons"]',
        Selector$1_INPUT = 'input:not([type="hidden"])',
        Selector$1_ACTIVE = ".active",
        Selector$1_BUTTON = ".btn",
        Event$1 = {
          CLICK_DATA_API: "click.bs.button.data-api",
          FOCUS_BLUR_DATA_API: "focus.bs.button.data-api blur.bs.button.data-api"
        },
        Button = function () {
          function Button(element) {
            this._element = element
          }
          var _proto = Button.prototype;
          return _proto.toggle = function () {
            var triggerChangeEvent = !0,
              addAriaPressed = !0,
              rootElement = $(this._element).closest(Selector$1_DATA_TOGGLE)[0];
            if (rootElement) {
              var input = this._element.querySelector(Selector$1_INPUT);
              if (input) {
                if ("radio" === input.type)
                  if (input.checked && this._element.classList.contains(ClassName$1_ACTIVE)) triggerChangeEvent = !1;
                  else {
                    var activeElement = rootElement.querySelector(Selector$1_ACTIVE);
                    activeElement && $(activeElement).removeClass(ClassName$1_ACTIVE)
                  }
                if (triggerChangeEvent) {
                  if (input.hasAttribute("disabled") || rootElement.hasAttribute("disabled") || input.classList.contains("disabled") || rootElement.classList.contains("disabled")) return;
                  input.checked = !this._element.classList.contains(ClassName$1_ACTIVE), $(input).trigger("change")
                }
                input.focus(), addAriaPressed = !1
              }
            }
            addAriaPressed && this._element.setAttribute("aria-pressed", !this._element.classList.contains(ClassName$1_ACTIVE)), triggerChangeEvent && $(this._element).toggleClass(ClassName$1_ACTIVE)
          }, _proto.dispose = function () {
            $.removeData(this._element, "bs.button"), this._element = null
          }, Button._jQueryInterface = function (config) {
            return this.each(function () {
              var data = $(this).data("bs.button");
              data || (data = new Button(this), $(this).data("bs.button", data)), "toggle" === config && data[config]()
            })
          }, _createClass(Button, null, [{
            key: "VERSION",
            get: function () {
              return "4.2.1"
            }
          }]), Button
        }();
      $(document).on(Event$1.CLICK_DATA_API, Selector$1_DATA_TOGGLE_CARROT, function (event) {
        event.preventDefault();
        var button = event.target;
        $(button).hasClass(ClassName$1_BUTTON) || (button = $(button).closest(Selector$1_BUTTON)), Button._jQueryInterface.call($(button), "toggle")
      }).on(Event$1.FOCUS_BLUR_DATA_API, Selector$1_DATA_TOGGLE_CARROT, function (event) {
        var button = $(event.target).closest(Selector$1_BUTTON)[0];
        $(button).toggleClass(ClassName$1_FOCUS, /^focus(in)?$/.test(event.type))
      }), $.fn.button = Button._jQueryInterface, $.fn.button.Constructor = Button, $.fn.button.noConflict = function () {
        return $.fn.button = JQUERY_NO_CONFLICT$1, Button._jQueryInterface
      };
      var NAME$2 = "carousel",
        EVENT_KEY$2 = ".bs.carousel",
        JQUERY_NO_CONFLICT$2 = $.fn[NAME$2],
        Default = {
          interval: 5e3,
          keyboard: !0,
          slide: !1,
          pause: "hover",
          wrap: !0,
          touch: !0
        },
        DefaultType = {
          interval: "(number|boolean)",
          keyboard: "boolean",
          slide: "(boolean|string)",
          pause: "(string|boolean)",
          wrap: "boolean",
          touch: "boolean"
        },
        Direction_NEXT = "next",
        Direction_PREV = "prev",
        Direction_LEFT = "left",
        Direction_RIGHT = "right",
        Event$2 = {
          SLIDE: "slide.bs.carousel",
          SLID: "slid.bs.carousel",
          KEYDOWN: "keydown.bs.carousel",
          MOUSEENTER: "mouseenter.bs.carousel",
          MOUSELEAVE: "mouseleave.bs.carousel",
          TOUCHSTART: "touchstart.bs.carousel",
          TOUCHMOVE: "touchmove.bs.carousel",
          TOUCHEND: "touchend.bs.carousel",
          POINTERDOWN: "pointerdown.bs.carousel",
          POINTERUP: "pointerup.bs.carousel",
          DRAG_START: "dragstart.bs.carousel",
          LOAD_DATA_API: "load.bs.carousel.data-api",
          CLICK_DATA_API: "click.bs.carousel.data-api"
        },
        ClassName$2_CAROUSEL = "carousel",
        ClassName$2_ACTIVE = "active",
        ClassName$2_SLIDE = "slide",
        ClassName$2_RIGHT = "carousel-item-right",
        ClassName$2_LEFT = "carousel-item-left",
        ClassName$2_NEXT = "carousel-item-next",
        ClassName$2_PREV = "carousel-item-prev",
        ClassName$2_POINTER_EVENT = "pointer-event",
        Selector$2 = {
          ACTIVE: ".active",
          ACTIVE_ITEM: ".active.carousel-item",
          ITEM: ".carousel-item",
          ITEM_IMG: ".carousel-item img",
          NEXT_PREV: ".carousel-item-next, .carousel-item-prev",
          INDICATORS: ".carousel-indicators",
          DATA_SLIDE: "[data-slide], [data-slide-to]",
          DATA_RIDE: '[data-ride="carousel"]'
        },
        PointerType = {
          TOUCH: "touch",
          PEN: "pen"
        },
        Carousel = function () {
          function Carousel(element, config) {
            this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(config), this._element = element, this._indicatorsElement = this._element.querySelector(Selector$2.INDICATORS), this._touchSupported = "ontouchstart" in document.documentElement || 0 < navigator.maxTouchPoints, this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent), this._addEventListeners()
          }
          var _proto = Carousel.prototype;
          return _proto.next = function () {
            this._isSliding || this._slide(Direction_NEXT)
          }, _proto.nextWhenVisible = function () {
            !document.hidden && $(this._element).is(":visible") && "hidden" !== $(this._element).css("visibility") && this.next()
          }, _proto.prev = function () {
            this._isSliding || this._slide(Direction_PREV)
          }, _proto.pause = function (event) {
            event || (this._isPaused = !0), this._element.querySelector(Selector$2.NEXT_PREV) && (Util.triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null
          }, _proto.cycle = function (event) {
            event || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config.interval && !this._isPaused && (this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval))
          }, _proto.to = function (index) {
            var _this = this;
            this._activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM);
            var activeIndex = this._getItemIndex(this._activeElement);
            if (!(index > this._items.length - 1 || index < 0))
              if (this._isSliding) $(this._element).one(Event$2.SLID, function () {
                return _this.to(index)
              });
              else {
                if (activeIndex === index) return this.pause(), void this.cycle();
                var direction = activeIndex < index ? Direction_NEXT : Direction_PREV;
                this._slide(direction, this._items[index])
              }
          }, _proto.dispose = function () {
            $(this._element).off(EVENT_KEY$2), $.removeData(this._element, "bs.carousel"), this._items = null, this._config = null, this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null
          }, _proto._getConfig = function (config) {
            return config = _objectSpread({}, Default, config), Util.typeCheckConfig(NAME$2, config, DefaultType), config
          }, _proto._handleSwipe = function () {
            var absDeltax = Math.abs(this.touchDeltaX);
            if (!(absDeltax <= 40)) {
              var direction = absDeltax / this.touchDeltaX;
              0 < direction && this.prev(), direction < 0 && this.next()
            }
          }, _proto._addEventListeners = function () {
            var _this2 = this;
            this._config.keyboard && $(this._element).on(Event$2.KEYDOWN, function (event) {
              return _this2._keydown(event)
            }), "hover" === this._config.pause && $(this._element).on(Event$2.MOUSEENTER, function (event) {
              return _this2.pause(event)
            }).on(Event$2.MOUSELEAVE, function (event) {
              return _this2.cycle(event)
            }), this._addTouchEventListeners()
          }, _proto._addTouchEventListeners = function () {
            var _this3 = this;
            if (this._touchSupported) {
              var start = function (event) {
                  _this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()] ? _this3.touchStartX = event.originalEvent.clientX : _this3._pointerEvent || (_this3.touchStartX = event.originalEvent.touches[0].clientX)
                },
                end = function (event) {
                  _this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()] && (_this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX), _this3._handleSwipe(), "hover" === _this3._config.pause && (_this3.pause(), _this3.touchTimeout && clearTimeout(_this3.touchTimeout), _this3.touchTimeout = setTimeout(function (event) {
                    return _this3.cycle(event)
                  }, 500 + _this3._config.interval))
                };
              $(this._element.querySelectorAll(Selector$2.ITEM_IMG)).on(Event$2.DRAG_START, function (e) {
                return e.preventDefault()
              }), this._pointerEvent ? ($(this._element).on(Event$2.POINTERDOWN, function (event) {
                return start(event)
              }), $(this._element).on(Event$2.POINTERUP, function (event) {
                return end(event)
              }), this._element.classList.add(ClassName$2_POINTER_EVENT)) : ($(this._element).on(Event$2.TOUCHSTART, function (event) {
                return start(event)
              }), $(this._element).on(Event$2.TOUCHMOVE, function (event) {
                return function (event) {
                  event.originalEvent.touches && 1 < event.originalEvent.touches.length ? _this3.touchDeltaX = 0 : _this3.touchDeltaX = event.originalEvent.touches[0].clientX - _this3.touchStartX
                }(event)
              }), $(this._element).on(Event$2.TOUCHEND, function (event) {
                return end(event)
              }))
            }
          }, _proto._keydown = function (event) {
            if (!/input|textarea/i.test(event.target.tagName)) switch (event.which) {
              case 37:
                event.preventDefault(), this.prev();
                break;
              case 39:
                event.preventDefault(), this.next()
            }
          }, _proto._getItemIndex = function (element) {
            return this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(Selector$2.ITEM)) : [], this._items.indexOf(element)
          }, _proto._getItemByDirection = function (direction, activeElement) {
            var isNextDirection = direction === Direction_NEXT,
              isPrevDirection = direction === Direction_PREV,
              activeIndex = this._getItemIndex(activeElement),
              lastItemIndex = this._items.length - 1;
            if ((isPrevDirection && 0 === activeIndex || isNextDirection && activeIndex === lastItemIndex) && !this._config.wrap) return activeElement;
            var itemIndex = (activeIndex + (direction === Direction_PREV ? -1 : 1)) % this._items.length;
            return -1 === itemIndex ? this._items[this._items.length - 1] : this._items[itemIndex]
          }, _proto._triggerSlideEvent = function (relatedTarget, eventDirectionName) {
            var targetIndex = this._getItemIndex(relatedTarget),
              fromIndex = this._getItemIndex(this._element.querySelector(Selector$2.ACTIVE_ITEM)),
              slideEvent = $.Event(Event$2.SLIDE, {
                relatedTarget: relatedTarget,
                direction: eventDirectionName,
                from: fromIndex,
                to: targetIndex
              });
            return $(this._element).trigger(slideEvent), slideEvent
          }, _proto._setActiveIndicatorElement = function (element) {
            if (this._indicatorsElement) {
              var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(Selector$2.ACTIVE));
              $(indicators).removeClass(ClassName$2_ACTIVE);
              var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];
              nextIndicator && $(nextIndicator).addClass(ClassName$2_ACTIVE)
            }
          }, _proto._slide = function (direction, element) {
            var directionalClassName, orderClassName, eventDirectionName, _this4 = this,
              activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM),
              activeElementIndex = this._getItemIndex(activeElement),
              nextElement = element || activeElement && this._getItemByDirection(direction, activeElement),
              nextElementIndex = this._getItemIndex(nextElement),
              isCycling = Boolean(this._interval);
            if (direction === Direction_NEXT ? (directionalClassName = ClassName$2_LEFT, orderClassName = ClassName$2_NEXT, eventDirectionName = Direction_LEFT) : (directionalClassName = ClassName$2_RIGHT, orderClassName = ClassName$2_PREV, eventDirectionName = Direction_RIGHT), nextElement && $(nextElement).hasClass(ClassName$2_ACTIVE)) this._isSliding = !1;
            else if (!this._triggerSlideEvent(nextElement, eventDirectionName).isDefaultPrevented() && activeElement && nextElement) {
              this._isSliding = !0, isCycling && this.pause(), this._setActiveIndicatorElement(nextElement);
              var slidEvent = $.Event(Event$2.SLID, {
                relatedTarget: nextElement,
                direction: eventDirectionName,
                from: activeElementIndex,
                to: nextElementIndex
              });
              if ($(this._element).hasClass(ClassName$2_SLIDE)) {
                $(nextElement).addClass(orderClassName), Util.reflow(nextElement), $(activeElement).addClass(directionalClassName), $(nextElement).addClass(directionalClassName);
                var nextElementInterval = parseInt(nextElement.getAttribute("data-interval"), 10);
                nextElementInterval ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = nextElementInterval) : this._config.interval = this._config.defaultInterval || this._config.interval;
                var transitionDuration = Util.getTransitionDurationFromElement(activeElement);
                $(activeElement).one(Util.TRANSITION_END, function () {
                  $(nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(ClassName$2_ACTIVE), $(activeElement).removeClass(ClassName$2_ACTIVE + " " + orderClassName + " " + directionalClassName), _this4._isSliding = !1, setTimeout(function () {
                    return $(_this4._element).trigger(slidEvent)
                  }, 0)
                }).emulateTransitionEnd(transitionDuration)
              } else $(activeElement).removeClass(ClassName$2_ACTIVE), $(nextElement).addClass(ClassName$2_ACTIVE), this._isSliding = !1, $(this._element).trigger(slidEvent);
              isCycling && this.cycle()
            }
          }, Carousel._jQueryInterface = function (config) {
            return this.each(function () {
              var data = $(this).data("bs.carousel"),
                _config = _objectSpread({}, Default, $(this).data());
              "object" == typeof config && (_config = _objectSpread({}, _config, config));
              var action = "string" == typeof config ? config : _config.slide;
              if (data || (data = new Carousel(this, _config), $(this).data("bs.carousel", data)), "number" == typeof config) data.to(config);
              else if ("string" == typeof action) {
                if (void 0 === data[action]) throw new TypeError('No method named "' + action + '"');
                data[action]()
              } else _config.interval && (data.pause(), data.cycle())
            })
          }, Carousel._dataApiClickHandler = function (event) {
            var selector = Util.getSelectorFromElement(this);
            if (selector) {
              var target = $(selector)[0];
              if (target && $(target).hasClass(ClassName$2_CAROUSEL)) {
                var config = _objectSpread({}, $(target).data(), $(this).data()),
                  slideIndex = this.getAttribute("data-slide-to");
                slideIndex && (config.interval = !1), Carousel._jQueryInterface.call($(target), config), slideIndex && $(target).data("bs.carousel").to(slideIndex), event.preventDefault()
              }
            }
          }, _createClass(Carousel, null, [{
            key: "VERSION",
            get: function () {
              return "4.2.1"
            }
          }, {
            key: "Default",
            get: function () {
              return Default
            }
          }]), Carousel
        }();
      $(document).on(Event$2.CLICK_DATA_API, Selector$2.DATA_SLIDE, Carousel._dataApiClickHandler), $(window).on(Event$2.LOAD_DATA_API, function () {
        for (var carousels = [].slice.call(document.querySelectorAll(Selector$2.DATA_RIDE)), i = 0, len = carousels.length; i < len; i++) {
          var $carousel = $(carousels[i]);
          Carousel._jQueryInterface.call($carousel, $carousel.data())
        }
      }), $.fn[NAME$2] = Carousel._jQueryInterface, $.fn[NAME$2].Constructor = Carousel, $.fn[NAME$2].noConflict = function () {
        return $.fn[NAME$2] = JQUERY_NO_CONFLICT$2, Carousel._jQueryInterface
      };
      var NAME$3 = "collapse",
        JQUERY_NO_CONFLICT$3 = $.fn[NAME$3],
        Default$1 = {
          toggle: !0,
          parent: ""
        },
        DefaultType$1 = {
          toggle: "boolean",
          parent: "(string|element)"
        },
        Event$3 = {
          SHOW: "show.bs.collapse",
          SHOWN: "shown.bs.collapse",
          HIDE: "hide.bs.collapse",
          HIDDEN: "hidden.bs.collapse",
          CLICK_DATA_API: "click.bs.collapse.data-api"
        },
        ClassName$3_SHOW = "show",
        ClassName$3_COLLAPSE = "collapse",
        ClassName$3_COLLAPSING = "collapsing",
        ClassName$3_COLLAPSED = "collapsed",
        Dimension_WIDTH = "width",
        Dimension_HEIGHT = "height",
        Selector$3 = {
          ACTIVES: ".show, .collapsing",
          DATA_TOGGLE: '[data-toggle="collapse"]'
        },
        Collapse = function () {
          function Collapse(element, config) {
            this._isTransitioning = !1, this._element = element, this._config = this._getConfig(config), this._triggerArray = [].slice.call(document.querySelectorAll('[data-toggle="collapse"][href="#' + element.id + '"],[data-toggle="collapse"][data-target="#' + element.id + '"]'));
            for (var toggleList = [].slice.call(document.querySelectorAll(Selector$3.DATA_TOGGLE)), i = 0, len = toggleList.length; i < len; i++) {
              var elem = toggleList[i],
                selector = Util.getSelectorFromElement(elem),
                filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {
                  return foundElem === element
                });
              null !== selector && 0 < filterElement.length && (this._selector = selector, this._triggerArray.push(elem))
            }
            this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle()
          }
          var _proto = Collapse.prototype;
          return _proto.toggle = function () {
            $(this._element).hasClass(ClassName$3_SHOW) ? this.hide() : this.show()
          }, _proto.show = function () {
            var actives, activesData, _this = this;
            if (!this._isTransitioning && !$(this._element).hasClass(ClassName$3_SHOW) && (this._parent && 0 === (actives = [].slice.call(this._parent.querySelectorAll(Selector$3.ACTIVES)).filter(function (elem) {
                return "string" == typeof _this._config.parent ? elem.getAttribute("data-parent") === _this._config.parent : elem.classList.contains(ClassName$3_COLLAPSE)
              })).length && (actives = null), !(actives && (activesData = $(actives).not(this._selector).data("bs.collapse")) && activesData._isTransitioning))) {
              var startEvent = $.Event(Event$3.SHOW);
              if ($(this._element).trigger(startEvent), !startEvent.isDefaultPrevented()) {
                actives && (Collapse._jQueryInterface.call($(actives).not(this._selector), "hide"), activesData || $(actives).data("bs.collapse", null));
                var dimension = this._getDimension();
                $(this._element).removeClass(ClassName$3_COLLAPSE).addClass(ClassName$3_COLLAPSING), this._element.style[dimension] = 0, this._triggerArray.length && $(this._triggerArray).removeClass(ClassName$3_COLLAPSED).attr("aria-expanded", !0), this.setTransitioning(!0);
                var scrollSize = "scroll" + (dimension[0].toUpperCase() + dimension.slice(1)),
                  transitionDuration = Util.getTransitionDurationFromElement(this._element);
                $(this._element).one(Util.TRANSITION_END, function () {
                  $(_this._element).removeClass(ClassName$3_COLLAPSING).addClass(ClassName$3_COLLAPSE).addClass(ClassName$3_SHOW), _this._element.style[dimension] = "", _this.setTransitioning(!1), $(_this._element).trigger(Event$3.SHOWN)
                }).emulateTransitionEnd(transitionDuration), this._element.style[dimension] = this._element[scrollSize] + "px"
              }
            }
          }, _proto.hide = function () {
            var _this2 = this;
            if (!this._isTransitioning && $(this._element).hasClass(ClassName$3_SHOW)) {
              var startEvent = $.Event(Event$3.HIDE);
              if ($(this._element).trigger(startEvent), !startEvent.isDefaultPrevented()) {
                var dimension = this._getDimension();
                this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px", Util.reflow(this._element), $(this._element).addClass(ClassName$3_COLLAPSING).removeClass(ClassName$3_COLLAPSE).removeClass(ClassName$3_SHOW);
                var triggerArrayLength = this._triggerArray.length;
                if (0 < triggerArrayLength)
                  for (var i = 0; i < triggerArrayLength; i++) {
                    var trigger = this._triggerArray[i],
                      selector = Util.getSelectorFromElement(trigger);
                    if (null !== selector) $([].slice.call(document.querySelectorAll(selector))).hasClass(ClassName$3_SHOW) || $(trigger).addClass(ClassName$3_COLLAPSED).attr("aria-expanded", !1)
                  }
                this.setTransitioning(!0);
                this._element.style[dimension] = "";
                var transitionDuration = Util.getTransitionDurationFromElement(this._element);
                $(this._element).one(Util.TRANSITION_END, function () {
                  _this2.setTransitioning(!1), $(_this2._element).removeClass(ClassName$3_COLLAPSING).addClass(ClassName$3_COLLAPSE).trigger(Event$3.HIDDEN)
                }).emulateTransitionEnd(transitionDuration)
              }
            }
          }, _proto.setTransitioning = function (isTransitioning) {
            this._isTransitioning = isTransitioning
          }, _proto.dispose = function () {
            $.removeData(this._element, "bs.collapse"), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null
          }, _proto._getConfig = function (config) {
            return (config = _objectSpread({}, Default$1, config)).toggle = Boolean(config.toggle), Util.typeCheckConfig(NAME$3, config, DefaultType$1), config
          }, _proto._getDimension = function () {
            return $(this._element).hasClass(Dimension_WIDTH) ? Dimension_WIDTH : Dimension_HEIGHT
          }, _proto._getParent = function () {
            var parent, _this3 = this;
            Util.isElement(this._config.parent) ? (parent = this._config.parent, void 0 !== this._config.parent.jquery && (parent = this._config.parent[0])) : parent = document.querySelector(this._config.parent);
            var selector = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]',
              children = [].slice.call(parent.querySelectorAll(selector));
            return $(children).each(function (i, element) {
              _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element])
            }), parent
          }, _proto._addAriaAndCollapsedClass = function (element, triggerArray) {
            var isOpen = $(element).hasClass(ClassName$3_SHOW);
            triggerArray.length && $(triggerArray).toggleClass(ClassName$3_COLLAPSED, !isOpen).attr("aria-expanded", isOpen)
          }, Collapse._getTargetFromElement = function (element) {
            var selector = Util.getSelectorFromElement(element);
            return selector ? document.querySelector(selector) : null
          }, Collapse._jQueryInterface = function (config) {
            return this.each(function () {
              var $this = $(this),
                data = $this.data("bs.collapse"),
                _config = _objectSpread({}, Default$1, $this.data(), "object" == typeof config && config ? config : {});
              if (!data && _config.toggle && /show|hide/.test(config) && (_config.toggle = !1), data || (data = new Collapse(this, _config), $this.data("bs.collapse", data)), "string" == typeof config) {
                if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                data[config]()
              }
            })
          }, _createClass(Collapse, null, [{
            key: "VERSION",
            get: function () {
              return "4.2.1"
            }
          }, {
            key: "Default",
            get: function () {
              return Default$1
            }
          }]), Collapse
        }();
      $(document).on(Event$3.CLICK_DATA_API, Selector$3.DATA_TOGGLE, function (event) {
        "A" === event.currentTarget.tagName && event.preventDefault();
        var $trigger = $(this),
          selector = Util.getSelectorFromElement(this),
          selectors = [].slice.call(document.querySelectorAll(selector));
        $(selectors).each(function () {
          var $target = $(this),
            config = $target.data("bs.collapse") ? "toggle" : $trigger.data();
          Collapse._jQueryInterface.call($target, config)
        })
      }), $.fn[NAME$3] = Collapse._jQueryInterface, $.fn[NAME$3].Constructor = Collapse, $.fn[NAME$3].noConflict = function () {
        return $.fn[NAME$3] = JQUERY_NO_CONFLICT$3, Collapse._jQueryInterface
      };
      var NAME$4 = "dropdown",
        JQUERY_NO_CONFLICT$4 = $.fn[NAME$4],
        REGEXP_KEYDOWN = new RegExp("38|40|27"),
        Event$4 = {
          HIDE: "hide.bs.dropdown",
          HIDDEN: "hidden.bs.dropdown",
          SHOW: "show.bs.dropdown",
          SHOWN: "shown.bs.dropdown",
          CLICK: "click.bs.dropdown",
          CLICK_DATA_API: "click.bs.dropdown.data-api",
          KEYDOWN_DATA_API: "keydown.bs.dropdown.data-api",
          KEYUP_DATA_API: "keyup.bs.dropdown.data-api"
        },
        ClassName$4_DISABLED = "disabled",
        ClassName$4_SHOW = "show",
        ClassName$4_DROPUP = "dropup",
        ClassName$4_DROPRIGHT = "dropright",
        ClassName$4_DROPLEFT = "dropleft",
        ClassName$4_MENURIGHT = "dropdown-menu-right",
        ClassName$4_POSITION_STATIC = "position-static",
        Selector$4_DATA_TOGGLE = '[data-toggle="dropdown"]',
        Selector$4_FORM_CHILD = ".dropdown form",
        Selector$4_MENU = ".dropdown-menu",
        Selector$4_NAVBAR_NAV = ".navbar-nav",
        Selector$4_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",
        AttachmentMap_TOP = "top-start",
        AttachmentMap_TOPEND = "top-end",
        AttachmentMap_BOTTOM = "bottom-start",
        AttachmentMap_BOTTOMEND = "bottom-end",
        AttachmentMap_RIGHT = "right-start",
        AttachmentMap_LEFT = "left-start",
        Default$2 = {
          offset: 0,
          flip: !0,
          boundary: "scrollParent",
          reference: "toggle",
          display: "dynamic"
        },
        DefaultType$2 = {
          offset: "(number|string|function)",
          flip: "boolean",
          boundary: "(string|element)",
          reference: "(string|element)",
          display: "string"
        },
        Dropdown = function () {
          function Dropdown(element, config) {
            this._element = element, this._popper = null, this._config = this._getConfig(config), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners()
          }
          var _proto = Dropdown.prototype;
          return _proto.toggle = function () {
            if (!this._element.disabled && !$(this._element).hasClass(ClassName$4_DISABLED)) {
              var parent = Dropdown._getParentFromElement(this._element),
                isActive = $(this._menu).hasClass(ClassName$4_SHOW);
              if (Dropdown._clearMenus(), !isActive) {
                var relatedTarget = {
                    relatedTarget: this._element
                  },
                  showEvent = $.Event(Event$4.SHOW, relatedTarget);
                if ($(parent).trigger(showEvent), !showEvent.isDefaultPrevented()) {
                  if (!this._inNavbar) {
                    if (void 0 === Popper) throw new TypeError("Bootstrap's dropdowns require Popper.js (https://popper.js.org/)");
                    var referenceElement = this._element;
                    "parent" === this._config.reference ? referenceElement = parent : Util.isElement(this._config.reference) && (referenceElement = this._config.reference, void 0 !== this._config.reference.jquery && (referenceElement = this._config.reference[0])), "scrollParent" !== this._config.boundary && $(parent).addClass(ClassName$4_POSITION_STATIC), this._popper = new Popper(referenceElement, this._menu, this._getPopperConfig())
                  }
                  "ontouchstart" in document.documentElement && 0 === $(parent).closest(Selector$4_NAVBAR_NAV).length && $(document.body).children().on("mouseover", null, $.noop), this._element.focus(), this._element.setAttribute("aria-expanded", !0), $(this._menu).toggleClass(ClassName$4_SHOW), $(parent).toggleClass(ClassName$4_SHOW).trigger($.Event(Event$4.SHOWN, relatedTarget))
                }
              }
            }
          }, _proto.show = function () {
            if (!(this._element.disabled || $(this._element).hasClass(ClassName$4_DISABLED) || $(this._menu).hasClass(ClassName$4_SHOW))) {
              var relatedTarget = {
                  relatedTarget: this._element
                },
                showEvent = $.Event(Event$4.SHOW, relatedTarget),
                parent = Dropdown._getParentFromElement(this._element);
              $(parent).trigger(showEvent), showEvent.isDefaultPrevented() || ($(this._menu).toggleClass(ClassName$4_SHOW), $(parent).toggleClass(ClassName$4_SHOW).trigger($.Event(Event$4.SHOWN, relatedTarget)))
            }
          }, _proto.hide = function () {
            if (!this._element.disabled && !$(this._element).hasClass(ClassName$4_DISABLED) && $(this._menu).hasClass(ClassName$4_SHOW)) {
              var relatedTarget = {
                  relatedTarget: this._element
                },
                hideEvent = $.Event(Event$4.HIDE, relatedTarget),
                parent = Dropdown._getParentFromElement(this._element);
              $(parent).trigger(hideEvent), hideEvent.isDefaultPrevented() || ($(this._menu).toggleClass(ClassName$4_SHOW), $(parent).toggleClass(ClassName$4_SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget)))
            }
          }, _proto.dispose = function () {
            $.removeData(this._element, "bs.dropdown"), $(this._element).off(".bs.dropdown"), this._element = null, (this._menu = null) !== this._popper && (this._popper.destroy(), this._popper = null)
          }, _proto.update = function () {
            this._inNavbar = this._detectNavbar(), null !== this._popper && this._popper.scheduleUpdate()
          }, _proto._addEventListeners = function () {
            var _this = this;
            $(this._element).on(Event$4.CLICK, function (event) {
              event.preventDefault(), event.stopPropagation(), _this.toggle()
            })
          }, _proto._getConfig = function (config) {
            return config = _objectSpread({}, this.constructor.Default, $(this._element).data(), config), Util.typeCheckConfig(NAME$4, config, this.constructor.DefaultType), config
          }, _proto._getMenuElement = function () {
            if (!this._menu) {
              var parent = Dropdown._getParentFromElement(this._element);
              parent && (this._menu = parent.querySelector(Selector$4_MENU))
            }
            return this._menu
          }, _proto._getPlacement = function () {
            var $parentDropdown = $(this._element.parentNode),
              placement = AttachmentMap_BOTTOM;
            return $parentDropdown.hasClass(ClassName$4_DROPUP) ? (placement = AttachmentMap_TOP, $(this._menu).hasClass(ClassName$4_MENURIGHT) && (placement = AttachmentMap_TOPEND)) : $parentDropdown.hasClass(ClassName$4_DROPRIGHT) ? placement = AttachmentMap_RIGHT : $parentDropdown.hasClass(ClassName$4_DROPLEFT) ? placement = AttachmentMap_LEFT : $(this._menu).hasClass(ClassName$4_MENURIGHT) && (placement = AttachmentMap_BOTTOMEND), placement
          }, _proto._detectNavbar = function () {
            return 0 < $(this._element).closest(".navbar").length
          }, _proto._getPopperConfig = function () {
            var _this2 = this,
              offsetConf = {};
            "function" == typeof this._config.offset ? offsetConf.fn = function (data) {
              return data.offsets = _objectSpread({}, data.offsets, _this2._config.offset(data.offsets) || {}), data
            } : offsetConf.offset = this._config.offset;
            var popperConfig = {
              placement: this._getPlacement(),
              modifiers: {
                offset: offsetConf,
                flip: {
                  enabled: this._config.flip
                },
                preventOverflow: {
                  boundariesElement: this._config.boundary
                }
              }
            };
            return "static" === this._config.display && (popperConfig.modifiers.applyStyle = {
              enabled: !1
            }), popperConfig
          }, Dropdown._jQueryInterface = function (config) {
            return this.each(function () {
              var data = $(this).data("bs.dropdown");
              if (data || (data = new Dropdown(this, "object" == typeof config ? config : null), $(this).data("bs.dropdown", data)), "string" == typeof config) {
                if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                data[config]()
              }
            })
          }, Dropdown._clearMenus = function (event) {
            if (!event || 3 !== event.which && ("keyup" !== event.type || 9 === event.which))
              for (var toggles = [].slice.call(document.querySelectorAll(Selector$4_DATA_TOGGLE)), i = 0, len = toggles.length; i < len; i++) {
                var parent = Dropdown._getParentFromElement(toggles[i]),
                  context = $(toggles[i]).data("bs.dropdown"),
                  relatedTarget = {
                    relatedTarget: toggles[i]
                  };
                if (event && "click" === event.type && (relatedTarget.clickEvent = event), context) {
                  var dropdownMenu = context._menu;
                  if ($(parent).hasClass(ClassName$4_SHOW) && !(event && ("click" === event.type && /input|textarea/i.test(event.target.tagName) || "keyup" === event.type && 9 === event.which) && $.contains(parent, event.target))) {
                    var hideEvent = $.Event(Event$4.HIDE, relatedTarget);
                    $(parent).trigger(hideEvent), hideEvent.isDefaultPrevented() || ("ontouchstart" in document.documentElement && $(document.body).children().off("mouseover", null, $.noop), toggles[i].setAttribute("aria-expanded", "false"), $(dropdownMenu).removeClass(ClassName$4_SHOW), $(parent).removeClass(ClassName$4_SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget)))
                  }
                }
              }
          }, Dropdown._getParentFromElement = function (element) {
            var parent, selector = Util.getSelectorFromElement(element);
            return selector && (parent = document.querySelector(selector)), parent || element.parentNode
          }, Dropdown._dataApiKeydownHandler = function (event) {
            if ((/input|textarea/i.test(event.target.tagName) ? !(32 === event.which || 27 !== event.which && (40 !== event.which && 38 !== event.which || $(event.target).closest(Selector$4_MENU).length)) : REGEXP_KEYDOWN.test(event.which)) && (event.preventDefault(), event.stopPropagation(), !this.disabled && !$(this).hasClass(ClassName$4_DISABLED))) {
              var parent = Dropdown._getParentFromElement(this),
                isActive = $(parent).hasClass(ClassName$4_SHOW);
              if (isActive && (!isActive || 27 !== event.which && 32 !== event.which)) {
                var items = [].slice.call(parent.querySelectorAll(Selector$4_VISIBLE_ITEMS));
                if (0 !== items.length) {
                  var index = items.indexOf(event.target);
                  38 === event.which && 0 < index && index--, 40 === event.which && index < items.length - 1 && index++, index < 0 && (index = 0), items[index].focus()
                }
              } else {
                if (27 === event.which) {
                  var toggle = parent.querySelector(Selector$4_DATA_TOGGLE);
                  $(toggle).trigger("focus")
                }
                $(this).trigger("click")
              }
            }
          }, _createClass(Dropdown, null, [{
            key: "VERSION",
            get: function () {
              return "4.2.1"
            }
          }, {
            key: "Default",
            get: function () {
              return Default$2
            }
          }, {
            key: "DefaultType",
            get: function () {
              return DefaultType$2
            }
          }]), Dropdown
        }();
      $(document).on(Event$4.KEYDOWN_DATA_API, Selector$4_DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event$4.KEYDOWN_DATA_API, Selector$4_MENU, Dropdown._dataApiKeydownHandler).on(Event$4.CLICK_DATA_API + " " + Event$4.KEYUP_DATA_API, Dropdown._clearMenus).on(Event$4.CLICK_DATA_API, Selector$4_DATA_TOGGLE, function (event) {
        event.preventDefault(), event.stopPropagation(), Dropdown._jQueryInterface.call($(this), "toggle")
      }).on(Event$4.CLICK_DATA_API, Selector$4_FORM_CHILD, function (e) {
        e.stopPropagation()
      }), $.fn[NAME$4] = Dropdown._jQueryInterface, $.fn[NAME$4].Constructor = Dropdown, $.fn[NAME$4].noConflict = function () {
        return $.fn[NAME$4] = JQUERY_NO_CONFLICT$4, Dropdown._jQueryInterface
      };
      var JQUERY_NO_CONFLICT$5 = $.fn.modal,
        Default$3 = {
          backdrop: !0,
          keyboard: !0,
          focus: !0,
          show: !0
        },
        DefaultType$3 = {
          backdrop: "(boolean|string)",
          keyboard: "boolean",
          focus: "boolean",
          show: "boolean"
        },
        Event$5 = {
          HIDE: "hide.bs.modal",
          HIDDEN: "hidden.bs.modal",
          SHOW: "show.bs.modal",
          SHOWN: "shown.bs.modal",
          FOCUSIN: "focusin.bs.modal",
          RESIZE: "resize.bs.modal",
          CLICK_DISMISS: "click.dismiss.bs.modal",
          KEYDOWN_DISMISS: "keydown.dismiss.bs.modal",
          MOUSEUP_DISMISS: "mouseup.dismiss.bs.modal",
          MOUSEDOWN_DISMISS: "mousedown.dismiss.bs.modal",
          CLICK_DATA_API: "click.bs.modal.data-api"
        },
        ClassName$5_SCROLLBAR_MEASURER = "modal-scrollbar-measure",
        ClassName$5_BACKDROP = "modal-backdrop",
        ClassName$5_OPEN = "modal-open",
        ClassName$5_FADE = "fade",
        ClassName$5_SHOW = "show",
        Selector$5 = {
          DIALOG: ".modal-dialog",
          DATA_TOGGLE: '[data-toggle="modal"]',
          DATA_DISMISS: '[data-dismiss="modal"]',
          FIXED_CONTENT: ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
          STICKY_CONTENT: ".sticky-top"
        },
        Modal = function () {
          function Modal(element, config) {
            this._config = this._getConfig(config), this._element = element, this._dialog = element.querySelector(Selector$5.DIALOG), this._backdrop = null, this._isShown = !1, this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollbarWidth = 0
          }
          var _proto = Modal.prototype;
          return _proto.toggle = function (relatedTarget) {
            return this._isShown ? this.hide() : this.show(relatedTarget)
          }, _proto.show = function (relatedTarget) {
            var _this = this;
            if (!this._isShown && !this._isTransitioning) {
              $(this._element).hasClass(ClassName$5_FADE) && (this._isTransitioning = !0);
              var showEvent = $.Event(Event$5.SHOW, {
                relatedTarget: relatedTarget
              });
              $(this._element).trigger(showEvent), this._isShown || showEvent.isDefaultPrevented() || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), $(this._element).on(Event$5.CLICK_DISMISS, Selector$5.DATA_DISMISS, function (event) {
                return _this.hide(event)
              }), $(this._dialog).on(Event$5.MOUSEDOWN_DISMISS, function () {
                $(_this._element).one(Event$5.MOUSEUP_DISMISS, function (event) {
                  $(event.target).is(_this._element) && (_this._ignoreBackdropClick = !0)
                })
              }), this._showBackdrop(function () {
                return _this._showElement(relatedTarget)
              }))
            }
          }, _proto.hide = function (event) {
            var _this2 = this;
            if (event && event.preventDefault(), this._isShown && !this._isTransitioning) {
              var hideEvent = $.Event(Event$5.HIDE);
              if ($(this._element).trigger(hideEvent), this._isShown && !hideEvent.isDefaultPrevented()) {
                this._isShown = !1;
                var transition = $(this._element).hasClass(ClassName$5_FADE);
                if (transition && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), $(document).off(Event$5.FOCUSIN), $(this._element).removeClass(ClassName$5_SHOW), $(this._element).off(Event$5.CLICK_DISMISS), $(this._dialog).off(Event$5.MOUSEDOWN_DISMISS), transition) {
                  var transitionDuration = Util.getTransitionDurationFromElement(this._element);
                  $(this._element).one(Util.TRANSITION_END, function (event) {
                    return _this2._hideModal(event)
                  }).emulateTransitionEnd(transitionDuration)
                } else this._hideModal()
              }
            }
          }, _proto.dispose = function () {
            [window, this._element, this._dialog].forEach(function (htmlElement) {
              return $(htmlElement).off(".bs.modal")
            }), $(document).off(Event$5.FOCUSIN), $.removeData(this._element, "bs.modal"), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null
          }, _proto.handleUpdate = function () {
            this._adjustDialog()
          }, _proto._getConfig = function (config) {
            return config = _objectSpread({}, Default$3, config), Util.typeCheckConfig("modal", config, DefaultType$3), config
          }, _proto._showElement = function (relatedTarget) {
            var _this3 = this,
              transition = $(this._element).hasClass(ClassName$5_FADE);
            this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.scrollTop = 0, transition && Util.reflow(this._element), $(this._element).addClass(ClassName$5_SHOW), this._config.focus && this._enforceFocus();
            var shownEvent = $.Event(Event$5.SHOWN, {
                relatedTarget: relatedTarget
              }),
              transitionComplete = function () {
                _this3._config.focus && _this3._element.focus(), _this3._isTransitioning = !1, $(_this3._element).trigger(shownEvent)
              };
            if (transition) {
              var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);
              $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration)
            } else transitionComplete()
          }, _proto._enforceFocus = function () {
            var _this4 = this;
            $(document).off(Event$5.FOCUSIN).on(Event$5.FOCUSIN, function (event) {
              document !== event.target && _this4._element !== event.target && 0 === $(_this4._element).has(event.target).length && _this4._element.focus()
            })
          }, _proto._setEscapeEvent = function () {
            var _this5 = this;
            this._isShown && this._config.keyboard ? $(this._element).on(Event$5.KEYDOWN_DISMISS, function (event) {
              27 === event.which && (event.preventDefault(), _this5.hide())
            }) : this._isShown || $(this._element).off(Event$5.KEYDOWN_DISMISS)
          }, _proto._setResizeEvent = function () {
            var _this6 = this;
            this._isShown ? $(window).on(Event$5.RESIZE, function (event) {
              return _this6.handleUpdate(event)
            }) : $(window).off(Event$5.RESIZE)
          }, _proto._hideModal = function () {
            var _this7 = this;
            this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._isTransitioning = !1, this._showBackdrop(function () {
              $(document.body).removeClass(ClassName$5_OPEN), _this7._resetAdjustments(), _this7._resetScrollbar(), $(_this7._element).trigger(Event$5.HIDDEN)
            })
          }, _proto._removeBackdrop = function () {
            this._backdrop && ($(this._backdrop).remove(), this._backdrop = null)
          }, _proto._showBackdrop = function (callback) {
            var _this8 = this,
              animate = $(this._element).hasClass(ClassName$5_FADE) ? ClassName$5_FADE : "";
            if (this._isShown && this._config.backdrop) {
              if (this._backdrop = document.createElement("div"), this._backdrop.className = ClassName$5_BACKDROP, animate && this._backdrop.classList.add(animate), $(this._backdrop).appendTo(document.body), $(this._element).on(Event$5.CLICK_DISMISS, function (event) {
                  _this8._ignoreBackdropClick ? _this8._ignoreBackdropClick = !1 : event.target === event.currentTarget && ("static" === _this8._config.backdrop ? _this8._element.focus() : _this8.hide())
                }), animate && Util.reflow(this._backdrop), $(this._backdrop).addClass(ClassName$5_SHOW), !callback) return;
              if (!animate) return void callback();
              var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
              $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration)
            } else if (!this._isShown && this._backdrop) {
              $(this._backdrop).removeClass(ClassName$5_SHOW);
              var callbackRemove = function () {
                _this8._removeBackdrop(), callback && callback()
              };
              if ($(this._element).hasClass(ClassName$5_FADE)) {
                var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
                $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration)
              } else callbackRemove()
            } else callback && callback()
          }, _proto._adjustDialog = function () {
            var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
            !this._isBodyOverflowing && isModalOverflowing && (this._element.style.paddingLeft = this._scrollbarWidth + "px"), this._isBodyOverflowing && !isModalOverflowing && (this._element.style.paddingRight = this._scrollbarWidth + "px")
          }, _proto._resetAdjustments = function () {
            this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
          }, _proto._checkScrollbar = function () {
            var rect = document.body.getBoundingClientRect();
            this._isBodyOverflowing = rect.left + rect.right < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth()
          }, _proto._setScrollbar = function () {
            var _this9 = this;
            if (this._isBodyOverflowing) {
              var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT)),
                stickyContent = [].slice.call(document.querySelectorAll(Selector$5.STICKY_CONTENT));
              $(fixedContent).each(function (index, element) {
                var actualPadding = element.style.paddingRight,
                  calculatedPadding = $(element).css("padding-right");
                $(element).data("padding-right", actualPadding).css("padding-right", parseFloat(calculatedPadding) + _this9._scrollbarWidth + "px")
              }), $(stickyContent).each(function (index, element) {
                var actualMargin = element.style.marginRight,
                  calculatedMargin = $(element).css("margin-right");
                $(element).data("margin-right", actualMargin).css("margin-right", parseFloat(calculatedMargin) - _this9._scrollbarWidth + "px")
              });
              var actualPadding = document.body.style.paddingRight,
                calculatedPadding = $(document.body).css("padding-right");
              $(document.body).data("padding-right", actualPadding).css("padding-right", parseFloat(calculatedPadding) + this._scrollbarWidth + "px")
            }
            $(document.body).addClass(ClassName$5_OPEN)
          }, _proto._resetScrollbar = function () {
            var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT));
            $(fixedContent).each(function (index, element) {
              var padding = $(element).data("padding-right");
              $(element).removeData("padding-right"), element.style.paddingRight = padding || ""
            });
            var elements = [].slice.call(document.querySelectorAll("" + Selector$5.STICKY_CONTENT));
            $(elements).each(function (index, element) {
              var margin = $(element).data("margin-right");
              void 0 !== margin && $(element).css("margin-right", margin).removeData("margin-right")
            });
            var padding = $(document.body).data("padding-right");
            $(document.body).removeData("padding-right"), document.body.style.paddingRight = padding || ""
          }, _proto._getScrollbarWidth = function () {
            var scrollDiv = document.createElement("div");
            scrollDiv.className = ClassName$5_SCROLLBAR_MEASURER, document.body.appendChild(scrollDiv);
            var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
            return document.body.removeChild(scrollDiv), scrollbarWidth
          }, Modal._jQueryInterface = function (config, relatedTarget) {
            return this.each(function () {
              var data = $(this).data("bs.modal"),
                _config = _objectSpread({}, Default$3, $(this).data(), "object" == typeof config && config ? config : {});
              if (data || (data = new Modal(this, _config), $(this).data("bs.modal", data)), "string" == typeof config) {
                if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                data[config](relatedTarget)
              } else _config.show && data.show(relatedTarget)
            })
          }, _createClass(Modal, null, [{
            key: "VERSION",
            get: function () {
              return "4.2.1"
            }
          }, {
            key: "Default",
            get: function () {
              return Default$3
            }
          }]), Modal
        }();
      $(document).on(Event$5.CLICK_DATA_API, Selector$5.DATA_TOGGLE, function (event) {
        var target, _this10 = this,
          selector = Util.getSelectorFromElement(this);
        selector && (target = document.querySelector(selector));
        var config = $(target).data("bs.modal") ? "toggle" : _objectSpread({}, $(target).data(), $(this).data());
        "A" !== this.tagName && "AREA" !== this.tagName || event.preventDefault();
        var $target = $(target).one(Event$5.SHOW, function (showEvent) {
          showEvent.isDefaultPrevented() || $target.one(Event$5.HIDDEN, function () {
            $(_this10).is(":visible") && _this10.focus()
          })
        });
        Modal._jQueryInterface.call($(target), config, this)
      }), $.fn.modal = Modal._jQueryInterface, $.fn.modal.Constructor = Modal, $.fn.modal.noConflict = function () {
        return $.fn.modal = JQUERY_NO_CONFLICT$5, Modal._jQueryInterface
      };
      var NAME$6 = "tooltip",
        JQUERY_NO_CONFLICT$6 = $.fn.tooltip,
        BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)bs-tooltip\\S+", "g"),
        DefaultType$4 = {
          animation: "boolean",
          template: "string",
          title: "(string|element|function)",
          trigger: "string",
          delay: "(number|object)",
          html: "boolean",
          selector: "(string|boolean)",
          placement: "(string|function)",
          offset: "(number|string)",
          container: "(string|element|boolean)",
          fallbackPlacement: "(string|array)",
          boundary: "(string|element)"
        },
        AttachmentMap$1 = {
          AUTO: "auto",
          TOP: "top",
          RIGHT: "right",
          BOTTOM: "bottom",
          LEFT: "left"
        },
        Default$4 = {
          animation: !0,
          template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
          trigger: "hover focus",
          title: "",
          delay: 0,
          html: !1,
          selector: !1,
          placement: "top",
          offset: 0,
          container: !1,
          fallbackPlacement: "flip",
          boundary: "scrollParent"
        },
        HoverState_SHOW = "show",
        HoverState_OUT = "out",
        Event$6 = {
          HIDE: "hide.bs.tooltip",
          HIDDEN: "hidden.bs.tooltip",
          SHOW: "show.bs.tooltip",
          SHOWN: "shown.bs.tooltip",
          INSERTED: "inserted.bs.tooltip",
          CLICK: "click.bs.tooltip",
          FOCUSIN: "focusin.bs.tooltip",
          FOCUSOUT: "focusout.bs.tooltip",
          MOUSEENTER: "mouseenter.bs.tooltip",
          MOUSELEAVE: "mouseleave.bs.tooltip"
        },
        ClassName$6_FADE = "fade",
        ClassName$6_SHOW = "show",
        Selector$6_TOOLTIP_INNER = ".tooltip-inner",
        Selector$6_ARROW = ".arrow",
        Trigger_HOVER = "hover",
        Trigger_FOCUS = "focus",
        Trigger_CLICK = "click",
        Trigger_MANUAL = "manual",
        Tooltip = function () {
          function Tooltip(element, config) {
            if (void 0 === Popper) throw new TypeError("Bootstrap's tooltips require Popper.js (https://popper.js.org/)");
            this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this.element = element, this.config = this._getConfig(config), this.tip = null, this._setListeners()
          }
          var _proto = Tooltip.prototype;
          return _proto.enable = function () {
            this._isEnabled = !0
          }, _proto.disable = function () {
            this._isEnabled = !1
          }, _proto.toggleEnabled = function () {
            this._isEnabled = !this._isEnabled
          }, _proto.toggle = function (event) {
            if (this._isEnabled)
              if (event) {
                var dataKey = this.constructor.DATA_KEY,
                  context = $(event.currentTarget).data(dataKey);
                context || (context = new this.constructor(event.currentTarget, this._getDelegateConfig()), $(event.currentTarget).data(dataKey, context)), context._activeTrigger.click = !context._activeTrigger.click, context._isWithActiveTrigger() ? context._enter(null, context) : context._leave(null, context)
              } else {
                if ($(this.getTipElement()).hasClass(ClassName$6_SHOW)) return void this._leave(null, this);
                this._enter(null, this)
              }
          }, _proto.dispose = function () {
            clearTimeout(this._timeout), $.removeData(this.element, this.constructor.DATA_KEY), $(this.element).off(this.constructor.EVENT_KEY), $(this.element).closest(".modal").off("hide.bs.modal"), this.tip && $(this.tip).remove(), this._isEnabled = null, this._timeout = null, this._hoverState = null, (this._activeTrigger = null) !== this._popper && this._popper.destroy(), this._popper = null, this.element = null, this.config = null, this.tip = null
          }, _proto.show = function () {
            var _this = this;
            if ("none" === $(this.element).css("display")) throw new Error("Please use show on visible elements");
            var showEvent = $.Event(this.constructor.Event.SHOW);
            if (this.isWithContent() && this._isEnabled) {
              $(this.element).trigger(showEvent);
              var shadowRoot = Util.findShadowRoot(this.element),
                isInTheDom = $.contains(null !== shadowRoot ? shadowRoot : this.element.ownerDocument.documentElement, this.element);
              if (showEvent.isDefaultPrevented() || !isInTheDom) return;
              var tip = this.getTipElement(),
                tipId = Util.getUID(this.constructor.NAME);
              tip.setAttribute("id", tipId), this.element.setAttribute("aria-describedby", tipId), this.setContent(), this.config.animation && $(tip).addClass(ClassName$6_FADE);
              var placement = "function" == typeof this.config.placement ? this.config.placement.call(this, tip, this.element) : this.config.placement,
                attachment = this._getAttachment(placement);
              this.addAttachmentClass(attachment);
              var container = this._getContainer();
              $(tip).data(this.constructor.DATA_KEY, this), $.contains(this.element.ownerDocument.documentElement, this.tip) || $(tip).appendTo(container), $(this.element).trigger(this.constructor.Event.INSERTED), this._popper = new Popper(this.element, tip, {
                placement: attachment,
                modifiers: {
                  offset: {
                    offset: this.config.offset
                  },
                  flip: {
                    behavior: this.config.fallbackPlacement
                  },
                  arrow: {
                    element: Selector$6_ARROW
                  },
                  preventOverflow: {
                    boundariesElement: this.config.boundary
                  }
                },
                onCreate: function (data) {
                  data.originalPlacement !== data.placement && _this._handlePopperPlacementChange(data)
                },
                onUpdate: function (data) {
                  return _this._handlePopperPlacementChange(data)
                }
              }), $(tip).addClass(ClassName$6_SHOW), "ontouchstart" in document.documentElement && $(document.body).children().on("mouseover", null, $.noop);
              var complete = function () {
                _this.config.animation && _this._fixTransition();
                var prevHoverState = _this._hoverState;
                _this._hoverState = null, $(_this.element).trigger(_this.constructor.Event.SHOWN), prevHoverState === HoverState_OUT && _this._leave(null, _this)
              };
              if ($(this.tip).hasClass(ClassName$6_FADE)) {
                var transitionDuration = Util.getTransitionDurationFromElement(this.tip);
                $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration)
              } else complete()
            }
          }, _proto.hide = function (callback) {
            var _this2 = this,
              tip = this.getTipElement(),
              hideEvent = $.Event(this.constructor.Event.HIDE),
              complete = function () {
                _this2._hoverState !== HoverState_SHOW && tip.parentNode && tip.parentNode.removeChild(tip), _this2._cleanTipClass(), _this2.element.removeAttribute("aria-describedby"), $(_this2.element).trigger(_this2.constructor.Event.HIDDEN), null !== _this2._popper && _this2._popper.destroy(), callback && callback()
              };
            if ($(this.element).trigger(hideEvent), !hideEvent.isDefaultPrevented()) {
              if ($(tip).removeClass(ClassName$6_SHOW), "ontouchstart" in document.documentElement && $(document.body).children().off("mouseover", null, $.noop), this._activeTrigger[Trigger_CLICK] = !1, this._activeTrigger[Trigger_FOCUS] = !1, this._activeTrigger[Trigger_HOVER] = !1, $(this.tip).hasClass(ClassName$6_FADE)) {
                var transitionDuration = Util.getTransitionDurationFromElement(tip);
                $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration)
              } else complete();
              this._hoverState = ""
            }
          }, _proto.update = function () {
            null !== this._popper && this._popper.scheduleUpdate()
          }, _proto.isWithContent = function () {
            return Boolean(this.getTitle())
          }, _proto.addAttachmentClass = function (attachment) {
            $(this.getTipElement()).addClass("bs-tooltip-" + attachment)
          }, _proto.getTipElement = function () {
            return this.tip = this.tip || $(this.config.template)[0], this.tip
          }, _proto.setContent = function () {
            var tip = this.getTipElement();
            this.setElementContent($(tip.querySelectorAll(Selector$6_TOOLTIP_INNER)), this.getTitle()), $(tip).removeClass(ClassName$6_FADE + " " + ClassName$6_SHOW)
          }, _proto.setElementContent = function ($element, content) {
            var html = this.config.html;
            "object" == typeof content && (content.nodeType || content.jquery) ? html ? $(content).parent().is($element) || $element.empty().append(content) : $element.text($(content).text()) : $element[html ? "html" : "text"](content)
          }, _proto.getTitle = function () {
            var title = this.element.getAttribute("data-original-title");
            return title || (title = "function" == typeof this.config.title ? this.config.title.call(this.element) : this.config.title), title
          }, _proto._getContainer = function () {
            return !1 === this.config.container ? document.body : Util.isElement(this.config.container) ? $(this.config.container) : $(document).find(this.config.container)
          }, _proto._getAttachment = function (placement) {
            return AttachmentMap$1[placement.toUpperCase()]
          }, _proto._setListeners = function () {
            var _this3 = this;
            this.config.trigger.split(" ").forEach(function (trigger) {
              if ("click" === trigger) $(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {
                return _this3.toggle(event)
              });
              else if (trigger !== Trigger_MANUAL) {
                var eventIn = trigger === Trigger_HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN,
                  eventOut = trigger === Trigger_HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;
                $(_this3.element).on(eventIn, _this3.config.selector, function (event) {
                  return _this3._enter(event)
                }).on(eventOut, _this3.config.selector, function (event) {
                  return _this3._leave(event)
                })
              }
            }), $(this.element).closest(".modal").on("hide.bs.modal", function () {
              _this3.element && _this3.hide()
            }), this.config.selector ? this.config = _objectSpread({}, this.config, {
              trigger: "manual",
              selector: ""
            }) : this._fixTitle()
          }, _proto._fixTitle = function () {
            var titleType = typeof this.element.getAttribute("data-original-title");
            (this.element.getAttribute("title") || "string" !== titleType) && (this.element.setAttribute("data-original-title", this.element.getAttribute("title") || ""), this.element.setAttribute("title", ""))
          }, _proto._enter = function (event, context) {
            var dataKey = this.constructor.DATA_KEY;
            (context = context || $(event.currentTarget).data(dataKey)) || (context = new this.constructor(event.currentTarget, this._getDelegateConfig()), $(event.currentTarget).data(dataKey, context)), event && (context._activeTrigger["focusin" === event.type ? Trigger_FOCUS : Trigger_HOVER] = !0), $(context.getTipElement()).hasClass(ClassName$6_SHOW) || context._hoverState === HoverState_SHOW ? context._hoverState = HoverState_SHOW : (clearTimeout(context._timeout), context._hoverState = HoverState_SHOW, context.config.delay && context.config.delay.show ? context._timeout = setTimeout(function () {
              context._hoverState === HoverState_SHOW && context.show()
            }, context.config.delay.show) : context.show())
          }, _proto._leave = function (event, context) {
            var dataKey = this.constructor.DATA_KEY;
            (context = context || $(event.currentTarget).data(dataKey)) || (context = new this.constructor(event.currentTarget, this._getDelegateConfig()), $(event.currentTarget).data(dataKey, context)), event && (context._activeTrigger["focusout" === event.type ? Trigger_FOCUS : Trigger_HOVER] = !1), context._isWithActiveTrigger() || (clearTimeout(context._timeout), context._hoverState = HoverState_OUT, context.config.delay && context.config.delay.hide ? context._timeout = setTimeout(function () {
              context._hoverState === HoverState_OUT && context.hide()
            }, context.config.delay.hide) : context.hide())
          }, _proto._isWithActiveTrigger = function () {
            for (var trigger in this._activeTrigger)
              if (this._activeTrigger[trigger]) return !0;
            return !1
          }, _proto._getConfig = function (config) {
            return "number" == typeof (config = _objectSpread({}, this.constructor.Default, $(this.element).data(), "object" == typeof config && config ? config : {})).delay && (config.delay = {
              show: config.delay,
              hide: config.delay
            }), "number" == typeof config.title && (config.title = config.title.toString()), "number" == typeof config.content && (config.content = config.content.toString()), Util.typeCheckConfig(NAME$6, config, this.constructor.DefaultType), config
          }, _proto._getDelegateConfig = function () {
            var config = {};
            if (this.config)
              for (var key in this.config) this.constructor.Default[key] !== this.config[key] && (config[key] = this.config[key]);
            return config
          }, _proto._cleanTipClass = function () {
            var $tip = $(this.getTipElement()),
              tabClass = $tip.attr("class").match(BSCLS_PREFIX_REGEX);
            null !== tabClass && tabClass.length && $tip.removeClass(tabClass.join(""))
          }, _proto._handlePopperPlacementChange = function (popperData) {
            var popperInstance = popperData.instance;
            this.tip = popperInstance.popper, this._cleanTipClass(), this.addAttachmentClass(this._getAttachment(popperData.placement))
          }, _proto._fixTransition = function () {
            var tip = this.getTipElement(),
              initConfigAnimation = this.config.animation;
            null === tip.getAttribute("x-placement") && ($(tip).removeClass(ClassName$6_FADE), this.config.animation = !1, this.hide(), this.show(), this.config.animation = initConfigAnimation)
          }, Tooltip._jQueryInterface = function (config) {
            return this.each(function () {
              var data = $(this).data("bs.tooltip"),
                _config = "object" == typeof config && config;
              if ((data || !/dispose|hide/.test(config)) && (data || (data = new Tooltip(this, _config), $(this).data("bs.tooltip", data)), "string" == typeof config)) {
                if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                data[config]()
              }
            })
          }, _createClass(Tooltip, null, [{
            key: "VERSION",
            get: function () {
              return "4.2.1"
            }
          }, {
            key: "Default",
            get: function () {
              return Default$4
            }
          }, {
            key: "NAME",
            get: function () {
              return NAME$6
            }
          }, {
            key: "DATA_KEY",
            get: function () {
              return "bs.tooltip"
            }
          }, {
            key: "Event",
            get: function () {
              return Event$6
            }
          }, {
            key: "EVENT_KEY",
            get: function () {
              return ".bs.tooltip"
            }
          }, {
            key: "DefaultType",
            get: function () {
              return DefaultType$4
            }
          }]), Tooltip
        }();
      $.fn.tooltip = Tooltip._jQueryInterface, $.fn.tooltip.Constructor = Tooltip, $.fn.tooltip.noConflict = function () {
        return $.fn.tooltip = JQUERY_NO_CONFLICT$6, Tooltip._jQueryInterface
      };
      var NAME$7 = "popover",
        JQUERY_NO_CONFLICT$7 = $.fn.popover,
        BSCLS_PREFIX_REGEX$1 = new RegExp("(^|\\s)bs-popover\\S+", "g"),
        Default$5 = _objectSpread({}, Tooltip.Default, {
          placement: "right",
          trigger: "click",
          content: "",
          template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
        }),
        DefaultType$5 = _objectSpread({}, Tooltip.DefaultType, {
          content: "(string|element|function)"
        }),
        ClassName$7_FADE = "fade",
        ClassName$7_SHOW = "show",
        Selector$7_TITLE = ".popover-header",
        Selector$7_CONTENT = ".popover-body",
        Event$7 = {
          HIDE: "hide.bs.popover",
          HIDDEN: "hidden.bs.popover",
          SHOW: "show.bs.popover",
          SHOWN: "shown.bs.popover",
          INSERTED: "inserted.bs.popover",
          CLICK: "click.bs.popover",
          FOCUSIN: "focusin.bs.popover",
          FOCUSOUT: "focusout.bs.popover",
          MOUSEENTER: "mouseenter.bs.popover",
          MOUSELEAVE: "mouseleave.bs.popover"
        },
        Popover = function (_Tooltip) {
          var subClass, superClass;

          function Popover() {
            return _Tooltip.apply(this, arguments) || this
          }
          superClass = _Tooltip, (subClass = Popover).prototype = Object.create(superClass.prototype), (subClass.prototype.constructor = subClass).__proto__ = superClass;
          var _proto = Popover.prototype;
          return _proto.isWithContent = function () {
            return this.getTitle() || this._getContent()
          }, _proto.addAttachmentClass = function (attachment) {
            $(this.getTipElement()).addClass("bs-popover-" + attachment)
          }, _proto.getTipElement = function () {
            return this.tip = this.tip || $(this.config.template)[0], this.tip
          }, _proto.setContent = function () {
            var $tip = $(this.getTipElement());
            this.setElementContent($tip.find(Selector$7_TITLE), this.getTitle());
            var content = this._getContent();
            "function" == typeof content && (content = content.call(this.element)), this.setElementContent($tip.find(Selector$7_CONTENT), content), $tip.removeClass(ClassName$7_FADE + " " + ClassName$7_SHOW)
          }, _proto._getContent = function () {
            return this.element.getAttribute("data-content") || this.config.content
          }, _proto._cleanTipClass = function () {
            var $tip = $(this.getTipElement()),
              tabClass = $tip.attr("class").match(BSCLS_PREFIX_REGEX$1);
            null !== tabClass && 0 < tabClass.length && $tip.removeClass(tabClass.join(""))
          }, Popover._jQueryInterface = function (config) {
            return this.each(function () {
              var data = $(this).data("bs.popover"),
                _config = "object" == typeof config ? config : null;
              if ((data || !/dispose|hide/.test(config)) && (data || (data = new Popover(this, _config), $(this).data("bs.popover", data)), "string" == typeof config)) {
                if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                data[config]()
              }
            })
          }, _createClass(Popover, null, [{
            key: "VERSION",
            get: function () {
              return "4.2.1"
            }
          }, {
            key: "Default",
            get: function () {
              return Default$5
            }
          }, {
            key: "NAME",
            get: function () {
              return NAME$7
            }
          }, {
            key: "DATA_KEY",
            get: function () {
              return "bs.popover"
            }
          }, {
            key: "Event",
            get: function () {
              return Event$7
            }
          }, {
            key: "EVENT_KEY",
            get: function () {
              return ".bs.popover"
            }
          }, {
            key: "DefaultType",
            get: function () {
              return DefaultType$5
            }
          }]), Popover
        }(Tooltip);
      $.fn.popover = Popover._jQueryInterface, $.fn.popover.Constructor = Popover, $.fn.popover.noConflict = function () {
        return $.fn.popover = JQUERY_NO_CONFLICT$7, Popover._jQueryInterface
      };
      var NAME$8 = "scrollspy",
        JQUERY_NO_CONFLICT$8 = $.fn[NAME$8],
        Default$6 = {
          offset: 10,
          method: "auto",
          target: ""
        },
        DefaultType$6 = {
          offset: "number",
          method: "string",
          target: "(string|element)"
        },
        Event$8 = {
          ACTIVATE: "activate.bs.scrollspy",
          SCROLL: "scroll.bs.scrollspy",
          LOAD_DATA_API: "load.bs.scrollspy.data-api"
        },
        ClassName$8_DROPDOWN_ITEM = "dropdown-item",
        ClassName$8_ACTIVE = "active",
        Selector$8 = {
          DATA_SPY: '[data-spy="scroll"]',
          ACTIVE: ".active",
          NAV_LIST_GROUP: ".nav, .list-group",
          NAV_LINKS: ".nav-link",
          NAV_ITEMS: ".nav-item",
          LIST_ITEMS: ".list-group-item",
          DROPDOWN: ".dropdown",
          DROPDOWN_ITEMS: ".dropdown-item",
          DROPDOWN_TOGGLE: ".dropdown-toggle"
        },
        OffsetMethod_OFFSET = "offset",
        OffsetMethod_POSITION = "position",
        ScrollSpy = function () {
          function ScrollSpy(element, config) {
            var _this = this;
            this._element = element, this._scrollElement = "BODY" === element.tagName ? window : element, this._config = this._getConfig(config), this._selector = this._config.target + " " + Selector$8.NAV_LINKS + "," + this._config.target + " " + Selector$8.LIST_ITEMS + "," + this._config.target + " " + Selector$8.DROPDOWN_ITEMS, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, $(this._scrollElement).on(Event$8.SCROLL, function (event) {
              return _this._process(event)
            }), this.refresh(), this._process()
          }
          var _proto = ScrollSpy.prototype;
          return _proto.refresh = function () {
            var _this2 = this,
              autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod_OFFSET : OffsetMethod_POSITION,
              offsetMethod = "auto" === this._config.method ? autoMethod : this._config.method,
              offsetBase = offsetMethod === OffsetMethod_POSITION ? this._getScrollTop() : 0;
            this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), [].slice.call(document.querySelectorAll(this._selector)).map(function (element) {
              var target, targetSelector = Util.getSelectorFromElement(element);
              if (targetSelector && (target = document.querySelector(targetSelector)), target) {
                var targetBCR = target.getBoundingClientRect();
                if (targetBCR.width || targetBCR.height) return [$(target)[offsetMethod]().top + offsetBase, targetSelector]
              }
              return null
            }).filter(function (item) {
              return item
            }).sort(function (a, b) {
              return a[0] - b[0]
            }).forEach(function (item) {
              _this2._offsets.push(item[0]), _this2._targets.push(item[1])
            })
          }, _proto.dispose = function () {
            $.removeData(this._element, "bs.scrollspy"), $(this._scrollElement).off(".bs.scrollspy"), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null
          }, _proto._getConfig = function (config) {
            if ("string" != typeof (config = _objectSpread({}, Default$6, "object" == typeof config && config ? config : {})).target) {
              var id = $(config.target).attr("id");
              id || (id = Util.getUID(NAME$8), $(config.target).attr("id", id)), config.target = "#" + id
            }
            return Util.typeCheckConfig(NAME$8, config, DefaultType$6), config
          }, _proto._getScrollTop = function () {
            return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop
          }, _proto._getScrollHeight = function () {
            return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
          }, _proto._getOffsetHeight = function () {
            return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height
          }, _proto._process = function () {
            var scrollTop = this._getScrollTop() + this._config.offset,
              scrollHeight = this._getScrollHeight(),
              maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
            if (this._scrollHeight !== scrollHeight && this.refresh(), maxScroll <= scrollTop) {
              var target = this._targets[this._targets.length - 1];
              this._activeTarget !== target && this._activate(target)
            } else {
              if (this._activeTarget && scrollTop < this._offsets[0] && 0 < this._offsets[0]) return this._activeTarget = null, void this._clear();
              for (var i = this._offsets.length; i--;) {
                this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (void 0 === this._offsets[i + 1] || scrollTop < this._offsets[i + 1]) && this._activate(this._targets[i])
              }
            }
          }, _proto._activate = function (target) {
            this._activeTarget = target, this._clear();
            var queries = this._selector.split(",").map(function (selector) {
                return selector + '[data-target="' + target + '"],' + selector + '[href="' + target + '"]'
              }),
              $link = $([].slice.call(document.querySelectorAll(queries.join(","))));
            $link.hasClass(ClassName$8_DROPDOWN_ITEM) ? ($link.closest(Selector$8.DROPDOWN).find(Selector$8.DROPDOWN_TOGGLE).addClass(ClassName$8_ACTIVE), $link.addClass(ClassName$8_ACTIVE)) : ($link.addClass(ClassName$8_ACTIVE), $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_LINKS + ", " + Selector$8.LIST_ITEMS).addClass(ClassName$8_ACTIVE), $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_ITEMS).children(Selector$8.NAV_LINKS).addClass(ClassName$8_ACTIVE)), $(this._scrollElement).trigger(Event$8.ACTIVATE, {
              relatedTarget: target
            })
          }, _proto._clear = function () {
            [].slice.call(document.querySelectorAll(this._selector)).filter(function (node) {
              return node.classList.contains(ClassName$8_ACTIVE)
            }).forEach(function (node) {
              return node.classList.remove(ClassName$8_ACTIVE)
            })
          }, ScrollSpy._jQueryInterface = function (config) {
            return this.each(function () {
              var data = $(this).data("bs.scrollspy");
              if (data || (data = new ScrollSpy(this, "object" == typeof config && config), $(this).data("bs.scrollspy", data)), "string" == typeof config) {
                if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                data[config]()
              }
            })
          }, _createClass(ScrollSpy, null, [{
            key: "VERSION",
            get: function () {
              return "4.2.1"
            }
          }, {
            key: "Default",
            get: function () {
              return Default$6
            }
          }]), ScrollSpy
        }();
      $(window).on(Event$8.LOAD_DATA_API, function () {
        for (var scrollSpys = [].slice.call(document.querySelectorAll(Selector$8.DATA_SPY)), i = scrollSpys.length; i--;) {
          var $spy = $(scrollSpys[i]);
          ScrollSpy._jQueryInterface.call($spy, $spy.data())
        }
      }), $.fn[NAME$8] = ScrollSpy._jQueryInterface, $.fn[NAME$8].Constructor = ScrollSpy, $.fn[NAME$8].noConflict = function () {
        return $.fn[NAME$8] = JQUERY_NO_CONFLICT$8, ScrollSpy._jQueryInterface
      };
      var JQUERY_NO_CONFLICT$9 = $.fn.tab,
        Event$9 = {
          HIDE: "hide.bs.tab",
          HIDDEN: "hidden.bs.tab",
          SHOW: "show.bs.tab",
          SHOWN: "shown.bs.tab",
          CLICK_DATA_API: "click.bs.tab.data-api"
        },
        ClassName$9_DROPDOWN_MENU = "dropdown-menu",
        ClassName$9_ACTIVE = "active",
        ClassName$9_DISABLED = "disabled",
        ClassName$9_FADE = "fade",
        ClassName$9_SHOW = "show",
        Selector$9_DROPDOWN = ".dropdown",
        Selector$9_NAV_LIST_GROUP = ".nav, .list-group",
        Selector$9_ACTIVE = ".active",
        Selector$9_ACTIVE_UL = "> li > .active",
        Selector$9_DATA_TOGGLE = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
        Selector$9_DROPDOWN_TOGGLE = ".dropdown-toggle",
        Selector$9_DROPDOWN_ACTIVE_CHILD = "> .dropdown-menu .active",
        Tab = function () {
          function Tab(element) {
            this._element = element
          }
          var _proto = Tab.prototype;
          return _proto.show = function () {
            var _this = this;
            if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName$9_ACTIVE) || $(this._element).hasClass(ClassName$9_DISABLED))) {
              var target, previous, listElement = $(this._element).closest(Selector$9_NAV_LIST_GROUP)[0],
                selector = Util.getSelectorFromElement(this._element);
              if (listElement) {
                var itemSelector = "UL" === listElement.nodeName || "OL" === listElement.nodeName ? Selector$9_ACTIVE_UL : Selector$9_ACTIVE;
                previous = (previous = $.makeArray($(listElement).find(itemSelector)))[previous.length - 1]
              }
              var hideEvent = $.Event(Event$9.HIDE, {
                  relatedTarget: this._element
                }),
                showEvent = $.Event(Event$9.SHOW, {
                  relatedTarget: previous
                });
              if (previous && $(previous).trigger(hideEvent), $(this._element).trigger(showEvent), !showEvent.isDefaultPrevented() && !hideEvent.isDefaultPrevented()) {
                selector && (target = document.querySelector(selector)), this._activate(this._element, listElement);
                var complete = function () {
                  var hiddenEvent = $.Event(Event$9.HIDDEN, {
                      relatedTarget: _this._element
                    }),
                    shownEvent = $.Event(Event$9.SHOWN, {
                      relatedTarget: previous
                    });
                  $(previous).trigger(hiddenEvent), $(_this._element).trigger(shownEvent)
                };
                target ? this._activate(target, target.parentNode, complete) : complete()
              }
            }
          }, _proto.dispose = function () {
            $.removeData(this._element, "bs.tab"), this._element = null
          }, _proto._activate = function (element, container, callback) {
            var _this2 = this,
              active = (!container || "UL" !== container.nodeName && "OL" !== container.nodeName ? $(container).children(Selector$9_ACTIVE) : $(container).find(Selector$9_ACTIVE_UL))[0],
              isTransitioning = callback && active && $(active).hasClass(ClassName$9_FADE),
              complete = function () {
                return _this2._transitionComplete(element, active, callback)
              };
            if (active && isTransitioning) {
              var transitionDuration = Util.getTransitionDurationFromElement(active);
              $(active).removeClass(ClassName$9_SHOW).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration)
            } else complete()
          }, _proto._transitionComplete = function (element, active, callback) {
            if (active) {
              $(active).removeClass(ClassName$9_ACTIVE);
              var dropdownChild = $(active.parentNode).find(Selector$9_DROPDOWN_ACTIVE_CHILD)[0];
              dropdownChild && $(dropdownChild).removeClass(ClassName$9_ACTIVE), "tab" === active.getAttribute("role") && active.setAttribute("aria-selected", !1)
            }
            if ($(element).addClass(ClassName$9_ACTIVE), "tab" === element.getAttribute("role") && element.setAttribute("aria-selected", !0), Util.reflow(element), $(element).addClass(ClassName$9_SHOW), element.parentNode && $(element.parentNode).hasClass(ClassName$9_DROPDOWN_MENU)) {
              var dropdownElement = $(element).closest(Selector$9_DROPDOWN)[0];
              if (dropdownElement) {
                var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(Selector$9_DROPDOWN_TOGGLE));
                $(dropdownToggleList).addClass(ClassName$9_ACTIVE)
              }
              element.setAttribute("aria-expanded", !0)
            }
            callback && callback()
          }, Tab._jQueryInterface = function (config) {
            return this.each(function () {
              var $this = $(this),
                data = $this.data("bs.tab");
              if (data || (data = new Tab(this), $this.data("bs.tab", data)), "string" == typeof config) {
                if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                data[config]()
              }
            })
          }, _createClass(Tab, null, [{
            key: "VERSION",
            get: function () {
              return "4.2.1"
            }
          }]), Tab
        }();
      $(document).on(Event$9.CLICK_DATA_API, Selector$9_DATA_TOGGLE, function (event) {
        event.preventDefault(), Tab._jQueryInterface.call($(this), "show")
      }), $.fn.tab = Tab._jQueryInterface, $.fn.tab.Constructor = Tab, $.fn.tab.noConflict = function () {
        return $.fn.tab = JQUERY_NO_CONFLICT$9, Tab._jQueryInterface
      };
      var JQUERY_NO_CONFLICT$a = $.fn.toast,
        Event$a = {
          CLICK_DISMISS: "click.dismiss.bs.toast",
          HIDE: "hide.bs.toast",
          HIDDEN: "hidden.bs.toast",
          SHOW: "show.bs.toast",
          SHOWN: "shown.bs.toast"
        },
        ClassName$a_FADE = "fade",
        ClassName$a_HIDE = "hide",
        ClassName$a_SHOW = "show",
        ClassName$a_SHOWING = "showing",
        DefaultType$7 = {
          animation: "boolean",
          autohide: "boolean",
          delay: "number"
        },
        Default$7 = {
          animation: !0,
          autohide: !0,
          delay: 500
        },
        Selector$a_DATA_DISMISS = '[data-dismiss="toast"]',
        Toast = function () {
          function Toast(element, config) {
            this._element = element, this._config = this._getConfig(config), this._timeout = null, this._setListeners()
          }
          var _proto = Toast.prototype;
          return _proto.show = function () {
            var _this = this;
            $(this._element).trigger(Event$a.SHOW), this._config.animation && this._element.classList.add(ClassName$a_FADE);
            var complete = function () {
              _this._element.classList.remove(ClassName$a_SHOWING), _this._element.classList.add(ClassName$a_SHOW), $(_this._element).trigger(Event$a.SHOWN), _this._config.autohide && _this.hide()
            };
            if (this._element.classList.remove(ClassName$a_HIDE), this._element.classList.add(ClassName$a_SHOWING), this._config.animation) {
              var transitionDuration = Util.getTransitionDurationFromElement(this._element);
              $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration)
            } else complete()
          }, _proto.hide = function (withoutTimeout) {
            var _this2 = this;
            this._element.classList.contains(ClassName$a_SHOW) && ($(this._element).trigger(Event$a.HIDE), withoutTimeout ? this._close() : this._timeout = setTimeout(function () {
              _this2._close()
            }, this._config.delay))
          }, _proto.dispose = function () {
            clearTimeout(this._timeout), this._timeout = null, this._element.classList.contains(ClassName$a_SHOW) && this._element.classList.remove(ClassName$a_SHOW), $(this._element).off(Event$a.CLICK_DISMISS), $.removeData(this._element, "bs.toast"), this._element = null, this._config = null
          }, _proto._getConfig = function (config) {
            return config = _objectSpread({}, Default$7, $(this._element).data(), "object" == typeof config && config ? config : {}), Util.typeCheckConfig("toast", config, this.constructor.DefaultType), config
          }, _proto._setListeners = function () {
            var _this3 = this;
            $(this._element).on(Event$a.CLICK_DISMISS, Selector$a_DATA_DISMISS, function () {
              return _this3.hide(!0)
            })
          }, _proto._close = function () {
            var _this4 = this,
              complete = function () {
                _this4._element.classList.add(ClassName$a_HIDE), $(_this4._element).trigger(Event$a.HIDDEN)
              };
            if (this._element.classList.remove(ClassName$a_SHOW), this._config.animation) {
              var transitionDuration = Util.getTransitionDurationFromElement(this._element);
              $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration)
            } else complete()
          }, Toast._jQueryInterface = function (config) {
            return this.each(function () {
              var $element = $(this),
                data = $element.data("bs.toast");
              if (data || (data = new Toast(this, "object" == typeof config && config), $element.data("bs.toast", data)), "string" == typeof config) {
                if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                data[config](this)
              }
            })
          }, _createClass(Toast, null, [{
            key: "VERSION",
            get: function () {
              return "4.2.1"
            }
          }, {
            key: "DefaultType",
            get: function () {
              return DefaultType$7
            }
          }]), Toast
        }();
      $.fn.toast = Toast._jQueryInterface, $.fn.toast.Constructor = Toast, $.fn.toast.noConflict = function () {
          return $.fn.toast = JQUERY_NO_CONFLICT$a, Toast._jQueryInterface
        },
        function () {
          if (void 0 === $) throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");
          var version = $.fn.jquery.split(" ")[0].split(".");
          if (version[0] < 2 && version[1] < 9 || 1 === version[0] && 9 === version[1] && version[2] < 1 || 4 <= version[0]) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0")
        }(), exports.Util = Util, exports.Alert = Alert, exports.Button = Button, exports.Carousel = Carousel, exports.Collapse = Collapse, exports.Dropdown = Dropdown, exports.Modal = Modal, exports.Popover = Popover, exports.Scrollspy = ScrollSpy, exports.Tab = Tab, exports.Toast = Toast, exports.Tooltip = Tooltip, Object.defineProperty(exports, "__esModule", {
          value: !0
        })
    }, "object" == typeof exports && void 0 !== module ? factory(exports, require("popper.js"), require("jquery")) : "function" == typeof define && define.amd ? define(["exports", "popper.js", "jquery"], factory) : factory(global.bootstrap = {}, global.Popper, global.jQuery)
  }, {
    jquery: 7,
    "popper.js": 9
  }],
  2: [function (require, module, exports) {
    var global, factory;
    global = this, factory = function () {
      "use strict";
      var __assign = function () {
          return (__assign = Object.assign || function (t) {
            for (var s, i = 1, n = arguments.length; i < n; i++)
              for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
            return t
          }).apply(this, arguments)
        },
        HOOKS = ["onChange", "onClose", "onDayCreate", "onDestroy", "onKeyDown", "onMonthChange", "onOpen", "onParseConfig", "onReady", "onValueUpdate", "onYearChange", "onPreCalendarPosition"],
        defaults = {
          _disable: [],
          _enable: [],
          allowInput: !1,
          altFormat: "F j, Y",
          altInput: !1,
          altInputClass: "form-control input",
          animate: "object" == typeof window && -1 === window.navigator.userAgent.indexOf("MSIE"),
          ariaDateFormat: "F j, Y",
          clickOpens: !0,
          closeOnSelect: !0,
          conjunction: ", ",
          dateFormat: "Y-m-d",
          defaultHour: 12,
          defaultMinute: 0,
          defaultSeconds: 0,
          disable: [],
          disableMobile: !1,
          enable: [],
          enableSeconds: !1,
          enableTime: !1,
          errorHandler: function (err) {
            return "undefined" != typeof console && console.warn(err)
          },
          getWeek: function (givenDate) {
            var date = new Date(givenDate.getTime());
            date.setHours(0, 0, 0, 0), date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
            var week1 = new Date(date.getFullYear(), 0, 4);
            return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7)
          },
          hourIncrement: 1,
          ignoredFocusElements: [],
          inline: !1,
          locale: "default",
          minuteIncrement: 5,
          mode: "single",
          nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
          noCalendar: !1,
          now: new Date,
          onChange: [],
          onClose: [],
          onDayCreate: [],
          onDestroy: [],
          onKeyDown: [],
          onMonthChange: [],
          onOpen: [],
          onParseConfig: [],
          onReady: [],
          onValueUpdate: [],
          onYearChange: [],
          onPreCalendarPosition: [],
          plugins: [],
          position: "auto",
          positionElement: void 0,
          prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
          shorthandCurrentMonth: !1,
          showMonths: 1,
          static: !1,
          time_24hr: !1,
          weekNumbers: !1,
          wrap: !1
        },
        english = {
          weekdays: {
            shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
          },
          months: {
            shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
          },
          daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
          firstDayOfWeek: 0,
          ordinal: function (nth) {
            var s = nth % 100;
            if (3 < s && s < 21) return "th";
            switch (s % 10) {
              case 1:
                return "st";
              case 2:
                return "nd";
              case 3:
                return "rd";
              default:
                return "th"
            }
          },
          rangeSeparator: " to ",
          weekAbbreviation: "Wk",
          scrollTitle: "Scroll to increment",
          toggleTitle: "Click to toggle",
          amPM: ["AM", "PM"],
          yearAriaLabel: "Year"
        },
        pad = function (number) {
          return ("0" + number).slice(-2)
        },
        int = function (bool) {
          return !0 === bool ? 1 : 0
        };

      function debounce(func, wait, immediate) {
        var timeout;
        return void 0 === immediate && (immediate = !1),
          function () {
            var context = this,
              args = arguments;
            null !== timeout && clearTimeout(timeout), timeout = window.setTimeout(function () {
              timeout = null, immediate || func.apply(context, args)
            }, wait), immediate && !timeout && func.apply(context, args)
          }
      }
      var arrayify = function (obj) {
        return obj instanceof Array ? obj : [obj]
      };

      function toggleClass(elem, className, bool) {
        if (!0 === bool) return elem.classList.add(className);
        elem.classList.remove(className)
      }

      function createElement(tag, className, content) {
        var e = window.document.createElement(tag);
        return className = className || "", content = content || "", e.className = className, void 0 !== content && (e.textContent = content), e
      }

      function clearNode(node) {
        for (; node.firstChild;) node.removeChild(node.firstChild)
      }

      function createNumberInput(inputClassName, opts) {
        var wrapper = createElement("div", "numInputWrapper"),
          numInput = createElement("input", "numInput " + inputClassName),
          arrowUp = createElement("span", "arrowUp"),
          arrowDown = createElement("span", "arrowDown");
        if (-1 === navigator.userAgent.indexOf("MSIE 9.0") ? numInput.type = "number" : (numInput.type = "text", numInput.pattern = "\\d*"), void 0 !== opts)
          for (var key in opts) numInput.setAttribute(key, opts[key]);
        return wrapper.appendChild(numInput), wrapper.appendChild(arrowUp), wrapper.appendChild(arrowDown), wrapper
      }
      var do_nothing = function () {},
        monthToStr = function (monthNumber, shorthand, locale) {
          return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber]
        },
        revFormat = {
          D: do_nothing,
          F: function (dateObj, monthName, locale) {
            dateObj.setMonth(locale.months.longhand.indexOf(monthName))
          },
          G: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour))
          },
          H: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour))
          },
          J: function (dateObj, day) {
            dateObj.setDate(parseFloat(day))
          },
          K: function (dateObj, amPM, locale) {
            dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)))
          },
          M: function (dateObj, shortMonth, locale) {
            dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth))
          },
          S: function (dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds))
          },
          U: function (_, unixSeconds) {
            return new Date(1e3 * parseFloat(unixSeconds))
          },
          W: function (dateObj, weekNum) {
            var weekNumber = parseInt(weekNum);
            return new Date(dateObj.getFullYear(), 0, 2 + 7 * (weekNumber - 1), 0, 0, 0, 0)
          },
          Y: function (dateObj, year) {
            dateObj.setFullYear(parseFloat(year))
          },
          Z: function (_, ISODate) {
            return new Date(ISODate)
          },
          d: function (dateObj, day) {
            dateObj.setDate(parseFloat(day))
          },
          h: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour))
          },
          i: function (dateObj, minutes) {
            dateObj.setMinutes(parseFloat(minutes))
          },
          j: function (dateObj, day) {
            dateObj.setDate(parseFloat(day))
          },
          l: do_nothing,
          m: function (dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1)
          },
          n: function (dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1)
          },
          s: function (dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds))
          },
          u: function (_, unixMillSeconds) {
            return new Date(parseFloat(unixMillSeconds))
          },
          w: do_nothing,
          y: function (dateObj, year) {
            dateObj.setFullYear(2e3 + parseFloat(year))
          }
        },
        tokenRegex = {
          D: "(\\w+)",
          F: "(\\w+)",
          G: "(\\d\\d|\\d)",
          H: "(\\d\\d|\\d)",
          J: "(\\d\\d|\\d)\\w+",
          K: "",
          M: "(\\w+)",
          S: "(\\d\\d|\\d)",
          U: "(.+)",
          W: "(\\d\\d|\\d)",
          Y: "(\\d{4})",
          Z: "(.+)",
          d: "(\\d\\d|\\d)",
          h: "(\\d\\d|\\d)",
          i: "(\\d\\d|\\d)",
          j: "(\\d\\d|\\d)",
          l: "(\\w+)",
          m: "(\\d\\d|\\d)",
          n: "(\\d\\d|\\d)",
          s: "(\\d\\d|\\d)",
          u: "(.+)",
          w: "(\\d\\d|\\d)",
          y: "(\\d{2})"
        },
        formats = {
          Z: function (date) {
            return date.toISOString()
          },
          D: function (date, locale, options) {
            return locale.weekdays.shorthand[formats.w(date, locale, options)]
          },
          F: function (date, locale, options) {
            return monthToStr(formats.n(date, locale, options) - 1, !1, locale)
          },
          G: function (date, locale, options) {
            return pad(formats.h(date, locale, options))
          },
          H: function (date) {
            return pad(date.getHours())
          },
          J: function (date, locale) {
            return void 0 !== locale.ordinal ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate()
          },
          K: function (date, locale) {
            return locale.amPM[int(11 < date.getHours())]
          },
          M: function (date, locale) {
            return monthToStr(date.getMonth(), !0, locale)
          },
          S: function (date) {
            return pad(date.getSeconds())
          },
          U: function (date) {
            return date.getTime() / 1e3
          },
          W: function (date, _, options) {
            return options.getWeek(date)
          },
          Y: function (date) {
            return date.getFullYear()
          },
          d: function (date) {
            return pad(date.getDate())
          },
          h: function (date) {
            return date.getHours() % 12 ? date.getHours() % 12 : 12
          },
          i: function (date) {
            return pad(date.getMinutes())
          },
          j: function (date) {
            return date.getDate()
          },
          l: function (date, locale) {
            return locale.weekdays.longhand[date.getDay()]
          },
          m: function (date) {
            return pad(date.getMonth() + 1)
          },
          n: function (date) {
            return date.getMonth() + 1
          },
          s: function (date) {
            return date.getSeconds()
          },
          u: function (date) {
            return date.getTime()
          },
          w: function (date) {
            return date.getDay()
          },
          y: function (date) {
            return String(date.getFullYear()).substring(2)
          }
        },
        createDateFormatter = function (_a) {
          var _b = _a.config,
            config = void 0 === _b ? defaults : _b,
            _c = _a.l10n,
            l10n = void 0 === _c ? english : _c;
          return function (dateObj, frmt, overrideLocale) {
            var locale = overrideLocale || l10n;
            return void 0 !== config.formatDate ? config.formatDate(dateObj, frmt, locale) : frmt.split("").map(function (c, i, arr) {
              return formats[c] && "\\" !== arr[i - 1] ? formats[c](dateObj, locale, config) : "\\" !== c ? c : ""
            }).join("")
          }
        },
        createDateParser = function (_a) {
          var _b = _a.config,
            config = void 0 === _b ? defaults : _b,
            _c = _a.l10n,
            l10n = void 0 === _c ? english : _c;
          return function (date, givenFormat, timeless, customLocale) {
            if (0 === date || date) {
              var parsedDate, locale = customLocale || l10n,
                date_orig = date;
              if (date instanceof Date) parsedDate = new Date(date.getTime());
              else if ("string" != typeof date && void 0 !== date.toFixed) parsedDate = new Date(date);
              else if ("string" == typeof date) {
                var format = givenFormat || (config || defaults).dateFormat,
                  datestr = String(date).trim();
                if ("today" === datestr) parsedDate = new Date, timeless = !0;
                else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) parsedDate = new Date(date);
                else if (config && config.parseDate) parsedDate = config.parseDate(date, format);
                else {
                  parsedDate = config && config.noCalendar ? new Date((new Date).setHours(0, 0, 0, 0)) : new Date((new Date).getFullYear(), 0, 1, 0, 0, 0, 0);
                  for (var matched = void 0, ops = [], i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                    var token_1 = format[i],
                      isBackSlash = "\\" === token_1,
                      escaped = "\\" === format[i - 1] || isBackSlash;
                    if (tokenRegex[token_1] && !escaped) {
                      regexStr += tokenRegex[token_1];
                      var match = new RegExp(regexStr).exec(date);
                      match && (matched = !0) && ops["Y" !== token_1 ? "push" : "unshift"]({
                        fn: revFormat[token_1],
                        val: match[++matchIndex]
                      })
                    } else isBackSlash || (regexStr += ".");
                    ops.forEach(function (_a) {
                      var fn = _a.fn,
                        val = _a.val;
                      return parsedDate = fn(parsedDate, val, locale) || parsedDate
                    })
                  }
                  parsedDate = matched ? parsedDate : void 0
                }
              }
              if (parsedDate instanceof Date && !isNaN(parsedDate.getTime())) return !0 === timeless && parsedDate.setHours(0, 0, 0, 0), parsedDate;
              config.errorHandler(new Error("Invalid date provided: " + date_orig))
            }
          }
        };

      function compareDates(date1, date2, timeless) {
        return void 0 === timeless && (timeless = !0), !1 !== timeless ? new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0) : date1.getTime() - date2.getTime()
      }
      var isBetween = function (ts, ts1, ts2) {
          return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2)
        },
        duration = {
          DAY: 864e5
        };
      "function" != typeof Object.assign && (Object.assign = function (target) {
        for (var args = [], _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
        if (!target) throw TypeError("Cannot convert undefined or null to object");
        for (var _loop_1 = function (source) {
            source && Object.keys(source).forEach(function (key) {
              return target[key] = source[key]
            })
          }, _a = 0, args_1 = args; _a < args_1.length; _a++) {
          _loop_1(args_1[_a])
        }
        return target
      });
      var DEBOUNCED_CHANGE_MS = 300;

      function FlatpickrInstance(element, instanceConfig) {
        var self = {
          config: __assign({}, flatpickr.defaultConfig),
          l10n: english
        };

        function bindToInstance(fn) {
          return fn.bind(self)
        }

        function setCalendarWidth() {
          var config = self.config;
          !1 === config.weekNumbers && 1 === config.showMonths || !0 !== config.noCalendar && window.requestAnimationFrame(function () {
            if (void 0 !== self.calendarContainer && (self.calendarContainer.style.visibility = "hidden", self.calendarContainer.style.display = "block"), void 0 !== self.daysContainer) {
              var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
              self.daysContainer.style.width = daysWidth + "px", self.calendarContainer.style.width = daysWidth + (void 0 !== self.weekWrapper ? self.weekWrapper.offsetWidth : 0) + "px", self.calendarContainer.style.removeProperty("visibility"), self.calendarContainer.style.removeProperty("display")
            }
          })
        }

        function updateTime(e) {
          0 === self.selectedDates.length && setDefaultTime(), void 0 !== e && "blur" !== e.type && function (e) {
            e.preventDefault();
            var isKeyDown = "keydown" === e.type,
              input = e.target;
            void 0 !== self.amPM && e.target === self.amPM && (self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])]);
            var min = parseFloat(input.getAttribute("min")),
              max = parseFloat(input.getAttribute("max")),
              step = parseFloat(input.getAttribute("step")),
              curValue = parseInt(input.value, 10),
              delta = e.delta || (isKeyDown ? 38 === e.which ? 1 : -1 : 0),
              newValue = curValue + step * delta;
            if (void 0 !== input.value && 2 === input.value.length) {
              var isHourElem = input === self.hourElement,
                isMinuteElem = input === self.minuteElement;
              newValue < min ? (newValue = max + newValue + int(!isHourElem) + (int(isHourElem) && int(!self.amPM)), isMinuteElem && incrementNumInput(void 0, -1, self.hourElement)) : max < newValue && (newValue = input === self.hourElement ? newValue - max - int(!self.amPM) : min, isMinuteElem && incrementNumInput(void 0, 1, self.hourElement)), self.amPM && isHourElem && (1 === step ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step) && (self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])]), input.value = pad(newValue)
            }
          }(e);
          var prevValue = self._input.value;
          setHoursFromInputs(), updateValue(), self._input.value !== prevValue && self._debouncedChange()
        }

        function setHoursFromInputs() {
          if (void 0 !== self.hourElement && void 0 !== self.minuteElement) {
            var hour, amPM, hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24,
              minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,
              seconds = void 0 !== self.secondElement ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;
            void 0 !== self.amPM && (hour = hours, amPM = self.amPM.textContent, hours = hour % 12 + 12 * int(amPM === self.l10n.amPM[1]));
            var limitMinHours = void 0 !== self.config.minTime || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && 0 === compareDates(self.latestSelectedDateObj, self.config.minDate, !0);
            if (void 0 !== self.config.maxTime || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && 0 === compareDates(self.latestSelectedDateObj, self.config.maxDate, !0)) {
              var maxTime = void 0 !== self.config.maxTime ? self.config.maxTime : self.config.maxDate;
              (hours = Math.min(hours, maxTime.getHours())) === maxTime.getHours() && (minutes = Math.min(minutes, maxTime.getMinutes())), minutes === maxTime.getMinutes() && (seconds = Math.min(seconds, maxTime.getSeconds()))
            }
            if (limitMinHours) {
              var minTime = void 0 !== self.config.minTime ? self.config.minTime : self.config.minDate;
              (hours = Math.max(hours, minTime.getHours())) === minTime.getHours() && (minutes = Math.max(minutes, minTime.getMinutes())), minutes === minTime.getMinutes() && (seconds = Math.max(seconds, minTime.getSeconds()))
            }
            setHours(hours, minutes, seconds)
          }
        }

        function setHoursFromDate(dateObj) {
          var date = dateObj || self.latestSelectedDateObj;
          date && setHours(date.getHours(), date.getMinutes(), date.getSeconds())
        }

        function setDefaultHours() {
          var hours = self.config.defaultHour,
            minutes = self.config.defaultMinute,
            seconds = self.config.defaultSeconds;
          if (void 0 !== self.config.minDate) {
            var min_hr = self.config.minDate.getHours(),
              min_minutes = self.config.minDate.getMinutes();
            (hours = Math.max(hours, min_hr)) === min_hr && (minutes = Math.max(min_minutes, minutes)), hours === min_hr && minutes === min_minutes && (seconds = self.config.minDate.getSeconds())
          }
          if (void 0 !== self.config.maxDate) {
            var max_hr = self.config.maxDate.getHours(),
              max_minutes = self.config.maxDate.getMinutes();
            (hours = Math.min(hours, max_hr)) === max_hr && (minutes = Math.min(max_minutes, minutes)), hours === max_hr && minutes === max_minutes && (seconds = self.config.maxDate.getSeconds())
          }
          setHours(hours, minutes, seconds)
        }

        function setHours(hours, minutes, seconds) {
          void 0 !== self.latestSelectedDateObj && self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0), self.hourElement && self.minuteElement && !self.isMobile && (self.hourElement.value = pad(self.config.time_24hr ? hours : (12 + hours) % 12 + 12 * int(hours % 12 == 0)), self.minuteElement.value = pad(minutes), void 0 !== self.amPM && (self.amPM.textContent = self.l10n.amPM[int(12 <= hours)]), void 0 !== self.secondElement && (self.secondElement.value = pad(seconds)))
        }

        function onYearInput(event) {
          var year = parseInt(event.target.value) + (event.delta || 0);
          (1 < year / 1e3 || "Enter" === event.key && !/[^\d]/.test(year.toString())) && changeYear(year)
        }

        function bind(element, event, handler, options) {
          return event instanceof Array ? event.forEach(function (ev) {
            return bind(element, ev, handler, options)
          }) : element instanceof Array ? element.forEach(function (el) {
            return bind(el, event, handler, options)
          }) : (element.addEventListener(event, handler, options), void self._handlers.push({
            element: element,
            event: event,
            handler: handler,
            options: options
          }))
        }

        function onClick(handler) {
          return function (evt) {
            1 === evt.which && handler(evt)
          }
        }

        function triggerChange() {
          triggerEvent("onChange")
        }

        function jumpToDate(jumpDate) {
          var jumpTo = void 0 !== jumpDate ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);
          try {
            void 0 !== jumpTo && (self.currentYear = jumpTo.getFullYear(), self.currentMonth = jumpTo.getMonth())
          } catch (e) {
            e.message = "Invalid date supplied: " + jumpTo, self.config.errorHandler(e)
          }
          self.redraw()
        }

        function timeIncrement(e) {
          ~e.target.className.indexOf("arrow") && incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1)
        }

        function incrementNumInput(e, delta, inputElem) {
          var target = e && e.target,
            input = inputElem || target && target.parentNode && target.parentNode.firstChild,
            event = createEvent("increment");
          event.delta = delta, input && input.dispatchEvent(event)
        }

        function createDay(className, date, dayNumber, i) {
          var dateIsEnabled = isEnabled(date, !0),
            dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
          return dayElement.dateObj = date, dayElement.$i = i, dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat)), -1 === className.indexOf("hidden") && 0 === compareDates(date, self.now) && ((self.todayDateElem = dayElement).classList.add("today"), dayElement.setAttribute("aria-current", "date")), dateIsEnabled ? (dayElement.tabIndex = -1, isDateSelected(date) && (dayElement.classList.add("selected"), self.selectedDateElem = dayElement, "range" === self.config.mode && (toggleClass(dayElement, "startRange", self.selectedDates[0] && 0 === compareDates(date, self.selectedDates[0], !0)), toggleClass(dayElement, "endRange", self.selectedDates[1] && 0 === compareDates(date, self.selectedDates[1], !0)), "nextMonthDay" === className && dayElement.classList.add("inRange")))) : dayElement.classList.add("disabled"), "range" === self.config.mode && function (date) {
            return !("range" !== self.config.mode || self.selectedDates.length < 2) && 0 <= compareDates(date, self.selectedDates[0]) && compareDates(date, self.selectedDates[1]) <= 0
          }(date) && !isDateSelected(date) && dayElement.classList.add("inRange"), self.weekNumbers && 1 === self.config.showMonths && "prevMonthDay" !== className && dayNumber % 7 == 1 && self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>"), triggerEvent("onDayCreate", dayElement), dayElement
        }

        function focusOnDayElem(targetNode) {
          targetNode.focus(), "range" === self.config.mode && onMouseOver(targetNode)
        }

        function getFirstAvailableDay(delta) {
          for (var startMonth = 0 < delta ? 0 : self.config.showMonths - 1, endMonth = 0 < delta ? self.config.showMonths : -1, m = startMonth; m != endMonth; m += delta)
            for (var month = self.daysContainer.children[m], startIndex = 0 < delta ? 0 : month.children.length - 1, endIndex = 0 < delta ? month.children.length : -1, i = startIndex; i != endIndex; i += delta) {
              var c = month.children[i];
              if (-1 === c.className.indexOf("hidden") && isEnabled(c.dateObj)) return c
            }
        }

        function focusOnDay(current, offset) {
          var dayFocused = isInView(document.activeElement || document.body),
            startElem = void 0 !== current ? current : dayFocused ? document.activeElement : void 0 !== self.selectedDateElem && isInView(self.selectedDateElem) ? self.selectedDateElem : void 0 !== self.todayDateElem && isInView(self.todayDateElem) ? self.todayDateElem : getFirstAvailableDay(0 < offset ? 1 : -1);
          return void 0 === startElem ? self._input.focus() : dayFocused ? void
          function (current, delta) {
            for (var givenMonth = -1 === current.className.indexOf("Month") ? current.dateObj.getMonth() : self.currentMonth, endMonth = 0 < delta ? self.config.showMonths : -1, loopDelta = 0 < delta ? 1 : -1, m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta)
              for (var month = self.daysContainer.children[m], startIndex = givenMonth - self.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0, numMonthDays = month.children.length, i = startIndex; 0 <= i && i < numMonthDays && i != (0 < delta ? numMonthDays : -1); i += loopDelta) {
                var c = month.children[i];
                if (-1 === c.className.indexOf("hidden") && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta)) return focusOnDayElem(c)
              }
            self.changeMonth(loopDelta), focusOnDay(getFirstAvailableDay(loopDelta), 0)
          }(startElem, offset): focusOnDayElem(startElem)
        }

        function buildMonthDays(year, month) {
          for (var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7, prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12), daysInMonth = self.utils.getDaysInMonth(month), days = window.document.createDocumentFragment(), isMultiMonth = 1 < self.config.showMonths, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay", dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
          for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
          for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (1 === self.config.showMonths || dayIndex % 7 != 0); dayNum++, dayIndex++) days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
          var dayContainer = createElement("div", "dayContainer");
          return dayContainer.appendChild(days), dayContainer
        }

        function buildDays() {
          if (void 0 !== self.daysContainer) {
            clearNode(self.daysContainer), self.weekNumbers && clearNode(self.weekNumbers);
            for (var frag = document.createDocumentFragment(), i = 0; i < self.config.showMonths; i++) {
              var d = new Date(self.currentYear, self.currentMonth, 1);
              d.setMonth(self.currentMonth + i), frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()))
            }
            self.daysContainer.appendChild(frag), self.days = self.daysContainer.firstChild, "range" === self.config.mode && 1 === self.selectedDates.length && onMouseOver()
          }
        }

        function buildMonth() {
          var container = createElement("div", "flatpickr-month"),
            monthNavFragment = window.document.createDocumentFragment(),
            monthElement = createElement("span", "cur-month"),
            yearInput = createNumberInput("cur-year", {
              tabindex: "-1"
            }),
            yearElement = yearInput.getElementsByTagName("input")[0];
          yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel), self.config.minDate && yearElement.setAttribute("min", self.config.minDate.getFullYear().toString()), self.config.maxDate && (yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString()), yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear());
          var currentMonth = createElement("div", "flatpickr-current-month");
          return currentMonth.appendChild(monthElement), currentMonth.appendChild(yearInput), monthNavFragment.appendChild(currentMonth), container.appendChild(monthNavFragment), {
            container: container,
            yearElement: yearElement,
            monthElement: monthElement
          }
        }

        function buildMonths() {
          clearNode(self.monthNav), self.monthNav.appendChild(self.prevMonthNav), self.config.showMonths && (self.yearElements = [], self.monthElements = []);
          for (var m = self.config.showMonths; m--;) {
            var month = buildMonth();
            self.yearElements.push(month.yearElement), self.monthElements.push(month.monthElement), self.monthNav.appendChild(month.container)
          }
          self.monthNav.appendChild(self.nextMonthNav)
        }

        function buildWeekdays() {
          self.weekdayContainer ? clearNode(self.weekdayContainer) : self.weekdayContainer = createElement("div", "flatpickr-weekdays");
          for (var i = self.config.showMonths; i--;) {
            var container = createElement("div", "flatpickr-weekdaycontainer");
            self.weekdayContainer.appendChild(container)
          }
          return updateWeekdays(), self.weekdayContainer
        }

        function updateWeekdays() {
          var firstDayOfWeek = self.l10n.firstDayOfWeek,
            weekdays = self.l10n.weekdays.shorthand.slice();
          0 < firstDayOfWeek && firstDayOfWeek < weekdays.length && (weekdays = weekdays.splice(firstDayOfWeek, weekdays.length).concat(weekdays.splice(0, firstDayOfWeek)));
          for (var i = self.config.showMonths; i--;) self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      "
        }

        function changeMonth(value, is_offset) {
          void 0 === is_offset && (is_offset = !0);
          var delta = is_offset ? value : value - self.currentMonth;
          delta < 0 && !0 === self._hidePrevMonthArrow || 0 < delta && !0 === self._hideNextMonthArrow || (self.currentMonth += delta, (self.currentMonth < 0 || 11 < self.currentMonth) && (self.currentYear += 11 < self.currentMonth ? 1 : -1, self.currentMonth = (self.currentMonth + 12) % 12, triggerEvent("onYearChange")), buildDays(), triggerEvent("onMonthChange"), updateNavigationCurrentMonth())
        }

        function isCalendarElem(elem) {
          return !(!self.config.appendTo || !self.config.appendTo.contains(elem)) || self.calendarContainer.contains(elem)
        }

        function documentClick(e) {
          if (self.isOpen && !self.config.inline) {
            var eventTarget_1 = "function" == typeof (event = e).composedPath ? event.composedPath()[0] : event.target,
              isCalendarElement = isCalendarElem(eventTarget_1),
              isInput = eventTarget_1 === self.input || eventTarget_1 === self.altInput || self.element.contains(eventTarget_1) || e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput)),
              lostFocus = "blur" === e.type ? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget) : !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget),
              isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
                return elem.contains(eventTarget_1)
              });
            lostFocus && isIgnored && (self.close(), "range" === self.config.mode && 1 === self.selectedDates.length && (self.clear(!1), self.redraw()))
          }
          var event
        }

        function changeYear(newYear) {
          if (!(!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear())) {
            var newYearNum = newYear,
              isNewYear = self.currentYear !== newYearNum;
            self.currentYear = newYearNum || self.currentYear, self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth) : self.config.minDate && self.currentYear === self.config.minDate.getFullYear() && (self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth)), isNewYear && (self.redraw(), triggerEvent("onYearChange"))
          }
        }

        function isEnabled(date, timeless) {
          void 0 === timeless && (timeless = !0);
          var dateToCheck = self.parseDate(date, void 0, timeless);
          if (self.config.minDate && dateToCheck && compareDates(dateToCheck, self.config.minDate, void 0 !== timeless ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && 0 < compareDates(dateToCheck, self.config.maxDate, void 0 !== timeless ? timeless : !self.maxDateHasTime)) return !1;
          if (0 === self.config.enable.length && 0 === self.config.disable.length) return !0;
          if (void 0 === dateToCheck) return !1;
          for (var bool = 0 < self.config.enable.length, array = bool ? self.config.enable : self.config.disable, i = 0, d = void 0; i < array.length; i++) {
            if ("function" == typeof (d = array[i]) && d(dateToCheck)) return bool;
            if (d instanceof Date && void 0 !== dateToCheck && d.getTime() === dateToCheck.getTime()) return bool;
            if ("string" == typeof d && void 0 !== dateToCheck) {
              var parsed = self.parseDate(d, void 0, !0);
              return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool
            }
            if ("object" == typeof d && void 0 !== dateToCheck && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime()) return bool
          }
          return !bool
        }

        function isInView(elem) {
          return void 0 !== self.daysContainer && (-1 === elem.className.indexOf("hidden") && self.daysContainer.contains(elem))
        }

        function onKeyDown(e) {
          var isInput = e.target === self._input,
            allowInput = self.config.allowInput,
            allowKeydown = self.isOpen && (!allowInput || !isInput),
            allowInlineKeydown = self.config.inline && isInput && !allowInput;
          if (13 === e.keyCode && isInput) {
            if (allowInput) return self.setDate(self._input.value, !0, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat), e.target.blur();
            self.open()
          } else if (isCalendarElem(e.target) || allowKeydown || allowInlineKeydown) {
            var isTimeObj = !!self.timeContainer && self.timeContainer.contains(e.target);
            switch (e.keyCode) {
              case 13:
                isTimeObj ? (updateTime(), focusAndClose()) : selectDate(e);
                break;
              case 27:
                e.preventDefault(), focusAndClose();
                break;
              case 8:
              case 46:
                isInput && !self.config.allowInput && (e.preventDefault(), self.clear());
                break;
              case 37:
              case 39:
                if (isTimeObj) self.hourElement && self.hourElement.focus();
                else if (e.preventDefault(), void 0 !== self.daysContainer && (!1 === allowInput || document.activeElement && isInView(document.activeElement))) {
                  var delta_1 = 39 === e.keyCode ? 1 : -1;
                  e.ctrlKey ? (e.stopPropagation(), changeMonth(delta_1), focusOnDay(getFirstAvailableDay(1), 0)) : focusOnDay(void 0, delta_1)
                }
                break;
              case 38:
              case 40:
                e.preventDefault();
                var delta = 40 === e.keyCode ? 1 : -1;
                self.daysContainer && void 0 !== e.target.$i || e.target === self.input ? e.ctrlKey ? (e.stopPropagation(), changeYear(self.currentYear - delta), focusOnDay(getFirstAvailableDay(1), 0)) : isTimeObj || focusOnDay(void 0, 7 * delta) : self.config.enableTime && (!isTimeObj && self.hourElement && self.hourElement.focus(), updateTime(e), self._debouncedChange());
                break;
              case 9:
                if (isTimeObj) {
                  var elems = [self.hourElement, self.minuteElement, self.secondElement, self.amPM].filter(function (x) {
                      return x
                    }),
                    i = elems.indexOf(e.target);
                  if (-1 !== i) {
                    var target = elems[i + (e.shiftKey ? -1 : 1)];
                    void 0 !== target ? (e.preventDefault(), target.focus()) : e.shiftKey && (e.preventDefault(), self._input.focus())
                  }
                }
            }
          }
          if (void 0 !== self.amPM && e.target === self.amPM) switch (e.key) {
            case self.l10n.amPM[0].charAt(0):
            case self.l10n.amPM[0].charAt(0).toLowerCase():
              self.amPM.textContent = self.l10n.amPM[0], setHoursFromInputs(), updateValue();
              break;
            case self.l10n.amPM[1].charAt(0):
            case self.l10n.amPM[1].charAt(0).toLowerCase():
              self.amPM.textContent = self.l10n.amPM[1], setHoursFromInputs(), updateValue()
          }
          triggerEvent("onKeyDown", e)
        }

        function onMouseOver(elem) {
          if (1 === self.selectedDates.length && (!elem || elem.classList.contains("flatpickr-day") && !elem.classList.contains("disabled"))) {
            for (var hoverDate = elem ? elem.dateObj.getTime() : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], void 0, !0).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime()), lastDate = self.daysContainer.lastChild.lastChild.dateObj.getTime(), containsDisabled = !1, minRange = 0, maxRange = 0, t = rangeStartDate; t < lastDate; t += duration.DAY) isEnabled(new Date(t), !0) || (containsDisabled = containsDisabled || rangeStartDate < t && t < rangeEndDate, t < initialDate && (!minRange || minRange < t) ? minRange = t : initialDate < t && (!maxRange || t < maxRange) && (maxRange = t));
            for (var m = 0; m < self.config.showMonths; m++)
              for (var month = self.daysContainer.children[m], prevMonth = self.daysContainer.children[m - 1], _loop_1 = function (i, l) {
                  var dayElem = month.children[i],
                    timestamp = dayElem.dateObj.getTime(),
                    outOfRange = 0 < minRange && timestamp < minRange || 0 < maxRange && maxRange < timestamp;
                  return outOfRange ? (dayElem.classList.add("notAllowed"), ["inRange", "startRange", "endRange"].forEach(function (c) {
                    dayElem.classList.remove(c)
                  }), "continue") : containsDisabled && !outOfRange ? "continue" : (["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
                    dayElem.classList.remove(c)
                  }), void(void 0 !== elem && (elem.classList.add(hoverDate < self.selectedDates[0].getTime() ? "startRange" : "endRange"), !month.contains(elem) && 0 < m && prevMonth && prevMonth.lastChild.dateObj.getTime() >= timestamp || (initialDate < hoverDate && timestamp === initialDate ? dayElem.classList.add("startRange") : hoverDate < initialDate && timestamp === initialDate && dayElem.classList.add("endRange"), minRange <= timestamp && (0 === maxRange || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate) && dayElem.classList.add("inRange")))))
                }, i = 0, l = month.children.length; i < l; i++) _loop_1(i)
          }
        }

        function onResize() {
          !self.isOpen || self.config.static || self.config.inline || positionCalendar()
        }

        function setDefaultTime() {
          self.setDate(void 0 !== self.config.minDate ? new Date(self.config.minDate.getTime()) : new Date, !1), setDefaultHours(), updateValue()
        }

        function minMaxDateSetter(type) {
          return function (date) {
            var dateObj = self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat),
              inverseDateObj = self.config["_" + ("min" === type ? "max" : "min") + "Date"];
            void 0 !== dateObj && (self["min" === type ? "minDateHasTime" : "maxDateHasTime"] = 0 < dateObj.getHours() || 0 < dateObj.getMinutes() || 0 < dateObj.getSeconds()), self.selectedDates && (self.selectedDates = self.selectedDates.filter(function (d) {
              return isEnabled(d)
            }), self.selectedDates.length || "min" !== type || setHoursFromDate(dateObj), updateValue()), self.daysContainer && (redraw(), void 0 !== dateObj ? self.currentYearElement[type] = dateObj.getFullYear().toString() : self.currentYearElement.removeAttribute(type), self.currentYearElement.disabled = !!inverseDateObj && void 0 !== dateObj && inverseDateObj.getFullYear() === dateObj.getFullYear())
          }
        }

        function setupLocale() {
          "object" != typeof self.config.locale && void 0 === flatpickr.l10ns[self.config.locale] && self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale)), self.l10n = __assign({}, flatpickr.l10ns.default, "object" == typeof self.config.locale ? self.config.locale : "default" !== self.config.locale ? flatpickr.l10ns[self.config.locale] : void 0), tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")", self.formatDate = createDateFormatter(self), self.parseDate = createDateParser({
            config: self.config,
            l10n: self.l10n
          })
        }

        function positionCalendar(customPositionElement) {
          if (void 0 !== self.calendarContainer) {
            triggerEvent("onPreCalendarPosition");
            var positionElement = customPositionElement || self._positionElement,
              calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, function (acc, child) {
                return acc + child.offsetHeight
              }, 0),
              calendarWidth = self.calendarContainer.offsetWidth,
              configPos = self.config.position.split(" "),
              configPosVertical = configPos[0],
              configPosHorizontal = 1 < configPos.length ? configPos[1] : null,
              inputBounds = positionElement.getBoundingClientRect(),
              distanceFromBottom = window.innerHeight - inputBounds.bottom,
              showOnTop = "above" === configPosVertical || "below" !== configPosVertical && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight,
              top = window.pageYOffset + inputBounds.top + (showOnTop ? -calendarHeight - 2 : positionElement.offsetHeight + 2);
            if (toggleClass(self.calendarContainer, "arrowTop", !showOnTop), toggleClass(self.calendarContainer, "arrowBottom", showOnTop), !self.config.inline) {
              var left = window.pageXOffset + inputBounds.left - (null != configPosHorizontal && "center" === configPosHorizontal ? (calendarWidth - inputBounds.width) / 2 : 0),
                right = window.document.body.offsetWidth - inputBounds.right,
                rightMost = left + calendarWidth > window.document.body.offsetWidth,
                centerMost = right + calendarWidth > window.document.body.offsetWidth;
              if (toggleClass(self.calendarContainer, "rightMost", rightMost), !self.config.static)
                if (self.calendarContainer.style.top = top + "px", rightMost)
                  if (centerMost) {
                    var doc = document.styleSheets[0];
                    if (void 0 === doc) return;
                    var bodyWidth = window.document.body.offsetWidth,
                      centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2),
                      centerIndex = doc.cssRules.length,
                      centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
                    toggleClass(self.calendarContainer, "rightMost", !1), toggleClass(self.calendarContainer, "centerMost", !0), doc.insertRule(".flatpickr-calendar.centerMost:before,.flatpickr-calendar.centerMost:after" + centerStyle, centerIndex), self.calendarContainer.style.left = centerLeft + "px", self.calendarContainer.style.right = "auto"
                  } else self.calendarContainer.style.left = "auto", self.calendarContainer.style.right = right + "px";
              else self.calendarContainer.style.left = left + "px", self.calendarContainer.style.right = "auto"
            }
          }
        }

        function redraw() {
          self.config.noCalendar || self.isMobile || (updateNavigationCurrentMonth(), buildDays())
        }

        function focusAndClose() {
          self._input.focus(), -1 !== window.navigator.userAgent.indexOf("MSIE") || void 0 !== navigator.msMaxTouchPoints ? setTimeout(self.close, 0) : self.close()
        }

        function selectDate(e) {
          e.preventDefault(), e.stopPropagation();
          var t = function findParent(node, condition) {
            return condition(node) ? node : node.parentNode ? findParent(node.parentNode, condition) : void 0
          }(e.target, function (day) {
            return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("disabled") && !day.classList.contains("notAllowed")
          });
          if (void 0 !== t) {
            var target = t,
              selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime()),
              shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && "range" !== self.config.mode;
            if (self.selectedDateElem = target, "single" === self.config.mode) self.selectedDates = [selectedDate];
            else if ("multiple" === self.config.mode) {
              var selectedIndex = isDateSelected(selectedDate);
              selectedIndex ? self.selectedDates.splice(parseInt(selectedIndex), 1) : self.selectedDates.push(selectedDate)
            } else "range" === self.config.mode && (2 === self.selectedDates.length && self.clear(!1, !1), self.latestSelectedDateObj = selectedDate, self.selectedDates.push(selectedDate), 0 !== compareDates(selectedDate, self.selectedDates[0], !0) && self.selectedDates.sort(function (a, b) {
              return a.getTime() - b.getTime()
            }));
            if (setHoursFromInputs(), shouldChangeMonth) {
              var isNewYear = self.currentYear !== selectedDate.getFullYear();
              self.currentYear = selectedDate.getFullYear(), self.currentMonth = selectedDate.getMonth(), isNewYear && triggerEvent("onYearChange"), triggerEvent("onMonthChange")
            }
            if (updateNavigationCurrentMonth(), buildDays(), updateValue(), self.config.enableTime && setTimeout(function () {
                return self.showTimeInput = !0
              }, 50), shouldChangeMonth || "range" === self.config.mode || 1 !== self.config.showMonths ? void 0 !== self.selectedDateElem && void 0 === self.hourElement && self.selectedDateElem && self.selectedDateElem.focus() : focusOnDayElem(target), void 0 !== self.hourElement && void 0 !== self.hourElement && self.hourElement.focus(), self.config.closeOnSelect) {
              var single = "single" === self.config.mode && !self.config.enableTime,
                range = "range" === self.config.mode && 2 === self.selectedDates.length && !self.config.enableTime;
              (single || range) && focusAndClose()
            }
            triggerChange()
          }
        }
        self.parseDate = createDateParser({
          config: self.config,
          l10n: self.l10n
        }), self._handlers = [], self._bind = bind, self._setHoursFromDate = setHoursFromDate, self._positionCalendar = positionCalendar, self.changeMonth = changeMonth, self.changeYear = changeYear, self.clear = function (triggerChangeEvent, toInitial) {
          void 0 === triggerChangeEvent && (triggerChangeEvent = !0);
          void 0 === toInitial && (toInitial = !0);
          self.input.value = "", void 0 !== self.altInput && (self.altInput.value = "");
          void 0 !== self.mobileInput && (self.mobileInput.value = "");
          self.selectedDates = [], !(self.latestSelectedDateObj = void 0) === toInitial && (self.currentYear = self._initialDate.getFullYear(), self.currentMonth = self._initialDate.getMonth());
          !(self.showTimeInput = !1) === self.config.enableTime && setDefaultHours();
          self.redraw(), triggerChangeEvent && triggerEvent("onChange")
        }, self.close = function () {
          self.isOpen = !1, self.isMobile || (void 0 !== self.calendarContainer && self.calendarContainer.classList.remove("open"), void 0 !== self._input && self._input.classList.remove("active"));
          triggerEvent("onClose")
        }, self._createElement = createElement, self.destroy = function () {
          void 0 !== self.config && triggerEvent("onDestroy");
          for (var i = self._handlers.length; i--;) {
            var h = self._handlers[i];
            h.element.removeEventListener(h.event, h.handler, h.options)
          }
          if (self._handlers = [], self.mobileInput) self.mobileInput.parentNode && self.mobileInput.parentNode.removeChild(self.mobileInput), self.mobileInput = void 0;
          else if (self.calendarContainer && self.calendarContainer.parentNode)
            if (self.config.static && self.calendarContainer.parentNode) {
              var wrapper = self.calendarContainer.parentNode;
              if (wrapper.lastChild && wrapper.removeChild(wrapper.lastChild), wrapper.parentNode) {
                for (; wrapper.firstChild;) wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                wrapper.parentNode.removeChild(wrapper)
              }
            } else self.calendarContainer.parentNode.removeChild(self.calendarContainer);
          self.altInput && (self.input.type = "text", self.altInput.parentNode && self.altInput.parentNode.removeChild(self.altInput), delete self.altInput);
          self.input && (self.input.type = self.input._type, self.input.classList.remove("flatpickr-input"), self.input.removeAttribute("readonly"), self.input.value = "");
          ["_showTimeInput", "latestSelectedDateObj", "_hideNextMonthArrow", "_hidePrevMonthArrow", "__hideNextMonthArrow", "__hidePrevMonthArrow", "isMobile", "isOpen", "selectedDateElem", "minDateHasTime", "maxDateHasTime", "days", "daysContainer", "_input", "_positionElement", "innerContainer", "rContainer", "monthNav", "todayDateElem", "calendarContainer", "weekdayContainer", "prevMonthNav", "nextMonthNav", "currentMonthElement", "currentYearElement", "navigationCurrentMonth", "selectedDateElem", "config"].forEach(function (k) {
            try {
              delete self[k]
            } catch (_) {}
          })
        }, self.isEnabled = isEnabled, self.jumpToDate = jumpToDate, self.open = function (e, positionElement) {
          void 0 === positionElement && (positionElement = self._positionElement);
          if (!0 === self.isMobile) return e && (e.preventDefault(), e.target && e.target.blur()), void 0 !== self.mobileInput && (self.mobileInput.focus(), self.mobileInput.click()), void triggerEvent("onOpen");
          if (self._input.disabled || self.config.inline) return;
          var wasOpen = self.isOpen;
          self.isOpen = !0, wasOpen || (self.calendarContainer.classList.add("open"), self._input.classList.add("active"), triggerEvent("onOpen"), positionCalendar(positionElement));
          !0 === self.config.enableTime && !0 === self.config.noCalendar && (0 === self.selectedDates.length && setDefaultTime(), !1 !== self.config.allowInput || void 0 !== e && self.timeContainer.contains(e.relatedTarget) || setTimeout(function () {
            return self.hourElement.select()
          }, 50))
        }, self.redraw = redraw, self.set = function (option, value) {
          null !== option && "object" == typeof option ? Object.assign(self.config, option) : (self.config[option] = value, void 0 !== CALLBACKS[option] ? CALLBACKS[option].forEach(function (x) {
            return x()
          }) : -1 < HOOKS.indexOf(option) && (self.config[option] = arrayify(value)));
          self.redraw(), updateValue(!1)
        }, self.setDate = function (date, triggerChange, format) {
          void 0 === triggerChange && (triggerChange = !1);
          void 0 === format && (format = self.config.dateFormat);
          if (0 !== date && !date || date instanceof Array && 0 === date.length) return self.clear(triggerChange);
          setSelectedDate(date, format), self.showTimeInput = 0 < self.selectedDates.length, self.latestSelectedDateObj = self.selectedDates[0], self.redraw(), jumpToDate(), setHoursFromDate(), updateValue(triggerChange), triggerChange && triggerEvent("onChange")
        }, self.toggle = function (e) {
          if (!0 === self.isOpen) return self.close();
          self.open(e)
        };
        var CALLBACKS = {
          locale: [setupLocale, updateWeekdays],
          showMonths: [buildMonths, setCalendarWidth, buildWeekdays]
        };

        function setSelectedDate(inputDate, format) {
          var dates = [];
          if (inputDate instanceof Array) dates = inputDate.map(function (d) {
            return self.parseDate(d, format)
          });
          else if (inputDate instanceof Date || "number" == typeof inputDate) dates = [self.parseDate(inputDate, format)];
          else if ("string" == typeof inputDate) switch (self.config.mode) {
            case "single":
            case "time":
              dates = [self.parseDate(inputDate, format)];
              break;
            case "multiple":
              dates = inputDate.split(self.config.conjunction).map(function (date) {
                return self.parseDate(date, format)
              });
              break;
            case "range":
              dates = inputDate.split(self.l10n.rangeSeparator).map(function (date) {
                return self.parseDate(date, format)
              })
          } else self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
          self.selectedDates = dates.filter(function (d) {
            return d instanceof Date && isEnabled(d, !1)
          }), "range" === self.config.mode && self.selectedDates.sort(function (a, b) {
            return a.getTime() - b.getTime()
          })
        }

        function parseDateRules(arr) {
          return arr.slice().map(function (rule) {
            return "string" == typeof rule || "number" == typeof rule || rule instanceof Date ? self.parseDate(rule, void 0, !0) : rule && "object" == typeof rule && rule.from && rule.to ? {
              from: self.parseDate(rule.from, void 0),
              to: self.parseDate(rule.to, void 0)
            } : rule
          }).filter(function (x) {
            return x
          })
        }

        function triggerEvent(event, data) {
          if (void 0 !== self.config) {
            var hooks = self.config[event];
            if (void 0 !== hooks && 0 < hooks.length)
              for (var i = 0; hooks[i] && i < hooks.length; i++) hooks[i](self.selectedDates, self.input.value, self, data);
            "onChange" === event && (self.input.dispatchEvent(createEvent("change")), self.input.dispatchEvent(createEvent("input")))
          }
        }

        function createEvent(name) {
          var e = document.createEvent("Event");
          return e.initEvent(name, !0, !0), e
        }

        function isDateSelected(date) {
          for (var i = 0; i < self.selectedDates.length; i++)
            if (0 === compareDates(self.selectedDates[i], date)) return "" + i;
          return !1
        }

        function updateNavigationCurrentMonth() {
          self.config.noCalendar || self.isMobile || !self.monthNav || (self.yearElements.forEach(function (yearElement, i) {
            var d = new Date(self.currentYear, self.currentMonth, 1);
            d.setMonth(self.currentMonth + i), self.monthElements[i].textContent = monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ", yearElement.value = d.getFullYear().toString()
          }), self._hidePrevMonthArrow = void 0 !== self.config.minDate && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear()), self._hideNextMonthArrow = void 0 !== self.config.maxDate && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear()))
        }

        function getDateStr(format) {
          return self.selectedDates.map(function (dObj) {
            return self.formatDate(dObj, format)
          }).filter(function (d, i, arr) {
            return "range" !== self.config.mode || self.config.enableTime || arr.indexOf(d) === i
          }).join("range" !== self.config.mode ? self.config.conjunction : self.l10n.rangeSeparator)
        }

        function updateValue(triggerChange) {
          if (void 0 === triggerChange && (triggerChange = !0), 0 === self.selectedDates.length) return self.clear(triggerChange);
          void 0 !== self.mobileInput && self.mobileFormatStr && (self.mobileInput.value = void 0 !== self.latestSelectedDateObj ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : ""), self.input.value = getDateStr(self.config.dateFormat), void 0 !== self.altInput && (self.altInput.value = getDateStr(self.config.altFormat)), !1 !== triggerChange && triggerEvent("onValueUpdate")
        }

        function onMonthNavClick(e) {
          e.preventDefault();
          var isPrevMonth = self.prevMonthNav.contains(e.target),
            isNextMonth = self.nextMonthNav.contains(e.target);
          isPrevMonth || isNextMonth ? changeMonth(isPrevMonth ? -1 : 1) : 0 <= self.yearElements.indexOf(e.target) ? e.target.select() : e.target.classList.contains("arrowUp") ? self.changeYear(self.currentYear + 1) : e.target.classList.contains("arrowDown") && self.changeYear(self.currentYear - 1)
        }
        return function () {
          self.element = self.input = element, self.isOpen = !1,
            function () {
              var boolOpts = ["wrap", "weekNumbers", "allowInput", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile"],
                userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {}))),
                formats = {};
              self.config.parseDate = userConfig.parseDate, self.config.formatDate = userConfig.formatDate, Object.defineProperty(self.config, "enable", {
                get: function () {
                  return self.config._enable
                },
                set: function (dates) {
                  self.config._enable = parseDateRules(dates)
                }
              }), Object.defineProperty(self.config, "disable", {
                get: function () {
                  return self.config._disable
                },
                set: function (dates) {
                  self.config._disable = parseDateRules(dates)
                }
              });
              var timeMode = "time" === userConfig.mode;
              userConfig.dateFormat || !userConfig.enableTime && !timeMode || (formats.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : flatpickr.defaultConfig.dateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "")), userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat && (formats.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : flatpickr.defaultConfig.altFormat + " h:i" + (userConfig.enableSeconds ? ":S" : "") + " K"), Object.defineProperty(self.config, "minDate", {
                get: function () {
                  return self.config._minDate
                },
                set: minMaxDateSetter("min")
              }), Object.defineProperty(self.config, "maxDate", {
                get: function () {
                  return self.config._maxDate
                },
                set: minMaxDateSetter("max")
              });
              var minMaxTimeSetter = function (type) {
                return function (val) {
                  self.config["min" === type ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i")
                }
              };
              Object.defineProperty(self.config, "minTime", {
                get: function () {
                  return self.config._minTime
                },
                set: minMaxTimeSetter("min")
              }), Object.defineProperty(self.config, "maxTime", {
                get: function () {
                  return self.config._maxTime
                },
                set: minMaxTimeSetter("max")
              }), "time" === userConfig.mode && (self.config.noCalendar = !0, self.config.enableTime = !0), Object.assign(self.config, formats, userConfig);
              for (var i = 0; i < boolOpts.length; i++) self.config[boolOpts[i]] = !0 === self.config[boolOpts[i]] || "true" === self.config[boolOpts[i]];
              HOOKS.filter(function (hook) {
                return void 0 !== self.config[hook]
              }).forEach(function (hook) {
                self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance)
              }), self.isMobile = !self.config.disableMobile && !self.config.inline && "single" === self.config.mode && !self.config.disable.length && !self.config.enable.length && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
              for (var i = 0; i < self.config.plugins.length; i++) {
                var pluginConf = self.config.plugins[i](self) || {};
                for (var key in pluginConf) - 1 < HOOKS.indexOf(key) ? self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]) : void 0 === userConfig[key] && (self.config[key] = pluginConf[key])
              }
              triggerEvent("onParseConfig")
            }(), setupLocale(),
            function () {
              if (self.input = self.config.wrap ? element.querySelector("[data-input]") : element, !self.input) return self.config.errorHandler(new Error("Invalid input element specified"));
              self.input._type = self.input.type, self.input.type = "text", self.input.classList.add("flatpickr-input"), self._input = self.input, self.config.altInput && (self.altInput = createElement(self.input.nodeName, self.input.className + " " + self.config.altInputClass), self._input = self.altInput, self.altInput.placeholder = self.input.placeholder, self.altInput.disabled = self.input.disabled, self.altInput.required = self.input.required, self.altInput.tabIndex = self.input.tabIndex, self.altInput.type = "text", self.input.setAttribute("type", "hidden"), !self.config.static && self.input.parentNode && self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling)), self.config.allowInput || self._input.setAttribute("readonly", "readonly"), self._positionElement = self.config.positionElement || self._input
            }(),
            function () {
              self.selectedDates = [], self.now = self.parseDate(self.config.now) || new Date;
              var preloadedDate = self.config.defaultDate || ("INPUT" !== self.input.nodeName && "TEXTAREA" !== self.input.nodeName || !self.input.placeholder || self.input.value !== self.input.placeholder ? self.input.value : null);
              preloadedDate && setSelectedDate(preloadedDate, self.config.dateFormat), self._initialDate = 0 < self.selectedDates.length ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now, self.currentYear = self._initialDate.getFullYear(), self.currentMonth = self._initialDate.getMonth(), 0 < self.selectedDates.length && (self.latestSelectedDateObj = self.selectedDates[0]), void 0 !== self.config.minTime && (self.config.minTime = self.parseDate(self.config.minTime, "H:i")), void 0 !== self.config.maxTime && (self.config.maxTime = self.parseDate(self.config.maxTime, "H:i")), self.minDateHasTime = !!self.config.minDate && (0 < self.config.minDate.getHours() || 0 < self.config.minDate.getMinutes() || 0 < self.config.minDate.getSeconds()), self.maxDateHasTime = !!self.config.maxDate && (0 < self.config.maxDate.getHours() || 0 < self.config.maxDate.getMinutes() || 0 < self.config.maxDate.getSeconds()), Object.defineProperty(self, "showTimeInput", {
                get: function () {
                  return self._showTimeInput
                },
                set: function (bool) {
                  self._showTimeInput = bool, self.calendarContainer && toggleClass(self.calendarContainer, "showTimeInput", bool), self.isOpen && positionCalendar()
                }
              })
            }(), self.utils = {
              getDaysInMonth: function (month, yr) {
                return void 0 === month && (month = self.currentMonth), void 0 === yr && (yr = self.currentYear), 1 === month && (yr % 4 == 0 && yr % 100 != 0 || yr % 400 == 0) ? 29 : self.l10n.daysInMonth[month]
              }
            }, self.isMobile || function () {
              var fragment = window.document.createDocumentFragment();
              if (self.calendarContainer = createElement("div", "flatpickr-calendar"), self.calendarContainer.tabIndex = -1, !self.config.noCalendar) {
                if (fragment.appendChild((self.monthNav = createElement("div", "flatpickr-months"), self.yearElements = [], self.monthElements = [], self.prevMonthNav = createElement("span", "flatpickr-prev-month"), self.prevMonthNav.innerHTML = self.config.prevArrow, self.nextMonthNav = createElement("span", "flatpickr-next-month"), self.nextMonthNav.innerHTML = self.config.nextArrow, buildMonths(), Object.defineProperty(self, "_hidePrevMonthArrow", {
                    get: function () {
                      return self.__hidePrevMonthArrow
                    },
                    set: function (bool) {
                      self.__hidePrevMonthArrow !== bool && (toggleClass(self.prevMonthNav, "disabled", bool), self.__hidePrevMonthArrow = bool)
                    }
                  }), Object.defineProperty(self, "_hideNextMonthArrow", {
                    get: function () {
                      return self.__hideNextMonthArrow
                    },
                    set: function (bool) {
                      self.__hideNextMonthArrow !== bool && (toggleClass(self.nextMonthNav, "disabled", bool), self.__hideNextMonthArrow = bool)
                    }
                  }), self.currentYearElement = self.yearElements[0], updateNavigationCurrentMonth(), self.monthNav)), self.innerContainer = createElement("div", "flatpickr-innerContainer"), self.config.weekNumbers) {
                  var _a = function () {
                      self.calendarContainer.classList.add("hasWeeks");
                      var weekWrapper = createElement("div", "flatpickr-weekwrapper");
                      weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
                      var weekNumbers = createElement("div", "flatpickr-weeks");
                      return weekWrapper.appendChild(weekNumbers), {
                        weekWrapper: weekWrapper,
                        weekNumbers: weekNumbers
                      }
                    }(),
                    weekWrapper = _a.weekWrapper,
                    weekNumbers = _a.weekNumbers;
                  self.innerContainer.appendChild(weekWrapper), self.weekNumbers = weekNumbers, self.weekWrapper = weekWrapper
                }
                self.rContainer = createElement("div", "flatpickr-rContainer"), self.rContainer.appendChild(buildWeekdays()), self.daysContainer || (self.daysContainer = createElement("div", "flatpickr-days"), self.daysContainer.tabIndex = -1), buildDays(), self.rContainer.appendChild(self.daysContainer), self.innerContainer.appendChild(self.rContainer), fragment.appendChild(self.innerContainer)
              }
              self.config.enableTime && fragment.appendChild(function () {
                self.calendarContainer.classList.add("hasTime"), self.config.noCalendar && self.calendarContainer.classList.add("noCalendar"), self.timeContainer = createElement("div", "flatpickr-time"), self.timeContainer.tabIndex = -1;
                var separator = createElement("span", "flatpickr-time-separator", ":"),
                  hourInput = createNumberInput("flatpickr-hour");
                self.hourElement = hourInput.getElementsByTagName("input")[0];
                var minuteInput = createNumberInput("flatpickr-minute");
                if (self.minuteElement = minuteInput.getElementsByTagName("input")[0], self.hourElement.tabIndex = self.minuteElement.tabIndex = -1, self.hourElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? self.config.defaultHour : function (hour) {
                    switch (hour % 24) {
                      case 0:
                      case 12:
                        return 12;
                      default:
                        return hour % 12
                    }
                  }(self.config.defaultHour)), self.minuteElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : self.config.defaultMinute), self.hourElement.setAttribute("step", self.config.hourIncrement.toString()), self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString()), self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1"), self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12"), self.minuteElement.setAttribute("min", "0"), self.minuteElement.setAttribute("max", "59"), self.timeContainer.appendChild(hourInput), self.timeContainer.appendChild(separator), self.timeContainer.appendChild(minuteInput), self.config.time_24hr && self.timeContainer.classList.add("time24hr"), self.config.enableSeconds) {
                  self.timeContainer.classList.add("hasSeconds");
                  var secondInput = createNumberInput("flatpickr-second");
                  self.secondElement = secondInput.getElementsByTagName("input")[0], self.secondElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : self.config.defaultSeconds), self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step")), self.secondElement.setAttribute("min", "0"), self.secondElement.setAttribute("max", "59"), self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":")), self.timeContainer.appendChild(secondInput)
                }
                return self.config.time_24hr || (self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int(11 < (self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour))]), self.amPM.title = self.l10n.toggleTitle, self.amPM.tabIndex = -1, self.timeContainer.appendChild(self.amPM)), self.timeContainer
              }()), toggleClass(self.calendarContainer, "rangeMode", "range" === self.config.mode), toggleClass(self.calendarContainer, "animate", !0 === self.config.animate), toggleClass(self.calendarContainer, "multiMonth", 1 < self.config.showMonths), self.calendarContainer.appendChild(fragment);
              var customAppend = void 0 !== self.config.appendTo && void 0 !== self.config.appendTo.nodeType;
              if ((self.config.inline || self.config.static) && (self.calendarContainer.classList.add(self.config.inline ? "inline" : "static"), self.config.inline && (!customAppend && self.element.parentNode ? self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling) : void 0 !== self.config.appendTo && self.config.appendTo.appendChild(self.calendarContainer)), self.config.static)) {
                var wrapper = createElement("div", "flatpickr-wrapper");
                self.element.parentNode && self.element.parentNode.insertBefore(wrapper, self.element), wrapper.appendChild(self.element), self.altInput && wrapper.appendChild(self.altInput), wrapper.appendChild(self.calendarContainer)
              }
              self.config.static || self.config.inline || (void 0 !== self.config.appendTo ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer)
            }(),
            function () {
              if (self.config.wrap && ["open", "close", "toggle", "clear"].forEach(function (evt) {
                  Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
                    return bind(el, "click", self[evt])
                  })
                }), self.isMobile) return function () {
                var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";
                self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile"), self.mobileInput.step = self.input.getAttribute("step") || "any", self.mobileInput.tabIndex = 1, self.mobileInput.type = inputType, self.mobileInput.disabled = self.input.disabled, self.mobileInput.required = self.input.required, self.mobileInput.placeholder = self.input.placeholder, self.mobileFormatStr = "datetime-local" === inputType ? "Y-m-d\\TH:i:S" : "date" === inputType ? "Y-m-d" : "H:i:S", 0 < self.selectedDates.length && (self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr)), self.config.minDate && (self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d")), self.config.maxDate && (self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d")), self.input.type = "hidden", void 0 !== self.altInput && (self.altInput.type = "hidden");
                try {
                  self.input.parentNode && self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling)
                } catch (_a) {}
                bind(self.mobileInput, "change", function (e) {
                  self.setDate(e.target.value, !1, self.mobileFormatStr), triggerEvent("onChange"), triggerEvent("onClose")
                })
              }();
              var debouncedResize = debounce(onResize, 50);
              self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS), self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent) && bind(self.daysContainer, "mouseover", function (e) {
                "range" === self.config.mode && onMouseOver(e.target)
              }), bind(window.document.body, "keydown", onKeyDown), self.config.static || bind(self._input, "keydown", onKeyDown), self.config.inline || self.config.static || bind(window, "resize", debouncedResize), void 0 !== window.ontouchstart ? bind(window.document, "click", documentClick) : bind(window.document, "mousedown", onClick(documentClick)), bind(window.document, "focus", documentClick, {
                capture: !0
              }), !0 === self.config.clickOpens && (bind(self._input, "focus", self.open), bind(self._input, "mousedown", onClick(self.open))), void 0 !== self.daysContainer && (bind(self.monthNav, "mousedown", onClick(onMonthNavClick)), bind(self.monthNav, ["keyup", "increment"], onYearInput), bind(self.daysContainer, "mousedown", onClick(selectDate))), void 0 !== self.timeContainer && void 0 !== self.minuteElement && void 0 !== self.hourElement && (bind(self.timeContainer, ["increment"], updateTime), bind(self.timeContainer, "blur", updateTime, {
                capture: !0
              }), bind(self.timeContainer, "mousedown", onClick(timeIncrement)), bind([self.hourElement, self.minuteElement], ["focus", "click"], function (e) {
                return e.target.select()
              }), void 0 !== self.secondElement && bind(self.secondElement, "focus", function () {
                return self.secondElement && self.secondElement.select()
              }), void 0 !== self.amPM && bind(self.amPM, "mousedown", onClick(function (e) {
                updateTime(e), triggerChange()
              })))
            }(), (self.selectedDates.length || self.config.noCalendar) && (self.config.enableTime && setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj || self.config.minDate : void 0), updateValue(!1)), setCalendarWidth(), self.showTimeInput = 0 < self.selectedDates.length || self.config.noCalendar;
          var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          !self.isMobile && isSafari && positionCalendar(), triggerEvent("onReady")
        }(), self
      }

      function _flatpickr(nodeList, config) {
        for (var nodes = Array.prototype.slice.call(nodeList).filter(function (x) {
            return x instanceof HTMLElement
          }), instances = [], i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          try {
            if (null !== node.getAttribute("data-fp-omit")) continue;
            void 0 !== node._flatpickr && (node._flatpickr.destroy(), node._flatpickr = void 0), node._flatpickr = FlatpickrInstance(node, config || {}), instances.push(node._flatpickr)
          } catch (e) {
            console.error(e)
          }
        }
        return 1 === instances.length ? instances[0] : instances
      }
      "undefined" != typeof HTMLElement && (HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
        return _flatpickr(this, config)
      }, HTMLElement.prototype.flatpickr = function (config) {
        return _flatpickr([this], config)
      });
      var flatpickr = function (selector, config) {
        return "string" == typeof selector ? _flatpickr(window.document.querySelectorAll(selector), config) : selector instanceof Node ? _flatpickr([selector], config) : _flatpickr(selector, config)
      };
      return flatpickr.defaultConfig = defaults, flatpickr.l10ns = {
        en: __assign({}, english),
        default: __assign({}, english)
      }, flatpickr.localize = function (l10n) {
        flatpickr.l10ns.default = __assign({}, flatpickr.l10ns.default, l10n)
      }, flatpickr.setDefaults = function (config) {
        flatpickr.defaultConfig = __assign({}, flatpickr.defaultConfig, config)
      }, flatpickr.parseDate = createDateParser({}), flatpickr.formatDate = createDateFormatter({}), flatpickr.compareDates = compareDates, "undefined" != typeof jQuery && (jQuery.fn.flatpickr = function (config) {
        return _flatpickr(this, config)
      }), Date.prototype.fp_incr = function (days) {
        return new Date(this.getFullYear(), this.getMonth(), this.getDate() + ("string" == typeof days ? parseInt(days, 10) : days))
      }, "undefined" != typeof window && (window.flatpickr = flatpickr), flatpickr
    }, "object" == typeof exports && void 0 !== module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : (global = global || self).flatpickr = factory()
  }, {}],
  3: [function (require, module, exports) {
    var global, factory;
    global = this, factory = function (exports) {
      "use strict";
      var fp = "undefined" != typeof window && void 0 !== window.flatpickr ? window.flatpickr : {
          l10ns: {}
        },
        Arabic = {
          weekdays: {
            shorthand: ["أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"],
            longhand: ["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت"]
          },
          months: {
            shorthand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
            longhand: ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"]
          }
        };
      fp.l10ns.ar = Arabic;
      var ar = fp.l10ns;
      exports.Arabic = Arabic, exports.default = ar, Object.defineProperty(exports, "__esModule", {
        value: !0
      })
    }, "object" == typeof exports && void 0 !== module ? factory(exports) : "function" == typeof define && define.amd ? define(["exports"], factory) : factory((global = global || self).ar = {})
  }, {}],
  4: [function (require, module, exports) {
    var global, factory;
    global = this, factory = function (exports) {
      "use strict";
      var english = {
        weekdays: {
          shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        },
        months: {
          shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
          longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: function (nth) {
          var s = nth % 100;
          if (3 < s && s < 21) return "th";
          switch (s % 10) {
            case 1:
              return "st";
            case 2:
              return "nd";
            case 3:
              return "rd";
            default:
              return "th"
          }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        scrollTitle: "Scroll to increment",
        toggleTitle: "Click to toggle",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year"
      };
      exports.english = english, exports.default = english, Object.defineProperty(exports, "__esModule", {
        value: !0
      })
    }, "object" == typeof exports && void 0 !== module ? factory(exports) : "function" == typeof define && define.amd ? define(["exports"], factory) : factory((global = global || self).default = {})
  }, {}],
  5: [function (require, module, exports) {
    ! function (o) {
      var n = {};

      function i(e) {
        if (n[e]) return n[e].exports;
        var t = n[e] = {
          i: e,
          l: !1,
          exports: {}
        };
        return o[e].call(t.exports, t, t.exports, i), t.l = !0, t.exports
      }
      i.m = o, i.c = n, i.d = function (e, t, o) {
        i.o(e, t) || Object.defineProperty(e, t, {
          enumerable: !0,
          get: o
        })
      }, i.r = function (e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
          value: "Module"
        }), Object.defineProperty(e, "__esModule", {
          value: !0
        })
      }, i.t = function (t, e) {
        if (1 & e && (t = i(t)), 8 & e) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var o = Object.create(null);
        if (i.r(o), Object.defineProperty(o, "default", {
            enumerable: !0,
            value: t
          }), 2 & e && "string" != typeof t)
          for (var n in t) i.d(o, n, function (e) {
            return t[e]
          }.bind(null, n));
        return o
      }, i.n = function (e) {
        var t = e && e.__esModule ? function () {
          return e.default
        } : function () {
          return e
        };
        return i.d(t, "a", t), t
      }, i.o = function (e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
      }, i.p = "", i(i.s = 11)
    }([, , function (e, t, o) {
      "use strict";
      e.exports = function (e) {
        "complete" === document.readyState || "interactive" === document.readyState ? e.call() : document.attachEvent ? document.attachEvent("onreadystatechange", function () {
          "interactive" === document.readyState && e.call()
        }) : document.addEventListener && document.addEventListener("DOMContentLoaded", e)
      }
    }, , function (o, e, t) {
      "use strict";
      (function (e) {
        var t;
        t = "undefined" != typeof window ? window : void 0 !== e ? e : "undefined" != typeof self ? self : {}, o.exports = t
      }).call(this, t(5))
    }, function (e, t, o) {
      "use strict";
      var n, i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
      };
      n = function () {
        return this
      }();
      try {
        n = n || Function("return this")() || (0, eval)("this")
      } catch (e) {
        "object" === ("undefined" == typeof window ? "undefined" : i(window)) && (n = window)
      }
      e.exports = n
    }, , , , , , function (e, t, o) {
      e.exports = o(12)
    }, function (e, t, o) {
      "use strict";
      var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
          return typeof e
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        },
        i = l(o(2)),
        a = o(4),
        r = l(o(13));

      function l(e) {
        return e && e.__esModule ? e : {
          default: e
        }
      }
      var s = a.window.jarallax;
      if (a.window.jarallax = r.default, a.window.jarallax.noConflict = function () {
          return a.window.jarallax = s, this
        }, void 0 !== a.jQuery) {
        var c = function () {
          var e = arguments || [];
          Array.prototype.unshift.call(e, this);
          var t = r.default.apply(a.window, e);
          return "object" !== (void 0 === t ? "undefined" : n(t)) ? t : this
        };
        c.constructor = r.default.constructor;
        var u = a.jQuery.fn.jarallax;
        a.jQuery.fn.jarallax = c, a.jQuery.fn.jarallax.noConflict = function () {
          return a.jQuery.fn.jarallax = u, this
        }
      }(0, i.default)(function () {
        (0, r.default)(document.querySelectorAll("[data-jarallax]"))
      })
    }, function (e, j, S) {
      "use strict";
      (function (e) {
        Object.defineProperty(j, "__esModule", {
          value: !0
        });
        var d = function (e, t) {
            if (Array.isArray(e)) return e;
            if (Symbol.iterator in Object(e)) return function (e, t) {
              var o = [],
                n = !0,
                i = !1,
                a = void 0;
              try {
                for (var r, l = e[Symbol.iterator](); !(n = (r = l.next()).done) && (o.push(r.value), !t || o.length !== t); n = !0);
              } catch (e) {
                i = !0, a = e
              } finally {
                try {
                  !n && l.return && l.return()
                } finally {
                  if (i) throw a
                }
              }
              return o
            }(e, t);
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
          },
          t = function () {
            function n(e, t) {
              for (var o = 0; o < t.length; o++) {
                var n = t[o];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
              }
            }
            return function (e, t, o) {
              return t && n(e.prototype, t), o && n(e, o), e
            }
          }(),
          p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
            return typeof e
          } : function (e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
          },
          o = a(S(2)),
          n = a(S(14)),
          i = S(4);

        function a(e) {
          return e && e.__esModule ? e : {
            default: e
          }
        }
        var s = -1 < navigator.userAgent.indexOf("MSIE ") || -1 < navigator.userAgent.indexOf("Trident/") || -1 < navigator.userAgent.indexOf("Edge/"),
          r = function () {
            for (var e = "transform WebkitTransform MozTransform".split(" "), t = document.createElement("div"), o = 0; o < e.length; o++)
              if (t && void 0 !== t.style[e[o]]) return e[o];
            return !1
          }(),
          b = void 0,
          v = void 0,
          l = void 0,
          c = !1,
          u = !1;

        function m(e) {
          b = i.window.innerWidth || document.documentElement.clientWidth, v = i.window.innerHeight || document.documentElement.clientHeight, "object" !== (void 0 === e ? "undefined" : p(e)) || "load" !== e.type && "dom-loaded" !== e.type || (c = !0)
        }
        m(), i.window.addEventListener("resize", m), i.window.addEventListener("orientationchange", m), i.window.addEventListener("load", m), (0, o.default)(function () {
          m({
            type: "dom-loaded"
          })
        });
        var f = [],
          y = !1;

        function g() {
          if (f.length) {
            l = void 0 !== i.window.pageYOffset ? i.window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
            var t = c || !y || y.width !== b || y.height !== v,
              o = u || t || !y || y.y !== l;
            u = c = !1, (t || o) && (f.forEach(function (e) {
              t && e.onResize(), o && e.onScroll()
            }), y = {
              width: b,
              height: v,
              y: l
            }), (0, n.default)(g)
          }
        }
        var h = !!e.ResizeObserver && new e.ResizeObserver(function (e) {
            e && e.length && (0, n.default)(function () {
              e.forEach(function (e) {
                e.target && e.target.jarallax && (c || e.target.jarallax.onResize(), u = !0)
              })
            })
          }),
          x = 0,
          w = function () {
            function u(e, t) {
              ! function (e, t) {
                if (!(e instanceof u)) throw new TypeError("Cannot call a class as a function")
              }(this);
              var o = this;
              o.instanceID = x++, o.$item = e, o.defaults = {
                type: "scroll",
                speed: .5,
                imgSrc: null,
                imgElement: ".jarallax-img",
                imgSize: "cover",
                imgPosition: "50% 50%",
                imgRepeat: "no-repeat",
                keepImg: !1,
                elementInViewport: null,
                zIndex: -100,
                disableParallax: !1,
                disableVideo: !1,
                automaticResize: !0,
                videoSrc: null,
                videoStartTime: 0,
                videoEndTime: 0,
                videoVolume: 0,
                videoLoop: !0,
                videoPlayOnlyVisible: !0,
                onScroll: null,
                onInit: null,
                onDestroy: null,
                onCoverImage: null
              };
              var n = o.$item.getAttribute("data-jarallax"),
                i = JSON.parse(n || "{}");
              n && console.warn("Detected usage of deprecated data-jarallax JSON options, you should use pure data-attribute options. See info here - https://github.com/nk-o/jarallax/issues/53");
              var a = o.$item.dataset || {},
                r = {};
              if (Object.keys(a).forEach(function (e) {
                  var t = e.substr(0, 1).toLowerCase() + e.substr(1);
                  t && void 0 !== o.defaults[t] && (r[t] = a[e])
                }), o.options = o.extend({}, o.defaults, i, r, t), o.pureOptions = o.extend({}, o.options), Object.keys(o.options).forEach(function (e) {
                  "true" === o.options[e] ? o.options[e] = !0 : "false" === o.options[e] && (o.options[e] = !1)
                }), o.options.speed = Math.min(2, Math.max(-1, parseFloat(o.options.speed))), (o.options.noAndroid || o.options.noIos) && (console.warn("Detected usage of deprecated noAndroid or noIos options, you should use disableParallax option. See info here - https://github.com/nk-o/jarallax/#disable-on-mobile-devices"), o.options.disableParallax || (o.options.noIos && o.options.noAndroid ? o.options.disableParallax = /iPad|iPhone|iPod|Android/ : o.options.noIos ? o.options.disableParallax = /iPad|iPhone|iPod/ : o.options.noAndroid && (o.options.disableParallax = /Android/))), "string" == typeof o.options.disableParallax && (o.options.disableParallax = new RegExp(o.options.disableParallax)), o.options.disableParallax instanceof RegExp) {
                var l = o.options.disableParallax;
                o.options.disableParallax = function () {
                  return l.test(navigator.userAgent)
                }
              }
              if ("function" != typeof o.options.disableParallax && (o.options.disableParallax = function () {
                  return !1
                }), "string" == typeof o.options.disableVideo && (o.options.disableVideo = new RegExp(o.options.disableVideo)), o.options.disableVideo instanceof RegExp) {
                var s = o.options.disableVideo;
                o.options.disableVideo = function () {
                  return s.test(navigator.userAgent)
                }
              }
              "function" != typeof o.options.disableVideo && (o.options.disableVideo = function () {
                return !1
              });
              var c = o.options.elementInViewport;
              c && "object" === (void 0 === c ? "undefined" : p(c)) && void 0 !== c.length && (c = d(c, 1)[0]), c instanceof Element || (c = null), o.options.elementInViewport = c, o.image = {
                src: o.options.imgSrc || null,
                $container: null,
                useImgTag: !1,
                position: /iPad|iPhone|iPod|Android/.test(navigator.userAgent) ? "absolute" : "fixed"
              }, o.initImg() && o.canInitParallax() && o.init()
            }
            return t(u, [{
              key: "css",
              value: function (t, o) {
                return "string" == typeof o ? i.window.getComputedStyle(t).getPropertyValue(o) : (o.transform && r && (o[r] = o.transform), Object.keys(o).forEach(function (e) {
                  t.style[e] = o[e]
                }), t)
              }
            }, {
              key: "extend",
              value: function (o) {
                var n = arguments;
                return o = o || {}, Object.keys(arguments).forEach(function (t) {
                  n[t] && Object.keys(n[t]).forEach(function (e) {
                    o[e] = n[t][e]
                  })
                }), o
              }
            }, {
              key: "getWindowData",
              value: function () {
                return {
                  width: b,
                  height: v,
                  y: l
                }
              }
            }, {
              key: "initImg",
              value: function () {
                var e = this,
                  t = e.options.imgElement;
                return t && "string" == typeof t && (t = e.$item.querySelector(t)), t instanceof Element || (t = null), t && (e.options.keepImg ? e.image.$item = t.cloneNode(!0) : (e.image.$item = t, e.image.$itemParent = t.parentNode), e.image.useImgTag = !0), !(!e.image.$item && (null === e.image.src && (e.image.src = e.css(e.$item, "background-image").replace(/^url\(['"]?/g, "").replace(/['"]?\)$/g, "")), !e.image.src || "none" === e.image.src))
              }
            }, {
              key: "canInitParallax",
              value: function () {
                return r && !this.options.disableParallax()
              }
            }, {
              key: "init",
              value: function () {
                var e = this,
                  t = {
                    position: "absolute",
                    top: 0,
                    left: 0,
                    width: "100%",
                    height: "100%",
                    overflow: "hidden",
                    pointerEvents: "none"
                  },
                  o = {};
                if (!e.options.keepImg) {
                  var n = e.$item.getAttribute("style");
                  if (n && e.$item.setAttribute("data-jarallax-original-styles", n), e.image.useImgTag) {
                    var i = e.image.$item.getAttribute("style");
                    i && e.image.$item.setAttribute("data-jarallax-original-styles", i)
                  }
                }
                if ("static" === e.css(e.$item, "position") && e.css(e.$item, {
                    position: "relative"
                  }), "auto" === e.css(e.$item, "z-index") && e.css(e.$item, {
                    zIndex: 0
                  }), e.image.$container = document.createElement("div"), e.css(e.image.$container, t), e.css(e.image.$container, {
                    "z-index": e.options.zIndex
                  }), s && e.css(e.image.$container, {
                    opacity: .9999
                  }), e.image.$container.setAttribute("id", "jarallax-container-" + e.instanceID), e.$item.appendChild(e.image.$container), e.image.useImgTag ? o = e.extend({
                    "object-fit": e.options.imgSize,
                    "object-position": e.options.imgPosition,
                    "font-family": "object-fit: " + e.options.imgSize + "; object-position: " + e.options.imgPosition + ";",
                    "max-width": "none"
                  }, t, o) : (e.image.$item = document.createElement("div"), e.image.src && (o = e.extend({
                    "background-position": e.options.imgPosition,
                    "background-size": e.options.imgSize,
                    "background-repeat": e.options.imgRepeat,
                    "background-image": 'url("' + e.image.src + '")'
                  }, t, o))), "opacity" !== e.options.type && "scale" !== e.options.type && "scale-opacity" !== e.options.type && 1 !== e.options.speed || (e.image.position = "absolute"), "fixed" === e.image.position)
                  for (var a = 0, r = e.$item; null !== r && r !== document && 0 === a;) {
                    var l = e.css(r, "-webkit-transform") || e.css(r, "-moz-transform") || e.css(r, "transform");
                    l && "none" !== l && (a = 1, e.image.position = "absolute"), r = r.parentNode
                  }
                o.position = e.image.position, e.css(e.image.$item, o), e.image.$container.appendChild(e.image.$item), e.onResize(), e.onScroll(!0), e.options.automaticResize && h && h.observe(e.$item), e.options.onInit && e.options.onInit.call(e), "none" !== e.css(e.$item, "background-image") && e.css(e.$item, {
                  "background-image": "none"
                }), e.addToParallaxList()
              }
            }, {
              key: "addToParallaxList",
              value: function () {
                f.push(this), 1 === f.length && g()
              }
            }, {
              key: "removeFromParallaxList",
              value: function () {
                var o = this;
                f.forEach(function (e, t) {
                  e.instanceID === o.instanceID && f.splice(t, 1)
                })
              }
            }, {
              key: "destroy",
              value: function () {
                var e = this;
                e.removeFromParallaxList();
                var t = e.$item.getAttribute("data-jarallax-original-styles");
                if (e.$item.removeAttribute("data-jarallax-original-styles"), t ? e.$item.setAttribute("style", t) : e.$item.removeAttribute("style"), e.image.useImgTag) {
                  var o = e.image.$item.getAttribute("data-jarallax-original-styles");
                  e.image.$item.removeAttribute("data-jarallax-original-styles"), o ? e.image.$item.setAttribute("style", t) : e.image.$item.removeAttribute("style"), e.image.$itemParent && e.image.$itemParent.appendChild(e.image.$item)
                }
                e.$clipStyles && e.$clipStyles.parentNode.removeChild(e.$clipStyles), e.image.$container && e.image.$container.parentNode.removeChild(e.image.$container), e.options.onDestroy && e.options.onDestroy.call(e), delete e.$item.jarallax
              }
            }, {
              key: "clipContainer",
              value: function () {
                if ("fixed" === this.image.position) {
                  var e = this,
                    t = e.image.$container.getBoundingClientRect(),
                    o = t.width,
                    n = t.height;
                  e.$clipStyles || (e.$clipStyles = document.createElement("style"), e.$clipStyles.setAttribute("type", "text/css"), e.$clipStyles.setAttribute("id", "jarallax-clip-" + e.instanceID), (document.head || document.getElementsByTagName("head")[0]).appendChild(e.$clipStyles));
                  var i = "#jarallax-container-" + e.instanceID + " {\n           clip: rect(0 " + o + "px " + n + "px 0);\n           clip: rect(0, " + o + "px, " + n + "px, 0);\n        }";
                  e.$clipStyles.styleSheet ? e.$clipStyles.styleSheet.cssText = i : e.$clipStyles.innerHTML = i
                }
              }
            }, {
              key: "coverImage",
              value: function () {
                var l, e = this,
                  t = e.image.$container.getBoundingClientRect(),
                  o = t.height,
                  n = e.options.speed,
                  i = "scroll" === e.options.type || "scroll-opacity" === e.options.type,
                  a = 0,
                  r = o;
                return i && (n < 0 ? (a = n * Math.max(o, v), v < o && (a -= n * (o - v))) : a = n * (o + v), 1 < n ? r = Math.abs(a - v) : n < 0 ? r = a / n + Math.abs(a) : r += (v - o) * (1 - n), a /= 2), e.parallaxScrollDistance = a, l = i ? (v - r) / 2 : (o - r) / 2, e.css(e.image.$item, {
                  height: r + "px",
                  marginTop: l + "px",
                  left: "fixed" === e.image.position ? t.left + "px" : "0",
                  width: t.width + "px"
                }), e.options.onCoverImage && e.options.onCoverImage.call(e), {
                  image: {
                    height: r,
                    marginTop: l
                  },
                  container: t
                }
              }
            }, {
              key: "isVisible",
              value: function () {
                return this.isElementInViewport || !1
              }
            }, {
              key: "onScroll",
              value: function (e) {
                var t = this,
                  o = t.$item.getBoundingClientRect(),
                  n = o.top,
                  i = o.height,
                  a = {},
                  r = o;
                if (t.options.elementInViewport && (r = t.options.elementInViewport.getBoundingClientRect()), t.isElementInViewport = 0 <= r.bottom && 0 <= r.right && r.top <= v && r.left <= b, e || t.isElementInViewport) {
                  var l = Math.max(0, n),
                    s = Math.max(0, i + n),
                    c = Math.max(0, -n),
                    u = Math.max(0, n + i - v),
                    d = Math.max(0, i - (n + i - v)),
                    p = Math.max(0, -n + v - i),
                    m = 1 - 2 * (v - n) / (v + i),
                    f = 1;
                  if (i < v ? f = 1 - (c || u) / i : s <= v ? f = s / v : d <= v && (f = d / v), "opacity" !== t.options.type && "scale-opacity" !== t.options.type && "scroll-opacity" !== t.options.type || (a.transform = "translate3d(0,0,0)", a.opacity = f), "scale" === t.options.type || "scale-opacity" === t.options.type) {
                    var y = 1;
                    t.options.speed < 0 ? y -= t.options.speed * f : y += t.options.speed * (1 - f), a.transform = "scale(" + y + ") translate3d(0,0,0)"
                  }
                  if ("scroll" === t.options.type || "scroll-opacity" === t.options.type) {
                    var g = t.parallaxScrollDistance * m;
                    "absolute" === t.image.position && (g -= n), a.transform = "translate3d(0," + g + "px,0)"
                  }
                  t.css(t.image.$item, a), t.options.onScroll && t.options.onScroll.call(t, {
                    section: o,
                    beforeTop: l,
                    beforeTopEnd: s,
                    afterTop: c,
                    beforeBottom: u,
                    beforeBottomEnd: d,
                    afterBottom: p,
                    visiblePercent: f,
                    fromViewportCenter: m
                  })
                }
              }
            }, {
              key: "onResize",
              value: function () {
                this.coverImage(), this.clipContainer()
              }
            }]), u
          }(),
          $ = function (e) {
            ("object" === ("undefined" == typeof HTMLElement ? "undefined" : p(HTMLElement)) ? e instanceof HTMLElement : e && "object" === (void 0 === e ? "undefined" : p(e)) && null !== e && 1 === e.nodeType && "string" == typeof e.nodeName) && (e = [e]);
            for (var t = arguments[1], o = Array.prototype.slice.call(arguments, 2), n = e.length, i = 0, a = void 0; i < n; i++)
              if ("object" === (void 0 === t ? "undefined" : p(t)) || void 0 === t ? e[i].jarallax || (e[i].jarallax = new w(e[i], t)) : e[i].jarallax && (a = e[i].jarallax[t].apply(e[i].jarallax, o)), void 0 !== a) return a;
            return e
          };
        $.constructor = w, j.default = $
      }).call(this, S(5))
    }, function (e, t, o) {
      "use strict";
      var n = o(4),
        i = n.requestAnimationFrame || n.webkitRequestAnimationFrame || n.mozRequestAnimationFrame || function (e) {
          var t = +new Date,
            o = Math.max(0, 16 - (t - a)),
            n = setTimeout(e, o);
          return a = t, n
        },
        a = +new Date,
        r = n.cancelAnimationFrame || n.webkitCancelAnimationFrame || n.mozCancelAnimationFrame || clearTimeout;
      Function.prototype.bind && (i = i.bind(n), r = r.bind(n)), (e.exports = i).cancel = r
    }])
  }, {}],
  6: [function (require, module, exports) {
    var factory;
    factory = function ($) {
      var BarRating = function () {
        function BarRating() {
          var self = this,
            findOption = function (value) {
              return $.isNumeric(value) && (value = Math.floor(value)), $('option[value="' + value + '"]', self.$elem)
            },
            getData = function (key) {
              var data = self.$elem.data("barrating");
              return void 0 !== key ? data[key] : data
            },
            setData = function (key, value) {
              null !== value && "object" == typeof value ? self.$elem.data("barrating", value) : self.$elem.data("barrating")[key] = value
            },
            saveDataOnElement = function () {
              var initialRating, $opt = (initialRating = self.options.initialRating) ? findOption(initialRating) : $("option:selected", self.$elem),
                $emptyOpt = function () {
                  var $emptyOpt = self.$elem.find('option[value="' + self.options.emptyValue + '"]');
                  return !$emptyOpt.length && self.options.allowEmpty ? ($emptyOpt = $("<option />", {
                    value: self.options.emptyValue
                  })).prependTo(self.$elem) : $emptyOpt
                }(),
                value = $opt.val(),
                text = $opt.data("html") ? $opt.data("html") : $opt.text(),
                allowEmpty = null !== self.options.allowEmpty ? self.options.allowEmpty : !!$emptyOpt.length,
                emptyValue = $emptyOpt.length ? $emptyOpt.val() : null,
                emptyText = $emptyOpt.length ? $emptyOpt.text() : null;
              setData(null, {
                userOptions: self.options,
                ratingValue: value,
                ratingText: text,
                originalRatingValue: value,
                originalRatingText: text,
                allowEmpty: allowEmpty,
                emptyRatingValue: emptyValue,
                emptyRatingText: emptyText,
                readOnly: self.options.readonly,
                ratingMade: !1
              })
            },
            ratingText = function () {
              return getData("ratingText")
            },
            ratingValue = function () {
              return getData("ratingValue")
            },
            nextAllorPreviousAll = function () {
              return getData("userOptions").reverse ? "nextAll" : "prevAll"
            },
            setSelectFieldValue = function (value) {
              findOption(value).prop("selected", !0), self.$elem.change()
            },
            showSelectedRating = function (text) {
              (text = text || ratingText()) == getData("emptyRatingText") && (text = ""), self.options.showSelectedRating && self.$elem.parent().find(".br-current-rating").text(text)
            },
            resetStyle = function () {
              self.$widget.find("a").removeClass(function (index, classes) {
                return (classes.match(/(^|\s)br-\S+/g) || []).join(" ")
              })
            },
            applyStyle = function () {
              var value, $all, $fractional, $a = self.$widget.find('a[data-rating-value="' + ratingValue() + '"]'),
                initialRating = getData("userOptions").initialRating,
                baseValue = $.isNumeric(ratingValue()) ? ratingValue() : 0,
                f = (value = initialRating, Math.round(Math.floor(10 * value) / 10 % 1 * 100));
              if (resetStyle(), $a.addClass("br-selected br-current")[nextAllorPreviousAll()]().addClass("br-selected"), !getData("ratingMade") && $.isNumeric(initialRating)) {
                if (initialRating <= baseValue || !f) return;
                $all = self.$widget.find("a"), ($fractional = $a.length ? $a[getData("userOptions").reverse ? "prev" : "next"]() : $all[getData("userOptions").reverse ? "last" : "first"]()).addClass("br-fractional"), $fractional.addClass("br-fractional-" + f)
              }
            },
            attachClickHandler = function ($elements) {
              $elements.on("click.barrating", function (event) {
                var value, text, $element, $a = $(this),
                  options = getData("userOptions");
                return event.preventDefault(), value = $a.attr("data-rating-value"), text = $a.attr("data-rating-text"), $element = $a, getData("allowEmpty") && getData("userOptions").deselectable && ratingValue() == $element.attr("data-rating-value") && (value = getData("emptyRatingValue"), text = getData("emptyRatingText")), setData("ratingValue", value), setData("ratingText", text), setData("ratingMade", !0), setSelectFieldValue(value), showSelectedRating(text), applyStyle(), options.onSelect.call(self, ratingValue(), ratingText(), event), !1
              })
            },
            fastClicks = function ($elements) {
              $elements.on("touchstart.barrating", function (event) {
                event.preventDefault(), event.stopPropagation(), $(this).click()
              })
            },
            attachHandlers = function ($elements) {
              attachClickHandler($elements), self.options.hoverState && (! function ($elements) {
                $elements.on("mouseenter.barrating", function () {
                  var $a = $(this);
                  resetStyle(), $a.addClass("br-active")[nextAllorPreviousAll()]().addClass("br-active"), showSelectedRating($a.attr("data-rating-text"))
                })
              }($elements), self.$widget.on("mouseleave.barrating blur.barrating", function () {
                showSelectedRating(), applyStyle()
              }))
            },
            detachHandlers = function ($elements) {
              $elements.off(".barrating")
            },
            setupHandlers = function (readonly) {
              var $elements = self.$widget.find("a");
              fastClicks($elements), readonly ? (detachHandlers($elements), function ($elements) {
                $elements.on("click.barrating", function (event) {
                  event.preventDefault()
                })
              }($elements)) : attachHandlers($elements)
            };
          this.show = function () {
            var classes, $w;
            getData() || (classes = ["br-wrapper"], "" !== self.options.theme && classes.push("br-theme-" + self.options.theme), self.$elem.wrap($("<div />", {
              class: classes.join(" ")
            })), saveDataOnElement(), self.$widget = ($w = $("<div />", {
              class: "br-widget"
            }), self.$elem.find("option").each(function () {
              var val, text, html, $a;
              (val = $(this).val()) !== getData("emptyRatingValue") && (text = $(this).text(), (html = $(this).data("html")) && (text = html), $a = $("<a />", {
                href: "#",
                "data-rating-value": val,
                "data-rating-text": text,
                html: self.options.showValues ? text : ""
              }), $w.append($a))
            }), self.options.showSelectedRating && $w.append($("<div />", {
              text: "",
              class: "br-current-rating"
            })), self.options.reverse && $w.addClass("br-reverse"), self.options.readonly && $w.addClass("br-readonly"), $w), self.$widget.insertAfter(self.$elem), applyStyle(), showSelectedRating(), setupHandlers(self.options.readonly), self.$elem.hide())
          }, this.readonly = function (state) {
            "boolean" == typeof state && getData("readOnly") != state && (setupHandlers(state), setData("readOnly", state), self.$widget.toggleClass("br-readonly"))
          }, this.set = function (value) {
            var options = getData("userOptions");
            0 !== self.$elem.find('option[value="' + value + '"]').length && (setData("ratingValue", value), setData("ratingText", self.$elem.find('option[value="' + value + '"]').text()), setData("ratingMade", !0), setSelectFieldValue(ratingValue()), showSelectedRating(ratingText()), applyStyle(), options.silent || options.onSelect.call(this, ratingValue(), ratingText()))
          }, this.clear = function () {
            var options = getData("userOptions");
            setData("ratingValue", getData("originalRatingValue")), setData("ratingText", getData("originalRatingText")), setData("ratingMade", !1), $("option", self.$elem).prop("selected", function () {
              return this.defaultSelected
            }), self.$elem.change(), showSelectedRating(ratingText()), applyStyle(), options.onClear.call(this, ratingValue(), ratingText())
          }, this.destroy = function () {
            var value = ratingValue(),
              text = ratingText(),
              options = getData("userOptions");
            detachHandlers(self.$widget.find("a")), self.$widget.remove(), self.$elem.removeData("barrating"), self.$elem.unwrap(), self.$elem.show(), options.onDestroy.call(this, value, text)
          }
        }
        return BarRating.prototype.init = function (options, elem) {
          return this.$elem = $(elem), this.options = $.extend({}, $.fn.barrating.defaults, options), this.options
        }, BarRating
      }();
      $.fn.barrating = function (method, options) {
        return this.each(function () {
          var plugin = new BarRating;
          if ($(this).is("select") || $.error("Sorry, this plugin only works with select fields."), plugin.hasOwnProperty(method)) {
            if (plugin.init(options, this), "show" === method) return plugin.show(options);
            if (plugin.$elem.data("barrating")) return plugin.$widget = $(this).next(".br-widget"), plugin[method](options)
          } else {
            if ("object" == typeof method || !method) return options = method, plugin.init(options, this), plugin.show();
            $.error("Method " + method + " does not exist on jQuery.barrating")
          }
        })
      }, $.fn.barrating.defaults = {
        theme: "",
        initialRating: null,
        allowEmpty: null,
        emptyValue: "",
        showValues: !1,
        showSelectedRating: !0,
        deselectable: !0,
        reverse: !1,
        readonly: !1,
        fastClicks: !0,
        hoverState: !0,
        silent: !1,
        onSelect: function (value, text, event) {},
        onClear: function (value, text) {},
        onDestroy: function (value, text) {}
      }, $.fn.barrating.BarRating = BarRating
    }, "function" == typeof define && define.amd ? define(["jquery"], factory) : "object" == typeof module && module.exports ? module.exports = factory(require("jquery")) : factory(jQuery)
  }, {
    jquery: 7
  }],
  7: [function (require, module, exports) {
    ! function (global, factory) {
      "use strict";
      "object" == typeof module && "object" == typeof module.exports ? module.exports = global.document ? factory(global, !0) : function (w) {
        if (!w.document) throw new Error("jQuery requires a window with a document");
        return factory(w)
      } : factory(global)
    }("undefined" != typeof window ? window : this, function (window, noGlobal) {
      "use strict";
      var arr = [],
        document = window.document,
        getProto = Object.getPrototypeOf,
        slice = arr.slice,
        concat = arr.concat,
        push = arr.push,
        indexOf = arr.indexOf,
        class2type = {},
        toString = class2type.toString,
        hasOwn = class2type.hasOwnProperty,
        fnToString = hasOwn.toString,
        ObjectFunctionString = fnToString.call(Object),
        support = {},
        isFunction = function (obj) {
          return "function" == typeof obj && "number" != typeof obj.nodeType
        },
        isWindow = function (obj) {
          return null != obj && obj === obj.window
        },
        preservedScriptAttributes = {
          type: !0,
          src: !0,
          noModule: !0
        };

      function DOMEval(code, doc, node) {
        var i, script = (doc = doc || document).createElement("script");
        if (script.text = code, node)
          for (i in preservedScriptAttributes) node[i] && (script[i] = node[i]);
        doc.head.appendChild(script).parentNode.removeChild(script)
      }

      function toType(obj) {
        return null == obj ? obj + "" : "object" == typeof obj || "function" == typeof obj ? class2type[toString.call(obj)] || "object" : typeof obj
      }
      var jQuery = function (selector, context) {
          return new jQuery.fn.init(selector, context)
        },
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

      function isArrayLike(obj) {
        var length = !!obj && "length" in obj && obj.length,
          type = toType(obj);
        return !isFunction(obj) && !isWindow(obj) && ("array" === type || 0 === length || "number" == typeof length && 0 < length && length - 1 in obj)
      }
      jQuery.fn = jQuery.prototype = {
        jquery: "3.3.1",
        constructor: jQuery,
        length: 0,
        toArray: function () {
          return slice.call(this)
        },
        get: function (num) {
          return null == num ? slice.call(this) : num < 0 ? this[num + this.length] : this[num]
        },
        pushStack: function (elems) {
          var ret = jQuery.merge(this.constructor(), elems);
          return ret.prevObject = this, ret
        },
        each: function (callback) {
          return jQuery.each(this, callback)
        },
        map: function (callback) {
          return this.pushStack(jQuery.map(this, function (elem, i) {
            return callback.call(elem, i, elem)
          }))
        },
        slice: function () {
          return this.pushStack(slice.apply(this, arguments))
        },
        first: function () {
          return this.eq(0)
        },
        last: function () {
          return this.eq(-1)
        },
        eq: function (i) {
          var len = this.length,
            j = +i + (i < 0 ? len : 0);
          return this.pushStack(0 <= j && j < len ? [this[j]] : [])
        },
        end: function () {
          return this.prevObject || this.constructor()
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
      }, jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
          i = 1,
          length = arguments.length,
          deep = !1;
        for ("boolean" == typeof target && (deep = target, target = arguments[i] || {}, i++), "object" == typeof target || isFunction(target) || (target = {}), i === length && (target = this, i--); i < length; i++)
          if (null != (options = arguments[i]))
            for (name in options) src = target[name], target !== (copy = options[name]) && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, clone = src && Array.isArray(src) ? src : []) : clone = src && jQuery.isPlainObject(src) ? src : {}, target[name] = jQuery.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
        return target
      }, jQuery.extend({
        expando: "jQuery" + ("3.3.1" + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function (msg) {
          throw new Error(msg)
        },
        noop: function () {},
        isPlainObject: function (obj) {
          var proto, Ctor;
          return !(!obj || "[object Object]" !== toString.call(obj)) && (!(proto = getProto(obj)) || "function" == typeof (Ctor = hasOwn.call(proto, "constructor") && proto.constructor) && fnToString.call(Ctor) === ObjectFunctionString)
        },
        isEmptyObject: function (obj) {
          var name;
          for (name in obj) return !1;
          return !0
        },
        globalEval: function (code) {
          DOMEval(code)
        },
        each: function (obj, callback) {
          var length, i = 0;
          if (isArrayLike(obj))
            for (length = obj.length; i < length && !1 !== callback.call(obj[i], i, obj[i]); i++);
          else
            for (i in obj)
              if (!1 === callback.call(obj[i], i, obj[i])) break;
          return obj
        },
        trim: function (text) {
          return null == text ? "" : (text + "").replace(rtrim, "")
        },
        makeArray: function (arr, results) {
          var ret = results || [];
          return null != arr && (isArrayLike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [arr] : arr) : push.call(ret, arr)), ret
        },
        inArray: function (elem, arr, i) {
          return null == arr ? -1 : indexOf.call(arr, elem, i)
        },
        merge: function (first, second) {
          for (var len = +second.length, j = 0, i = first.length; j < len; j++) first[i++] = second[j];
          return first.length = i, first
        },
        grep: function (elems, callback, invert) {
          for (var matches = [], i = 0, length = elems.length, callbackExpect = !invert; i < length; i++) !callback(elems[i], i) !== callbackExpect && matches.push(elems[i]);
          return matches
        },
        map: function (elems, callback, arg) {
          var length, value, i = 0,
            ret = [];
          if (isArrayLike(elems))
            for (length = elems.length; i < length; i++) null != (value = callback(elems[i], i, arg)) && ret.push(value);
          else
            for (i in elems) null != (value = callback(elems[i], i, arg)) && ret.push(value);
          return concat.apply([], ret)
        },
        guid: 1,
        support: support
      }), "function" == typeof Symbol && (jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]), jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase()
      });
      var Sizzle = function (window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date,
          preferredDoc = window.document,
          dirruns = 0,
          done = 0,
          classCache = createCache(),
          tokenCache = createCache(),
          compilerCache = createCache(),
          sortOrder = function (a, b) {
            return a === b && (hasDuplicate = !0), 0
          },
          hasOwn = {}.hasOwnProperty,
          arr = [],
          pop = arr.pop,
          push_native = arr.push,
          push = arr.push,
          slice = arr.slice,
          indexOf = function (list, elem) {
            for (var i = 0, len = list.length; i < len; i++)
              if (list[i] === elem) return i;
            return -1
          },
          booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
          whitespace = "[\\x20\\t\\r\\n\\f]",
          identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
          attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
          pseudos = ":(" + identifier + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|.*)\\)|)",
          rwhitespace = new RegExp(whitespace + "+", "g"),
          rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
          rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
          rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
          rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
          rpseudo = new RegExp(pseudos),
          ridentifier = new RegExp("^" + identifier + "$"),
          matchExpr = {
            ID: new RegExp("^#(" + identifier + ")"),
            CLASS: new RegExp("^\\.(" + identifier + ")"),
            TAG: new RegExp("^(" + identifier + "|[*])"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
          },
          rinputs = /^(?:input|select|textarea|button)$/i,
          rheader = /^h\d$/i,
          rnative = /^[^{]+\{\s*\[native \w/,
          rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
          rsibling = /[+~]/,
          runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
          funescape = function (_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            return high != high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320)
          },
          rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
          fcssescape = function (ch, asCodePoint) {
            return asCodePoint ? "\0" === ch ? "�" : ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " " : "\\" + ch
          },
          unloadHandler = function () {
            setDocument()
          },
          disabledAncestor = addCombinator(function (elem) {
            return !0 === elem.disabled && ("form" in elem || "label" in elem)
          }, {
            dir: "parentNode",
            next: "legend"
          });
        try {
          push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes), arr[preferredDoc.childNodes.length].nodeType
        } catch (e) {
          push = {
            apply: arr.length ? function (target, els) {
              push_native.apply(target, slice.call(els))
            } : function (target, els) {
              for (var j = target.length, i = 0; target[j++] = els[i++];);
              target.length = j - 1
            }
          }
        }

        function Sizzle(selector, context, results, seed) {
          var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument,
            nodeType = context ? context.nodeType : 9;
          if (results = results || [], "string" != typeof selector || !selector || 1 !== nodeType && 9 !== nodeType && 11 !== nodeType) return results;
          if (!seed && ((context ? context.ownerDocument || context : preferredDoc) !== document && setDocument(context), context = context || document, documentIsHTML)) {
            if (11 !== nodeType && (match = rquickExpr.exec(selector)))
              if (m = match[1]) {
                if (9 === nodeType) {
                  if (!(elem = context.getElementById(m))) return results;
                  if (elem.id === m) return results.push(elem), results
                } else if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) return results.push(elem), results
              } else {
                if (match[2]) return push.apply(results, context.getElementsByTagName(selector)), results;
                if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) return push.apply(results, context.getElementsByClassName(m)), results
              }
            if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
              if (1 !== nodeType) newContext = context, newSelector = selector;
              else if ("object" !== context.nodeName.toLowerCase()) {
                for ((nid = context.getAttribute("id")) ? nid = nid.replace(rcssescape, fcssescape) : context.setAttribute("id", nid = expando), i = (groups = tokenize(selector)).length; i--;) groups[i] = "#" + nid + " " + toSelector(groups[i]);
                newSelector = groups.join(","), newContext = rsibling.test(selector) && testContext(context.parentNode) || context
              }
              if (newSelector) try {
                return push.apply(results, newContext.querySelectorAll(newSelector)), results
              } catch (qsaError) {} finally {
                nid === expando && context.removeAttribute("id")
              }
            }
          }
          return select(selector.replace(rtrim, "$1"), context, results, seed)
        }

        function createCache() {
          var keys = [];
          return function cache(key, value) {
            return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()], cache[key + " "] = value
          }
        }

        function markFunction(fn) {
          return fn[expando] = !0, fn
        }

        function assert(fn) {
          var el = document.createElement("fieldset");
          try {
            return !!fn(el)
          } catch (e) {
            return !1
          } finally {
            el.parentNode && el.parentNode.removeChild(el), el = null
          }
        }

        function addHandle(attrs, handler) {
          for (var arr = attrs.split("|"), i = arr.length; i--;) Expr.attrHandle[arr[i]] = handler
        }

        function siblingCheck(a, b) {
          var cur = b && a,
            diff = cur && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex;
          if (diff) return diff;
          if (cur)
            for (; cur = cur.nextSibling;)
              if (cur === b) return -1;
          return a ? 1 : -1
        }

        function createInputPseudo(type) {
          return function (elem) {
            return "input" === elem.nodeName.toLowerCase() && elem.type === type
          }
        }

        function createButtonPseudo(type) {
          return function (elem) {
            var name = elem.nodeName.toLowerCase();
            return ("input" === name || "button" === name) && elem.type === type
          }
        }

        function createDisabledPseudo(disabled) {
          return function (elem) {
            return "form" in elem ? elem.parentNode && !1 === elem.disabled ? "label" in elem ? "label" in elem.parentNode ? elem.parentNode.disabled === disabled : elem.disabled === disabled : elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled : elem.disabled === disabled : "label" in elem && elem.disabled === disabled
          }
        }

        function createPositionalPseudo(fn) {
          return markFunction(function (argument) {
            return argument = +argument, markFunction(function (seed, matches) {
              for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--;) seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]))
            })
          })
        }

        function testContext(context) {
          return context && void 0 !== context.getElementsByTagName && context
        }
        for (i in support = Sizzle.support = {}, isXML = Sizzle.isXML = function (elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return !!documentElement && "HTML" !== documentElement.nodeName
          }, setDocument = Sizzle.setDocument = function (node) {
            var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            return doc !== document && 9 === doc.nodeType && doc.documentElement && (docElem = (document = doc).documentElement, documentIsHTML = !isXML(document), preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow && (subWindow.addEventListener ? subWindow.addEventListener("unload", unloadHandler, !1) : subWindow.attachEvent && subWindow.attachEvent("onunload", unloadHandler)), support.attributes = assert(function (el) {
              return el.className = "i", !el.getAttribute("className")
            }), support.getElementsByTagName = assert(function (el) {
              return el.appendChild(document.createComment("")), !el.getElementsByTagName("*").length
            }), support.getElementsByClassName = rnative.test(document.getElementsByClassName), support.getById = assert(function (el) {
              return docElem.appendChild(el).id = expando, !document.getElementsByName || !document.getElementsByName(expando).length
            }), support.getById ? (Expr.filter.ID = function (id) {
              var attrId = id.replace(runescape, funescape);
              return function (elem) {
                return elem.getAttribute("id") === attrId
              }
            }, Expr.find.ID = function (id, context) {
              if (void 0 !== context.getElementById && documentIsHTML) {
                var elem = context.getElementById(id);
                return elem ? [elem] : []
              }
            }) : (Expr.filter.ID = function (id) {
              var attrId = id.replace(runescape, funescape);
              return function (elem) {
                var node = void 0 !== elem.getAttributeNode && elem.getAttributeNode("id");
                return node && node.value === attrId
              }
            }, Expr.find.ID = function (id, context) {
              if (void 0 !== context.getElementById && documentIsHTML) {
                var node, i, elems, elem = context.getElementById(id);
                if (elem) {
                  if ((node = elem.getAttributeNode("id")) && node.value === id) return [elem];
                  for (elems = context.getElementsByName(id), i = 0; elem = elems[i++];)
                    if ((node = elem.getAttributeNode("id")) && node.value === id) return [elem]
                }
                return []
              }
            }), Expr.find.TAG = support.getElementsByTagName ? function (tag, context) {
              return void 0 !== context.getElementsByTagName ? context.getElementsByTagName(tag) : support.qsa ? context.querySelectorAll(tag) : void 0
            } : function (tag, context) {
              var elem, tmp = [],
                i = 0,
                results = context.getElementsByTagName(tag);
              if ("*" === tag) {
                for (; elem = results[i++];) 1 === elem.nodeType && tmp.push(elem);
                return tmp
              }
              return results
            }, Expr.find.CLASS = support.getElementsByClassName && function (className, context) {
              if (void 0 !== context.getElementsByClassName && documentIsHTML) return context.getElementsByClassName(className)
            }, rbuggyMatches = [], rbuggyQSA = [], (support.qsa = rnative.test(document.querySelectorAll)) && (assert(function (el) {
              docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>", el.querySelectorAll("[msallowcapture^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"), el.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"), el.querySelectorAll("[id~=" + expando + "-]").length || rbuggyQSA.push("~="), el.querySelectorAll(":checked").length || rbuggyQSA.push(":checked"), el.querySelectorAll("a#" + expando + "+*").length || rbuggyQSA.push(".#.+[+~]")
            }), assert(function (el) {
              el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
              var input = document.createElement("input");
              input.setAttribute("type", "hidden"), el.appendChild(input).setAttribute("name", "D"), el.querySelectorAll("[name=d]").length && rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?="), 2 !== el.querySelectorAll(":enabled").length && rbuggyQSA.push(":enabled", ":disabled"), docElem.appendChild(el).disabled = !0, 2 !== el.querySelectorAll(":disabled").length && rbuggyQSA.push(":enabled", ":disabled"), el.querySelectorAll("*,:x"), rbuggyQSA.push(",.*:")
            })), (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function (el) {
              support.disconnectedMatch = matches.call(el, "*"), matches.call(el, "[s!='']:x"), rbuggyMatches.push("!=", pseudos)
            }), rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")), rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")), hasCompare = rnative.test(docElem.compareDocumentPosition), contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
              var adown = 9 === a.nodeType ? a.documentElement : a,
                bup = b && b.parentNode;
              return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)))
            } : function (a, b) {
              if (b)
                for (; b = b.parentNode;)
                  if (b === a) return !0;
              return !1
            }, sortOrder = hasCompare ? function (a, b) {
              if (a === b) return hasDuplicate = !0, 0;
              var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
              return compare || (1 & (compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1) || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ? -1 : b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0 : 4 & compare ? -1 : 1)
            } : function (a, b) {
              if (a === b) return hasDuplicate = !0, 0;
              var cur, i = 0,
                aup = a.parentNode,
                bup = b.parentNode,
                ap = [a],
                bp = [b];
              if (!aup || !bup) return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
              if (aup === bup) return siblingCheck(a, b);
              for (cur = a; cur = cur.parentNode;) ap.unshift(cur);
              for (cur = b; cur = cur.parentNode;) bp.unshift(cur);
              for (; ap[i] === bp[i];) i++;
              return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0
            }), document
          }, Sizzle.matches = function (expr, elements) {
            return Sizzle(expr, null, null, elements)
          }, Sizzle.matchesSelector = function (elem, expr) {
            if ((elem.ownerDocument || elem) !== document && setDocument(elem), expr = expr.replace(rattributeQuotes, "='$1']"), support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) try {
              var ret = matches.call(elem, expr);
              if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType) return ret
            } catch (e) {}
            return 0 < Sizzle(expr, document, null, [elem]).length
          }, Sizzle.contains = function (context, elem) {
            return (context.ownerDocument || context) !== document && setDocument(context), contains(context, elem)
          }, Sizzle.attr = function (elem, name) {
            (elem.ownerDocument || elem) !== document && setDocument(elem);
            var fn = Expr.attrHandle[name.toLowerCase()],
              val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
            return void 0 !== val ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
          }, Sizzle.escape = function (sel) {
            return (sel + "").replace(rcssescape, fcssescape)
          }, Sizzle.error = function (msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg)
          }, Sizzle.uniqueSort = function (results) {
            var elem, duplicates = [],
              j = 0,
              i = 0;
            if (hasDuplicate = !support.detectDuplicates, sortInput = !support.sortStable && results.slice(0), results.sort(sortOrder), hasDuplicate) {
              for (; elem = results[i++];) elem === results[i] && (j = duplicates.push(i));
              for (; j--;) results.splice(duplicates[j], 1)
            }
            return sortInput = null, results
          }, getText = Sizzle.getText = function (elem) {
            var node, ret = "",
              i = 0,
              nodeType = elem.nodeType;
            if (nodeType) {
              if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                if ("string" == typeof elem.textContent) return elem.textContent;
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) ret += getText(elem)
              } else if (3 === nodeType || 4 === nodeType) return elem.nodeValue
            } else
              for (; node = elem[i++];) ret += getText(node);
            return ret
          }, (Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
              ">": {
                dir: "parentNode",
                first: !0
              },
              " ": {
                dir: "parentNode"
              },
              "+": {
                dir: "previousSibling",
                first: !0
              },
              "~": {
                dir: "previousSibling"
              }
            },
            preFilter: {
              ATTR: function (match) {
                return match[1] = match[1].replace(runescape, funescape), match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape), "~=" === match[2] && (match[3] = " " + match[3] + " "), match.slice(0, 4)
              },
              CHILD: function (match) {
                return match[1] = match[1].toLowerCase(), "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]), match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])), match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]), match
              },
              PSEUDO: function (match) {
                var excess, unquoted = !match[6] && match[2];
                return matchExpr.CHILD.test(match[0]) ? null : (match[3] ? match[2] = match[4] || match[5] || "" : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess), match[2] = unquoted.slice(0, excess)), match.slice(0, 3))
              }
            },
            filter: {
              TAG: function (nodeNameSelector) {
                var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                return "*" === nodeNameSelector ? function () {
                  return !0
                } : function (elem) {
                  return elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                }
              },
              CLASS: function (className) {
                var pattern = classCache[className + " "];
                return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
                  return pattern.test("string" == typeof elem.className && elem.className || void 0 !== elem.getAttribute && elem.getAttribute("class") || "")
                })
              },
              ATTR: function (name, operator, check) {
                return function (elem) {
                  var result = Sizzle.attr(elem, name);
                  return null == result ? "!=" === operator : !operator || (result += "", "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && -1 < result.indexOf(check) : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? -1 < (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) : "|=" === operator && (result === check || result.slice(0, check.length + 1) === check + "-"))
                }
              },
              CHILD: function (type, what, argument, first, last) {
                var simple = "nth" !== type.slice(0, 3),
                  forward = "last" !== type.slice(-4),
                  ofType = "of-type" === what;
                return 1 === first && 0 === last ? function (elem) {
                  return !!elem.parentNode
                } : function (elem, context, xml) {
                  var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling",
                    parent = elem.parentNode,
                    name = ofType && elem.nodeName.toLowerCase(),
                    useCache = !xml && !ofType,
                    diff = !1;
                  if (parent) {
                    if (simple) {
                      for (; dir;) {
                        for (node = elem; node = node[dir];)
                          if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType) return !1;
                        start = dir = "only" === type && !start && "nextSibling"
                      }
                      return !0
                    }
                    if (start = [forward ? parent.firstChild : parent.lastChild], forward && useCache) {
                      for (diff = (nodeIndex = (cache = (uniqueCache = (outerCache = (node = parent)[expando] || (node[expando] = {}))[node.uniqueID] || (outerCache[node.uniqueID] = {}))[type] || [])[0] === dirruns && cache[1]) && cache[2], node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop();)
                        if (1 === node.nodeType && ++diff && node === elem) {
                          uniqueCache[type] = [dirruns, nodeIndex, diff];
                          break
                        }
                    } else if (useCache && (diff = nodeIndex = (cache = (uniqueCache = (outerCache = (node = elem)[expando] || (node[expando] = {}))[node.uniqueID] || (outerCache[node.uniqueID] = {}))[type] || [])[0] === dirruns && cache[1]), !1 === diff)
                      for (;
                        (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name : 1 !== node.nodeType) || !++diff || (useCache && ((uniqueCache = (outerCache = node[expando] || (node[expando] = {}))[node.uniqueID] || (outerCache[node.uniqueID] = {}))[type] = [dirruns, diff]), node !== elem)););
                    return (diff -= last) === first || diff % first == 0 && 0 <= diff / first
                  }
                }
              },
              PSEUDO: function (pseudo, argument) {
                var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                return fn[expando] ? fn(argument) : 1 < fn.length ? (args = [pseudo, pseudo, "", argument], Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                  for (var idx, matched = fn(seed, argument), i = matched.length; i--;) seed[idx = indexOf(seed, matched[i])] = !(matches[idx] = matched[i])
                }) : function (elem) {
                  return fn(elem, 0, args)
                }) : fn
              }
            },
            pseudos: {
              not: markFunction(function (selector) {
                var input = [],
                  results = [],
                  matcher = compile(selector.replace(rtrim, "$1"));
                return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                  for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--;)(elem = unmatched[i]) && (seed[i] = !(matches[i] = elem))
                }) : function (elem, context, xml) {
                  return input[0] = elem, matcher(input, null, xml, results), input[0] = null, !results.pop()
                }
              }),
              has: markFunction(function (selector) {
                return function (elem) {
                  return 0 < Sizzle(selector, elem).length
                }
              }),
              contains: markFunction(function (text) {
                return text = text.replace(runescape, funescape),
                  function (elem) {
                    return -1 < (elem.textContent || elem.innerText || getText(elem)).indexOf(text)
                  }
              }),
              lang: markFunction(function (lang) {
                return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang), lang = lang.replace(runescape, funescape).toLowerCase(),
                  function (elem) {
                    var elemLang;
                    do {
                      if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) return (elemLang = elemLang.toLowerCase()) === lang || 0 === elemLang.indexOf(lang + "-")
                    } while ((elem = elem.parentNode) && 1 === elem.nodeType);
                    return !1
                  }
              }),
              target: function (elem) {
                var hash = window.location && window.location.hash;
                return hash && hash.slice(1) === elem.id
              },
              root: function (elem) {
                return elem === docElem
              },
              focus: function (elem) {
                return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex)
              },
              enabled: createDisabledPseudo(!1),
              disabled: createDisabledPseudo(!0),
              checked: function (elem) {
                var nodeName = elem.nodeName.toLowerCase();
                return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected
              },
              selected: function (elem) {
                return elem.parentNode && elem.parentNode.selectedIndex, !0 === elem.selected
              },
              empty: function (elem) {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling)
                  if (elem.nodeType < 6) return !1;
                return !0
              },
              parent: function (elem) {
                return !Expr.pseudos.empty(elem)
              },
              header: function (elem) {
                return rheader.test(elem.nodeName)
              },
              input: function (elem) {
                return rinputs.test(elem.nodeName)
              },
              button: function (elem) {
                var name = elem.nodeName.toLowerCase();
                return "input" === name && "button" === elem.type || "button" === name
              },
              text: function (elem) {
                var attr;
                return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase())
              },
              first: createPositionalPseudo(function () {
                return [0]
              }),
              last: createPositionalPseudo(function (matchIndexes, length) {
                return [length - 1]
              }),
              eq: createPositionalPseudo(function (matchIndexes, length, argument) {
                return [argument < 0 ? argument + length : argument]
              }),
              even: createPositionalPseudo(function (matchIndexes, length) {
                for (var i = 0; i < length; i += 2) matchIndexes.push(i);
                return matchIndexes
              }),
              odd: createPositionalPseudo(function (matchIndexes, length) {
                for (var i = 1; i < length; i += 2) matchIndexes.push(i);
                return matchIndexes
              }),
              lt: createPositionalPseudo(function (matchIndexes, length, argument) {
                for (var i = argument < 0 ? argument + length : argument; 0 <= --i;) matchIndexes.push(i);
                return matchIndexes
              }),
              gt: createPositionalPseudo(function (matchIndexes, length, argument) {
                for (var i = argument < 0 ? argument + length : argument; ++i < length;) matchIndexes.push(i);
                return matchIndexes
              })
            }
          }).pseudos.nth = Expr.pseudos.eq, {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
          }) Expr.pseudos[i] = createInputPseudo(i);
        for (i in {
            submit: !0,
            reset: !0
          }) Expr.pseudos[i] = createButtonPseudo(i);

        function setFilters() {}

        function toSelector(tokens) {
          for (var i = 0, len = tokens.length, selector = ""; i < len; i++) selector += tokens[i].value;
          return selector
        }

        function addCombinator(matcher, combinator, base) {
          var dir = combinator.dir,
            skip = combinator.next,
            key = skip || dir,
            checkNonElements = base && "parentNode" === key,
            doneName = done++;
          return combinator.first ? function (elem, context, xml) {
            for (; elem = elem[dir];)
              if (1 === elem.nodeType || checkNonElements) return matcher(elem, context, xml);
            return !1
          } : function (elem, context, xml) {
            var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
            if (xml) {
              for (; elem = elem[dir];)
                if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml)) return !0
            } else
              for (; elem = elem[dir];)
                if (1 === elem.nodeType || checkNonElements)
                  if (uniqueCache = (outerCache = elem[expando] || (elem[expando] = {}))[elem.uniqueID] || (outerCache[elem.uniqueID] = {}), skip && skip === elem.nodeName.toLowerCase()) elem = elem[dir] || elem;
                  else {
                    if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) return newCache[2] = oldCache[2];
                    if ((uniqueCache[key] = newCache)[2] = matcher(elem, context, xml)) return !0
                  } return !1
          }
        }

        function elementMatcher(matchers) {
          return 1 < matchers.length ? function (elem, context, xml) {
            for (var i = matchers.length; i--;)
              if (!matchers[i](elem, context, xml)) return !1;
            return !0
          } : matchers[0]
        }

        function condense(unmatched, map, filter, context, xml) {
          for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; i < len; i++)(elem = unmatched[i]) && (filter && !filter(elem, context, xml) || (newUnmatched.push(elem), mapped && map.push(i)));
          return newUnmatched
        }

        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)), postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)), markFunction(function (seed, results, context, xml) {
            var temp, i, elem, preMap = [],
              postMap = [],
              preexisting = results.length,
              elems = seed || function (selector, contexts, results) {
                for (var i = 0, len = contexts.length; i < len; i++) Sizzle(selector, contexts[i], results);
                return results
              }(selector || "*", context.nodeType ? [context] : context, []),
              matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml),
              matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
            if (matcher && matcher(matcherIn, matcherOut, context, xml), postFilter)
              for (temp = condense(matcherOut, postMap), postFilter(temp, [], context, xml), i = temp.length; i--;)(elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  for (temp = [], i = matcherOut.length; i--;)(elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
                  postFinder(null, matcherOut = [], temp, xml)
                }
                for (i = matcherOut.length; i--;)(elem = matcherOut[i]) && -1 < (temp = postFinder ? indexOf(seed, elem) : preMap[i]) && (seed[temp] = !(results[temp] = elem))
              }
            } else matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut), postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut)
          })
        }

        function matcherFromTokens(tokens) {
          for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
              return elem === checkContext
            }, implicitRelative, !0), matchAnyContext = addCombinator(function (elem) {
              return -1 < indexOf(checkContext, elem)
            }, implicitRelative, !0), matchers = [function (elem, context, xml) {
              var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
              return checkContext = null, ret
            }]; i < len; i++)
            if (matcher = Expr.relative[tokens[i].type]) matchers = [addCombinator(elementMatcher(matchers), matcher)];
            else {
              if ((matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches))[expando]) {
                for (j = ++i; j < len && !Expr.relative[tokens[j].type]; j++);
                return setMatcher(1 < i && elementMatcher(matchers), 1 < i && toSelector(tokens.slice(0, i - 1).concat({
                  value: " " === tokens[i - 2].type ? "*" : ""
                })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens))
              }
              matchers.push(matcher)
            }
          return elementMatcher(matchers)
        }
        return setFilters.prototype = Expr.filters = Expr.pseudos, Expr.setFilters = new setFilters, tokenize = Sizzle.tokenize = function (selector, parseOnly) {
          var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
          if (cached) return parseOnly ? 0 : cached.slice(0);
          for (soFar = selector, groups = [], preFilters = Expr.preFilter; soFar;) {
            for (type in matched && !(match = rcomma.exec(soFar)) || (match && (soFar = soFar.slice(match[0].length) || soFar), groups.push(tokens = [])), matched = !1, (match = rcombinators.exec(soFar)) && (matched = match.shift(), tokens.push({
                value: matched,
                type: match[0].replace(rtrim, " ")
              }), soFar = soFar.slice(matched.length)), Expr.filter) !(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(), tokens.push({
              value: matched,
              type: type,
              matches: match
            }), soFar = soFar.slice(matched.length));
            if (!matched) break
          }
          return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0)
        }, compile = Sizzle.compile = function (selector, match) {
          var i, setMatchers = [],
            elementMatchers = [],
            cached = compilerCache[selector + " "];
          if (!cached) {
            for (match || (match = tokenize(selector)), i = match.length; i--;)(cached = matcherFromTokens(match[i]))[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
            (cached = compilerCache(selector, function (elementMatchers, setMatchers) {
              var bySet = 0 < setMatchers.length,
                byElement = 0 < elementMatchers.length,
                superMatcher = function (seed, context, xml, results, outermost) {
                  var elem, j, matcher, matchedCount = 0,
                    i = "0",
                    unmatched = seed && [],
                    setMatched = [],
                    contextBackup = outermostContext,
                    elems = seed || byElement && Expr.find.TAG("*", outermost),
                    dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1,
                    len = elems.length;
                  for (outermost && (outermostContext = context === document || context || outermost); i !== len && null != (elem = elems[i]); i++) {
                    if (byElement && elem) {
                      for (j = 0, context || elem.ownerDocument === document || (setDocument(elem), xml = !documentIsHTML); matcher = elementMatchers[j++];)
                        if (matcher(elem, context || document, xml)) {
                          results.push(elem);
                          break
                        }
                      outermost && (dirruns = dirrunsUnique)
                    }
                    bySet && ((elem = !matcher && elem) && matchedCount--, seed && unmatched.push(elem))
                  }
                  if (matchedCount += i, bySet && i !== matchedCount) {
                    for (j = 0; matcher = setMatchers[j++];) matcher(unmatched, setMatched, context, xml);
                    if (seed) {
                      if (0 < matchedCount)
                        for (; i--;) unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                      setMatched = condense(setMatched)
                    }
                    push.apply(results, setMatched), outermost && !seed && 0 < setMatched.length && 1 < matchedCount + setMatchers.length && Sizzle.uniqueSort(results)
                  }
                  return outermost && (dirruns = dirrunsUnique, outermostContext = contextBackup), unmatched
                };
              return bySet ? markFunction(superMatcher) : superMatcher
            }(elementMatchers, setMatchers))).selector = selector
          }
          return cached
        }, select = Sizzle.select = function (selector, context, results, seed) {
          var i, tokens, token, type, find, compiled = "function" == typeof selector && selector,
            match = !seed && tokenize(selector = compiled.selector || selector);
          if (results = results || [], 1 === match.length) {
            if (2 < (tokens = match[0] = match[0].slice(0)).length && "ID" === (token = tokens[0]).type && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
              if (!(context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0])) return results;
              compiled && (context = context.parentNode), selector = selector.slice(tokens.shift().value.length)
            }
            for (i = matchExpr.needsContext.test(selector) ? 0 : tokens.length; i-- && (token = tokens[i], !Expr.relative[type = token.type]);)
              if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                if (tokens.splice(i, 1), !(selector = seed.length && toSelector(tokens))) return push.apply(results, seed), results;
                break
              }
          }
          return (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context), results
        }, support.sortStable = expando.split("").sort(sortOrder).join("") === expando, support.detectDuplicates = !!hasDuplicate, setDocument(), support.sortDetached = assert(function (el) {
          return 1 & el.compareDocumentPosition(document.createElement("fieldset"))
        }), assert(function (el) {
          return el.innerHTML = "<a href='#'></a>", "#" === el.firstChild.getAttribute("href")
        }) || addHandle("type|href|height|width", function (elem, name, isXML) {
          if (!isXML) return elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2)
        }), support.attributes && assert(function (el) {
          return el.innerHTML = "<input/>", el.firstChild.setAttribute("value", ""), "" === el.firstChild.getAttribute("value")
        }) || addHandle("value", function (elem, name, isXML) {
          if (!isXML && "input" === elem.nodeName.toLowerCase()) return elem.defaultValue
        }), assert(function (el) {
          return null == el.getAttribute("disabled")
        }) || addHandle(booleans, function (elem, name, isXML) {
          var val;
          if (!isXML) return !0 === elem[name] ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
        }), Sizzle
      }(window);
      jQuery.find = Sizzle, jQuery.expr = Sizzle.selectors, jQuery.expr[":"] = jQuery.expr.pseudos, jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort, jQuery.text = Sizzle.getText, jQuery.isXMLDoc = Sizzle.isXML, jQuery.contains = Sizzle.contains, jQuery.escapeSelector = Sizzle.escape;
      var dir = function (elem, dir, until) {
          for (var matched = [], truncate = void 0 !== until;
            (elem = elem[dir]) && 9 !== elem.nodeType;)
            if (1 === elem.nodeType) {
              if (truncate && jQuery(elem).is(until)) break;
              matched.push(elem)
            }
          return matched
        },
        siblings = function (n, elem) {
          for (var matched = []; n; n = n.nextSibling) 1 === n.nodeType && n !== elem && matched.push(n);
          return matched
        },
        rneedsContext = jQuery.expr.match.needsContext;

      function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()
      }
      var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

      function winnow(elements, qualifier, not) {
        return isFunction(qualifier) ? jQuery.grep(elements, function (elem, i) {
          return !!qualifier.call(elem, i, elem) !== not
        }) : qualifier.nodeType ? jQuery.grep(elements, function (elem) {
          return elem === qualifier !== not
        }) : "string" != typeof qualifier ? jQuery.grep(elements, function (elem) {
          return -1 < indexOf.call(qualifier, elem) !== not
        }) : jQuery.filter(qualifier, elements, not)
      }
      jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];
        return not && (expr = ":not(" + expr + ")"), 1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
          return 1 === elem.nodeType
        }))
      }, jQuery.fn.extend({
        find: function (selector) {
          var i, ret, len = this.length,
            self = this;
          if ("string" != typeof selector) return this.pushStack(jQuery(selector).filter(function () {
            for (i = 0; i < len; i++)
              if (jQuery.contains(self[i], this)) return !0
          }));
          for (ret = this.pushStack([]), i = 0; i < len; i++) jQuery.find(selector, self[i], ret);
          return 1 < len ? jQuery.uniqueSort(ret) : ret
        },
        filter: function (selector) {
          return this.pushStack(winnow(this, selector || [], !1))
        },
        not: function (selector) {
          return this.pushStack(winnow(this, selector || [], !0))
        },
        is: function (selector) {
          return !!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) : selector || [], !1).length
        }
      });
      var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
      (jQuery.fn.init = function (selector, context, root) {
        var match, elem;
        if (!selector) return this;
        if (root = root || rootjQuery, "string" == typeof selector) {
          if (!(match = "<" === selector[0] && ">" === selector[selector.length - 1] && 3 <= selector.length ? [null, selector, null] : rquickExpr.exec(selector)) || !match[1] && context) return !context || context.jquery ? (context || root).find(selector) : this.constructor(context).find(selector);
          if (match[1]) {
            if (context = context instanceof jQuery ? context[0] : context, jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, !0)), rsingleTag.test(match[1]) && jQuery.isPlainObject(context))
              for (match in context) isFunction(this[match]) ? this[match](context[match]) : this.attr(match, context[match]);
            return this
          }
          return (elem = document.getElementById(match[2])) && (this[0] = elem, this.length = 1), this
        }
        return selector.nodeType ? (this[0] = selector, this.length = 1, this) : isFunction(selector) ? void 0 !== root.ready ? root.ready(selector) : selector(jQuery) : jQuery.makeArray(selector, this)
      }).prototype = jQuery.fn, rootjQuery = jQuery(document);
      var rparentsprev = /^(?:parents|prev(?:Until|All))/,
        guaranteedUnique = {
          children: !0,
          contents: !0,
          next: !0,
          prev: !0
        };

      function sibling(cur, dir) {
        for (;
          (cur = cur[dir]) && 1 !== cur.nodeType;);
        return cur
      }
      jQuery.fn.extend({
        has: function (target) {
          var targets = jQuery(target, this),
            l = targets.length;
          return this.filter(function () {
            for (var i = 0; i < l; i++)
              if (jQuery.contains(this, targets[i])) return !0
          })
        },
        closest: function (selectors, context) {
          var cur, i = 0,
            l = this.length,
            matched = [],
            targets = "string" != typeof selectors && jQuery(selectors);
          if (!rneedsContext.test(selectors))
            for (; i < l; i++)
              for (cur = this[i]; cur && cur !== context; cur = cur.parentNode)
                if (cur.nodeType < 11 && (targets ? -1 < targets.index(cur) : 1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
                  matched.push(cur);
                  break
                }
          return this.pushStack(1 < matched.length ? jQuery.uniqueSort(matched) : matched)
        },
        index: function (elem) {
          return elem ? "string" == typeof elem ? indexOf.call(jQuery(elem), this[0]) : indexOf.call(this, elem.jquery ? elem[0] : elem) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        },
        add: function (selector, context) {
          return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))))
        },
        addBack: function (selector) {
          return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector))
        }
      }), jQuery.each({
        parent: function (elem) {
          var parent = elem.parentNode;
          return parent && 11 !== parent.nodeType ? parent : null
        },
        parents: function (elem) {
          return dir(elem, "parentNode")
        },
        parentsUntil: function (elem, i, until) {
          return dir(elem, "parentNode", until)
        },
        next: function (elem) {
          return sibling(elem, "nextSibling")
        },
        prev: function (elem) {
          return sibling(elem, "previousSibling")
        },
        nextAll: function (elem) {
          return dir(elem, "nextSibling")
        },
        prevAll: function (elem) {
          return dir(elem, "previousSibling")
        },
        nextUntil: function (elem, i, until) {
          return dir(elem, "nextSibling", until)
        },
        prevUntil: function (elem, i, until) {
          return dir(elem, "previousSibling", until)
        },
        siblings: function (elem) {
          return siblings((elem.parentNode || {}).firstChild, elem)
        },
        children: function (elem) {
          return siblings(elem.firstChild)
        },
        contents: function (elem) {
          return nodeName(elem, "iframe") ? elem.contentDocument : (nodeName(elem, "template") && (elem = elem.content || elem), jQuery.merge([], elem.childNodes))
        }
      }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
          var matched = jQuery.map(this, fn, until);
          return "Until" !== name.slice(-5) && (selector = until), selector && "string" == typeof selector && (matched = jQuery.filter(selector, matched)), 1 < this.length && (guaranteedUnique[name] || jQuery.uniqueSort(matched), rparentsprev.test(name) && matched.reverse()), this.pushStack(matched)
        }
      });
      var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;

      function Identity(v) {
        return v
      }

      function Thrower(ex) {
        throw ex
      }

      function adoptValue(value, resolve, reject, noValue) {
        var method;
        try {
          value && isFunction(method = value.promise) ? method.call(value).done(resolve).fail(reject) : value && isFunction(method = value.then) ? method.call(value, resolve, reject) : resolve.apply(void 0, [value].slice(noValue))
        } catch (value) {
          reject.apply(void 0, [value])
        }
      }
      jQuery.Callbacks = function (options) {
        options = "string" == typeof options ? function (options) {
          var object = {};
          return jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
            object[flag] = !0
          }), object
        }(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [],
          queue = [],
          firingIndex = -1,
          fire = function () {
            for (locked = locked || options.once, fired = firing = !0; queue.length; firingIndex = -1)
              for (memory = queue.shift(); ++firingIndex < list.length;) !1 === list[firingIndex].apply(memory[0], memory[1]) && options.stopOnFalse && (firingIndex = list.length, memory = !1);
            options.memory || (memory = !1), firing = !1, locked && (list = memory ? [] : "")
          },
          self = {
            add: function () {
              return list && (memory && !firing && (firingIndex = list.length - 1, queue.push(memory)), function add(args) {
                jQuery.each(args, function (_, arg) {
                  isFunction(arg) ? options.unique && self.has(arg) || list.push(arg) : arg && arg.length && "string" !== toType(arg) && add(arg)
                })
              }(arguments), memory && !firing && fire()), this
            },
            remove: function () {
              return jQuery.each(arguments, function (_, arg) {
                for (var index; - 1 < (index = jQuery.inArray(arg, list, index));) list.splice(index, 1), index <= firingIndex && firingIndex--
              }), this
            },
            has: function (fn) {
              return fn ? -1 < jQuery.inArray(fn, list) : 0 < list.length
            },
            empty: function () {
              return list && (list = []), this
            },
            disable: function () {
              return locked = queue = [], list = memory = "", this
            },
            disabled: function () {
              return !list
            },
            lock: function () {
              return locked = queue = [], memory || firing || (list = memory = ""), this
            },
            locked: function () {
              return !!locked
            },
            fireWith: function (context, args) {
              return locked || (args = [context, (args = args || []).slice ? args.slice() : args], queue.push(args), firing || fire()), this
            },
            fire: function () {
              return self.fireWith(this, arguments), this
            },
            fired: function () {
              return !!fired
            }
          };
        return self
      }, jQuery.extend({
        Deferred: function (func) {
          var tuples = [
              ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2],
              ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"],
              ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]
            ],
            state = "pending",
            promise = {
              state: function () {
                return state
              },
              always: function () {
                return deferred.done(arguments).fail(arguments), this
              },
              catch: function (fn) {
                return promise.then(null, fn)
              },
              pipe: function () {
                var fns = arguments;
                return jQuery.Deferred(function (newDefer) {
                  jQuery.each(tuples, function (i, tuple) {
                    var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                    deferred[tuple[1]](function () {
                      var returned = fn && fn.apply(this, arguments);
                      returned && isFunction(returned.promise) ? returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject) : newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments)
                    })
                  }), fns = null
                }).promise()
              },
              then: function (onFulfilled, onRejected, onProgress) {
                var maxDepth = 0;

                function resolve(depth, deferred, handler, special) {
                  return function () {
                    var that = this,
                      args = arguments,
                      mightThrow = function () {
                        var returned, then;
                        if (!(depth < maxDepth)) {
                          if ((returned = handler.apply(that, args)) === deferred.promise()) throw new TypeError("Thenable self-resolution");
                          then = returned && ("object" == typeof returned || "function" == typeof returned) && returned.then, isFunction(then) ? special ? then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)) : (maxDepth++, then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith))) : (handler !== Identity && (that = void 0, args = [returned]), (special || deferred.resolveWith)(that, args))
                        }
                      },
                      process = special ? mightThrow : function () {
                        try {
                          mightThrow()
                        } catch (e) {
                          jQuery.Deferred.exceptionHook && jQuery.Deferred.exceptionHook(e, process.stackTrace), maxDepth <= depth + 1 && (handler !== Thrower && (that = void 0, args = [e]), deferred.rejectWith(that, args))
                        }
                      };
                    depth ? process() : (jQuery.Deferred.getStackHook && (process.stackTrace = jQuery.Deferred.getStackHook()), window.setTimeout(process))
                  }
                }
                return jQuery.Deferred(function (newDefer) {
                  tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)), tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)), tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower))
                }).promise()
              },
              promise: function (obj) {
                return null != obj ? jQuery.extend(obj, promise) : promise
              }
            },
            deferred = {};
          return jQuery.each(tuples, function (i, tuple) {
            var list = tuple[2],
              stateString = tuple[5];
            promise[tuple[1]] = list.add, stateString && list.add(function () {
              state = stateString
            }, tuples[3 - i][2].disable, tuples[3 - i][3].disable, tuples[0][2].lock, tuples[0][3].lock), list.add(tuple[3].fire), deferred[tuple[0]] = function () {
              return deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments), this
            }, deferred[tuple[0] + "With"] = list.fireWith
          }), promise.promise(deferred), func && func.call(deferred, deferred), deferred
        },
        when: function (singleValue) {
          var remaining = arguments.length,
            i = remaining,
            resolveContexts = Array(i),
            resolveValues = slice.call(arguments),
            master = jQuery.Deferred(),
            updateFunc = function (i) {
              return function (value) {
                resolveContexts[i] = this, resolveValues[i] = 1 < arguments.length ? slice.call(arguments) : value, --remaining || master.resolveWith(resolveContexts, resolveValues)
              }
            };
          if (remaining <= 1 && (adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining), "pending" === master.state() || isFunction(resolveValues[i] && resolveValues[i].then))) return master.then();
          for (; i--;) adoptValue(resolveValues[i], updateFunc(i), master.reject);
          return master.promise()
        }
      });
      var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
      jQuery.Deferred.exceptionHook = function (error, stack) {
        window.console && window.console.warn && error && rerrorNames.test(error.name) && window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack)
      }, jQuery.readyException = function (error) {
        window.setTimeout(function () {
          throw error
        })
      };
      var readyList = jQuery.Deferred();

      function completed() {
        document.removeEventListener("DOMContentLoaded", completed), window.removeEventListener("load", completed), jQuery.ready()
      }
      jQuery.fn.ready = function (fn) {
        return readyList.then(fn).catch(function (error) {
          jQuery.readyException(error)
        }), this
      }, jQuery.extend({
        isReady: !1,
        readyWait: 1,
        ready: function (wait) {
          (!0 === wait ? --jQuery.readyWait : jQuery.isReady) || (jQuery.isReady = !0) !== wait && 0 < --jQuery.readyWait || readyList.resolveWith(document, [jQuery])
        }
      }), jQuery.ready.then = readyList.then, "complete" === document.readyState || "loading" !== document.readyState && !document.documentElement.doScroll ? window.setTimeout(jQuery.ready) : (document.addEventListener("DOMContentLoaded", completed), window.addEventListener("load", completed));
      var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
          var i = 0,
            len = elems.length,
            bulk = null == key;
          if ("object" === toType(key))
            for (i in chainable = !0, key) access(elems, fn, i, key[i], !0, emptyGet, raw);
          else if (void 0 !== value && (chainable = !0, isFunction(value) || (raw = !0), bulk && (raw ? (fn.call(elems, value), fn = null) : (bulk = fn, fn = function (elem, key, value) {
              return bulk.call(jQuery(elem), value)
            })), fn))
            for (; i < len; i++) fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
          return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet
        },
        rmsPrefix = /^-ms-/,
        rdashAlpha = /-([a-z])/g;

      function fcamelCase(all, letter) {
        return letter.toUpperCase()
      }

      function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase)
      }
      var acceptData = function (owner) {
        return 1 === owner.nodeType || 9 === owner.nodeType || !+owner.nodeType
      };

      function Data() {
        this.expando = jQuery.expando + Data.uid++
      }
      Data.uid = 1, Data.prototype = {
        cache: function (owner) {
          var value = owner[this.expando];
          return value || (value = {}, acceptData(owner) && (owner.nodeType ? owner[this.expando] = value : Object.defineProperty(owner, this.expando, {
            value: value,
            configurable: !0
          }))), value
        },
        set: function (owner, data, value) {
          var prop, cache = this.cache(owner);
          if ("string" == typeof data) cache[camelCase(data)] = value;
          else
            for (prop in data) cache[camelCase(prop)] = data[prop];
          return cache
        },
        get: function (owner, key) {
          return void 0 === key ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)]
        },
        access: function (owner, key, value) {
          return void 0 === key || key && "string" == typeof key && void 0 === value ? this.get(owner, key) : (this.set(owner, key, value), void 0 !== value ? value : key)
        },
        remove: function (owner, key) {
          var i, cache = owner[this.expando];
          if (void 0 !== cache) {
            if (void 0 !== key) {
              i = (key = Array.isArray(key) ? key.map(camelCase) : (key = camelCase(key)) in cache ? [key] : key.match(rnothtmlwhite) || []).length;
              for (; i--;) delete cache[key[i]]
            }(void 0 === key || jQuery.isEmptyObject(cache)) && (owner.nodeType ? owner[this.expando] = void 0 : delete owner[this.expando])
          }
        },
        hasData: function (owner) {
          var cache = owner[this.expando];
          return void 0 !== cache && !jQuery.isEmptyObject(cache)
        }
      };
      var dataPriv = new Data,
        dataUser = new Data,
        rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /[A-Z]/g;

      function dataAttr(elem, key, data) {
        var name;
        if (void 0 === data && 1 === elem.nodeType)
          if (name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase(), "string" == typeof (data = elem.getAttribute(name))) {
            try {
              data = function (data) {
                return "true" === data || "false" !== data && ("null" === data ? null : data === +data + "" ? +data : rbrace.test(data) ? JSON.parse(data) : data)
              }(data)
            } catch (e) {}
            dataUser.set(elem, key, data)
          } else data = void 0;
        return data
      }
      jQuery.extend({
        hasData: function (elem) {
          return dataUser.hasData(elem) || dataPriv.hasData(elem)
        },
        data: function (elem, name, data) {
          return dataUser.access(elem, name, data)
        },
        removeData: function (elem, name) {
          dataUser.remove(elem, name)
        },
        _data: function (elem, name, data) {
          return dataPriv.access(elem, name, data)
        },
        _removeData: function (elem, name) {
          dataPriv.remove(elem, name)
        }
      }), jQuery.fn.extend({
        data: function (key, value) {
          var i, name, data, elem = this[0],
            attrs = elem && elem.attributes;
          if (void 0 === key) {
            if (this.length && (data = dataUser.get(elem), 1 === elem.nodeType && !dataPriv.get(elem, "hasDataAttrs"))) {
              for (i = attrs.length; i--;) attrs[i] && 0 === (name = attrs[i].name).indexOf("data-") && (name = camelCase(name.slice(5)), dataAttr(elem, name, data[name]));
              dataPriv.set(elem, "hasDataAttrs", !0)
            }
            return data
          }
          return "object" == typeof key ? this.each(function () {
            dataUser.set(this, key)
          }) : access(this, function (value) {
            var data;
            if (elem && void 0 === value) return void 0 !== (data = dataUser.get(elem, key)) ? data : void 0 !== (data = dataAttr(elem, key)) ? data : void 0;
            this.each(function () {
              dataUser.set(this, key, value)
            })
          }, null, value, 1 < arguments.length, null, !0)
        },
        removeData: function (key) {
          return this.each(function () {
            dataUser.remove(this, key)
          })
        }
      }), jQuery.extend({
        queue: function (elem, type, data) {
          var queue;
          if (elem) return type = (type || "fx") + "queue", queue = dataPriv.get(elem, type), data && (!queue || Array.isArray(data) ? queue = dataPriv.access(elem, type, jQuery.makeArray(data)) : queue.push(data)), queue || []
        },
        dequeue: function (elem, type) {
          type = type || "fx";
          var queue = jQuery.queue(elem, type),
            startLength = queue.length,
            fn = queue.shift(),
            hooks = jQuery._queueHooks(elem, type);
          "inprogress" === fn && (fn = queue.shift(), startLength--), fn && ("fx" === type && queue.unshift("inprogress"), delete hooks.stop, fn.call(elem, function () {
            jQuery.dequeue(elem, type)
          }, hooks)), !startLength && hooks && hooks.empty.fire()
        },
        _queueHooks: function (elem, type) {
          var key = type + "queueHooks";
          return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
            empty: jQuery.Callbacks("once memory").add(function () {
              dataPriv.remove(elem, [type + "queue", key])
            })
          })
        }
      }), jQuery.fn.extend({
        queue: function (type, data) {
          var setter = 2;
          return "string" != typeof type && (data = type, type = "fx", setter--), arguments.length < setter ? jQuery.queue(this[0], type) : void 0 === data ? this : this.each(function () {
            var queue = jQuery.queue(this, type, data);
            jQuery._queueHooks(this, type), "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type)
          })
        },
        dequeue: function (type) {
          return this.each(function () {
            jQuery.dequeue(this, type)
          })
        },
        clearQueue: function (type) {
          return this.queue(type || "fx", [])
        },
        promise: function (type, obj) {
          var tmp, count = 1,
            defer = jQuery.Deferred(),
            elements = this,
            i = this.length,
            resolve = function () {
              --count || defer.resolveWith(elements, [elements])
            };
          for ("string" != typeof type && (obj = type, type = void 0), type = type || "fx"; i--;)(tmp = dataPriv.get(elements[i], type + "queueHooks")) && tmp.empty && (count++, tmp.empty.add(resolve));
          return resolve(), defer.promise(obj)
        }
      });
      var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
        rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
        cssExpand = ["Top", "Right", "Bottom", "Left"],
        isHiddenWithinTree = function (elem, el) {
          return "none" === (elem = el || elem).style.display || "" === elem.style.display && jQuery.contains(elem.ownerDocument, elem) && "none" === jQuery.css(elem, "display")
        },
        swap = function (elem, options, callback, args) {
          var ret, name, old = {};
          for (name in options) old[name] = elem.style[name], elem.style[name] = options[name];
          for (name in ret = callback.apply(elem, args || []), options) elem.style[name] = old[name];
          return ret
        };

      function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale, maxIterations = 20,
          currentValue = tween ? function () {
            return tween.cur()
          } : function () {
            return jQuery.css(elem, prop, "")
          },
          initial = currentValue(),
          unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
          initialInUnit = (jQuery.cssNumber[prop] || "px" !== unit && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
          for (initial /= 2, unit = unit || initialInUnit[3], initialInUnit = +initial || 1; maxIterations--;) jQuery.style(elem, prop, initialInUnit + unit), (1 - scale) * (1 - (scale = currentValue() / initial || .5)) <= 0 && (maxIterations = 0), initialInUnit /= scale;
          initialInUnit *= 2, jQuery.style(elem, prop, initialInUnit + unit), valueParts = valueParts || []
        }
        return valueParts && (initialInUnit = +initialInUnit || +initial || 0, adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2], tween && (tween.unit = unit, tween.start = initialInUnit, tween.end = adjusted)), adjusted
      }
      var defaultDisplayMap = {};

      function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument,
          nodeName = elem.nodeName,
          display = defaultDisplayMap[nodeName];
        return display || (temp = doc.body.appendChild(doc.createElement(nodeName)), display = jQuery.css(temp, "display"), temp.parentNode.removeChild(temp), "none" === display && (display = "block"), defaultDisplayMap[nodeName] = display)
      }

      function showHide(elements, show) {
        for (var display, elem, values = [], index = 0, length = elements.length; index < length; index++)(elem = elements[index]).style && (display = elem.style.display, show ? ("none" === display && (values[index] = dataPriv.get(elem, "display") || null, values[index] || (elem.style.display = "")), "" === elem.style.display && isHiddenWithinTree(elem) && (values[index] = getDefaultDisplay(elem))) : "none" !== display && (values[index] = "none", dataPriv.set(elem, "display", display)));
        for (index = 0; index < length; index++) null != values[index] && (elements[index].style.display = values[index]);
        return elements
      }
      jQuery.fn.extend({
        show: function () {
          return showHide(this, !0)
        },
        hide: function () {
          return showHide(this)
        },
        toggle: function (state) {
          return "boolean" == typeof state ? state ? this.show() : this.hide() : this.each(function () {
            isHiddenWithinTree(this) ? jQuery(this).show() : jQuery(this).hide()
          })
        }
      });
      var rcheckableType = /^(?:checkbox|radio)$/i,
        rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i,
        rscriptType = /^$|^module$|\/(?:java|ecma)script/i,
        wrapMap = {
          option: [1, "<select multiple='multiple'>", "</select>"],
          thead: [1, "<table>", "</table>"],
          col: [2, "<table><colgroup>", "</colgroup></table>"],
          tr: [2, "<table><tbody>", "</tbody></table>"],
          td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
          _default: [0, "", ""]
        };

      function getAll(context, tag) {
        var ret;
        return ret = void 0 !== context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : void 0 !== context.querySelectorAll ? context.querySelectorAll(tag || "*") : [], void 0 === tag || tag && nodeName(context, tag) ? jQuery.merge([context], ret) : ret
      }

      function setGlobalEval(elems, refElements) {
        for (var i = 0, l = elems.length; i < l; i++) dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"))
      }
      wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, wrapMap.th = wrapMap.td;
      var div, input, rhtml = /<|&#?\w+;/;

      function buildFragment(elems, context, scripts, selection, ignored) {
        for (var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length; i < l; i++)
          if ((elem = elems[i]) || 0 === elem)
            if ("object" === toType(elem)) jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
            else if (rhtml.test(elem)) {
          for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(), wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2], j = wrap[0]; j--;) tmp = tmp.lastChild;
          jQuery.merge(nodes, tmp.childNodes), (tmp = fragment.firstChild).textContent = ""
        } else nodes.push(context.createTextNode(elem));
        for (fragment.textContent = "", i = 0; elem = nodes[i++];)
          if (selection && -1 < jQuery.inArray(elem, selection)) ignored && ignored.push(elem);
          else if (contains = jQuery.contains(elem.ownerDocument, elem), tmp = getAll(fragment.appendChild(elem), "script"), contains && setGlobalEval(tmp), scripts)
          for (j = 0; elem = tmp[j++];) rscriptType.test(elem.type || "") && scripts.push(elem);
        return fragment
      }
      div = document.createDocumentFragment().appendChild(document.createElement("div")), (input = document.createElement("input")).setAttribute("type", "radio"), input.setAttribute("checked", "checked"), input.setAttribute("name", "t"), div.appendChild(input), support.checkClone = div.cloneNode(!0).cloneNode(!0).lastChild.checked, div.innerHTML = "<textarea>x</textarea>", support.noCloneChecked = !!div.cloneNode(!0).lastChild.defaultValue;
      var documentElement = document.documentElement,
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

      function returnTrue() {
        return !0
      }

      function returnFalse() {
        return !1
      }

      function safeActiveElement() {
        try {
          return document.activeElement
        } catch (err) {}
      }

      function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        if ("object" == typeof types) {
          for (type in "string" != typeof selector && (data = data || selector, selector = void 0), types) on(elem, type, selector, data, types[type], one);
          return elem
        }
        if (null == data && null == fn ? (fn = selector, data = selector = void 0) : null == fn && ("string" == typeof selector ? (fn = data, data = void 0) : (fn = data, data = selector, selector = void 0)), !1 === fn) fn = returnFalse;
        else if (!fn) return elem;
        return 1 === one && (origFn = fn, (fn = function (event) {
          return jQuery().off(event), origFn.apply(this, arguments)
        }).guid = origFn.guid || (origFn.guid = jQuery.guid++)), elem.each(function () {
          jQuery.event.add(this, types, fn, data, selector)
        })
      }
      jQuery.event = {
        global: {},
        add: function (elem, types, handler, data, selector) {
          var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
          if (elemData)
            for (handler.handler && (handler = (handleObjIn = handler).handler, selector = handleObjIn.selector), selector && jQuery.find.matchesSelector(documentElement, selector), handler.guid || (handler.guid = jQuery.guid++), (events = elemData.events) || (events = elemData.events = {}), (eventHandle = elemData.handle) || (eventHandle = elemData.handle = function (e) {
                return void 0 !== jQuery && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0
              }), t = (types = (types || "").match(rnothtmlwhite) || [""]).length; t--;) type = origType = (tmp = rtypenamespace.exec(types[t]) || [])[1], namespaces = (tmp[2] || "").split(".").sort(), type && (special = jQuery.event.special[type] || {}, type = (selector ? special.delegateType : special.bindType) || type, special = jQuery.event.special[type] || {}, handleObj = jQuery.extend({
              type: type,
              origType: origType,
              data: data,
              handler: handler,
              guid: handler.guid,
              selector: selector,
              needsContext: selector && jQuery.expr.match.needsContext.test(selector),
              namespace: namespaces.join(".")
            }, handleObjIn), (handlers = events[type]) || ((handlers = events[type] = []).delegateCount = 0, special.setup && !1 !== special.setup.call(elem, data, namespaces, eventHandle) || elem.addEventListener && elem.addEventListener(type, eventHandle)), special.add && (special.add.call(elem, handleObj), handleObj.handler.guid || (handleObj.handler.guid = handler.guid)), selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) : handlers.push(handleObj), jQuery.event.global[type] = !0)
        },
        remove: function (elem, types, handler, selector, mappedTypes) {
          var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
          if (elemData && (events = elemData.events)) {
            for (t = (types = (types || "").match(rnothtmlwhite) || [""]).length; t--;)
              if (type = origType = (tmp = rtypenamespace.exec(types[t]) || [])[1], namespaces = (tmp[2] || "").split(".").sort(), type) {
                for (special = jQuery.event.special[type] || {}, handlers = events[type = (selector ? special.delegateType : special.bindType) || type] || [], tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"), origCount = j = handlers.length; j--;) handleObj = handlers[j], !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1), handleObj.selector && handlers.delegateCount--, special.remove && special.remove.call(elem, handleObj));
                origCount && !handlers.length && (special.teardown && !1 !== special.teardown.call(elem, namespaces, elemData.handle) || jQuery.removeEvent(elem, type, elemData.handle), delete events[type])
              } else
                for (type in events) jQuery.event.remove(elem, type + types[t], handler, selector, !0);
            jQuery.isEmptyObject(events) && dataPriv.remove(elem, "handle events")
          }
        },
        dispatch: function (nativeEvent) {
          var i, j, ret, matched, handleObj, handlerQueue, event = jQuery.event.fix(nativeEvent),
            args = new Array(arguments.length),
            handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
            special = jQuery.event.special[event.type] || {};
          for (args[0] = event, i = 1; i < arguments.length; i++) args[i] = arguments[i];
          if (event.delegateTarget = this, !special.preDispatch || !1 !== special.preDispatch.call(this, event)) {
            for (handlerQueue = jQuery.event.handlers.call(this, event, handlers), i = 0;
              (matched = handlerQueue[i++]) && !event.isPropagationStopped();)
              for (event.currentTarget = matched.elem, j = 0;
                (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped();) event.rnamespace && !event.rnamespace.test(handleObj.namespace) || (event.handleObj = handleObj, event.data = handleObj.data, void 0 !== (ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args)) && !1 === (event.result = ret) && (event.preventDefault(), event.stopPropagation()));
            return special.postDispatch && special.postDispatch.call(this, event), event.result
          }
        },
        handlers: function (event, handlers) {
          var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [],
            delegateCount = handlers.delegateCount,
            cur = event.target;
          if (delegateCount && cur.nodeType && !("click" === event.type && 1 <= event.button))
            for (; cur !== this; cur = cur.parentNode || this)
              if (1 === cur.nodeType && ("click" !== event.type || !0 !== cur.disabled)) {
                for (matchedHandlers = [], matchedSelectors = {}, i = 0; i < delegateCount; i++) void 0 === matchedSelectors[sel = (handleObj = handlers[i]).selector + " "] && (matchedSelectors[sel] = handleObj.needsContext ? -1 < jQuery(sel, this).index(cur) : jQuery.find(sel, this, null, [cur]).length), matchedSelectors[sel] && matchedHandlers.push(handleObj);
                matchedHandlers.length && handlerQueue.push({
                  elem: cur,
                  handlers: matchedHandlers
                })
              }
          return cur = this, delegateCount < handlers.length && handlerQueue.push({
            elem: cur,
            handlers: handlers.slice(delegateCount)
          }), handlerQueue
        },
        addProp: function (name, hook) {
          Object.defineProperty(jQuery.Event.prototype, name, {
            enumerable: !0,
            configurable: !0,
            get: isFunction(hook) ? function () {
              if (this.originalEvent) return hook(this.originalEvent)
            } : function () {
              if (this.originalEvent) return this.originalEvent[name]
            },
            set: function (value) {
              Object.defineProperty(this, name, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: value
              })
            }
          })
        },
        fix: function (originalEvent) {
          return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent)
        },
        special: {
          load: {
            noBubble: !0
          },
          focus: {
            trigger: function () {
              if (this !== safeActiveElement() && this.focus) return this.focus(), !1
            },
            delegateType: "focusin"
          },
          blur: {
            trigger: function () {
              if (this === safeActiveElement() && this.blur) return this.blur(), !1
            },
            delegateType: "focusout"
          },
          click: {
            trigger: function () {
              if ("checkbox" === this.type && this.click && nodeName(this, "input")) return this.click(), !1
            },
            _default: function (event) {
              return nodeName(event.target, "a")
            }
          },
          beforeunload: {
            postDispatch: function (event) {
              void 0 !== event.result && event.originalEvent && (event.originalEvent.returnValue = event.result)
            }
          }
        }
      }, jQuery.removeEvent = function (elem, type, handle) {
        elem.removeEventListener && elem.removeEventListener(type, handle)
      }, jQuery.Event = function (src, props) {
        if (!(this instanceof jQuery.Event)) return new jQuery.Event(src, props);
        src && src.type ? (this.originalEvent = src, this.type = src.type, this.isDefaultPrevented = src.defaultPrevented || void 0 === src.defaultPrevented && !1 === src.returnValue ? returnTrue : returnFalse, this.target = src.target && 3 === src.target.nodeType ? src.target.parentNode : src.target, this.currentTarget = src.currentTarget, this.relatedTarget = src.relatedTarget) : this.type = src, props && jQuery.extend(this, props), this.timeStamp = src && src.timeStamp || Date.now(), this[jQuery.expando] = !0
      }, jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: !1,
        preventDefault: function () {
          var e = this.originalEvent;
          this.isDefaultPrevented = returnTrue, e && !this.isSimulated && e.preventDefault()
        },
        stopPropagation: function () {
          var e = this.originalEvent;
          this.isPropagationStopped = returnTrue, e && !this.isSimulated && e.stopPropagation()
        },
        stopImmediatePropagation: function () {
          var e = this.originalEvent;
          this.isImmediatePropagationStopped = returnTrue, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
        }
      }, jQuery.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        char: !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: function (event) {
          var button = event.button;
          return null == event.which && rkeyEvent.test(event.type) ? null != event.charCode ? event.charCode : event.keyCode : !event.which && void 0 !== button && rmouseEvent.test(event.type) ? 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0 : event.which
        }
      }, jQuery.event.addProp), jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function (orig, fix) {
        jQuery.event.special[orig] = {
          delegateType: fix,
          bindType: fix,
          handle: function (event) {
            var ret, related = event.relatedTarget,
              handleObj = event.handleObj;
            return related && (related === this || jQuery.contains(this, related)) || (event.type = handleObj.origType, ret = handleObj.handler.apply(this, arguments), event.type = fix), ret
          }
        }
      }), jQuery.fn.extend({
        on: function (types, selector, data, fn) {
          return on(this, types, selector, data, fn)
        },
        one: function (types, selector, data, fn) {
          return on(this, types, selector, data, fn, 1)
        },
        off: function (types, selector, fn) {
          var handleObj, type;
          if (types && types.preventDefault && types.handleObj) return handleObj = types.handleObj, jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler), this;
          if ("object" == typeof types) {
            for (type in types) this.off(type, selector, types[type]);
            return this
          }
          return !1 !== selector && "function" != typeof selector || (fn = selector, selector = void 0), !1 === fn && (fn = returnFalse), this.each(function () {
            jQuery.event.remove(this, types, fn, selector)
          })
        }
      });
      var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
        rnoInnerhtml = /<script|<style|<link/i,
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

      function manipulationTarget(elem, content) {
        return nodeName(elem, "table") && nodeName(11 !== content.nodeType ? content : content.firstChild, "tr") && jQuery(elem).children("tbody")[0] || elem
      }

      function disableScript(elem) {
        return elem.type = (null !== elem.getAttribute("type")) + "/" + elem.type, elem
      }

      function restoreScript(elem) {
        return "true/" === (elem.type || "").slice(0, 5) ? elem.type = elem.type.slice(5) : elem.removeAttribute("type"), elem
      }

      function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (1 === dest.nodeType) {
          if (dataPriv.hasData(src) && (pdataOld = dataPriv.access(src), pdataCur = dataPriv.set(dest, pdataOld), events = pdataOld.events))
            for (type in delete pdataCur.handle, pdataCur.events = {}, events)
              for (i = 0, l = events[type].length; i < l; i++) jQuery.event.add(dest, type, events[type][i]);
          dataUser.hasData(src) && (udataOld = dataUser.access(src), udataCur = jQuery.extend({}, udataOld), dataUser.set(dest, udataCur))
        }
      }

      function domManip(collection, args, callback, ignored) {
        args = concat.apply([], args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0,
          l = collection.length,
          iNoClone = l - 1,
          value = args[0],
          valueIsFunction = isFunction(value);
        if (valueIsFunction || 1 < l && "string" == typeof value && !support.checkClone && rchecked.test(value)) return collection.each(function (index) {
          var self = collection.eq(index);
          valueIsFunction && (args[0] = value.call(this, index, self.html())), domManip(self, args, callback, ignored)
        });
        if (l && (first = (fragment = buildFragment(args, collection[0].ownerDocument, !1, collection, ignored)).firstChild, 1 === fragment.childNodes.length && (fragment = first), first || ignored)) {
          for (hasScripts = (scripts = jQuery.map(getAll(fragment, "script"), disableScript)).length; i < l; i++) node = fragment, i !== iNoClone && (node = jQuery.clone(node, !0, !0), hasScripts && jQuery.merge(scripts, getAll(node, "script"))), callback.call(collection[i], node, i);
          if (hasScripts)
            for (doc = scripts[scripts.length - 1].ownerDocument, jQuery.map(scripts, restoreScript), i = 0; i < hasScripts; i++) node = scripts[i], rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node) && (node.src && "module" !== (node.type || "").toLowerCase() ? jQuery._evalUrl && jQuery._evalUrl(node.src) : DOMEval(node.textContent.replace(rcleanScript, ""), doc, node))
        }
        return collection
      }

      function remove(elem, selector, keepData) {
        for (var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0; null != (node = nodes[i]); i++) keepData || 1 !== node.nodeType || jQuery.cleanData(getAll(node)), node.parentNode && (keepData && jQuery.contains(node.ownerDocument, node) && setGlobalEval(getAll(node, "script")), node.parentNode.removeChild(node));
        return elem
      }
      jQuery.extend({
        htmlPrefilter: function (html) {
          return html.replace(rxhtmlTag, "<$1></$2>")
        },
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
          var i, l, srcElements, destElements, src, dest, nodeName, clone = elem.cloneNode(!0),
            inPage = jQuery.contains(elem.ownerDocument, elem);
          if (!(support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem)))
            for (destElements = getAll(clone), i = 0, l = (srcElements = getAll(elem)).length; i < l; i++) src = srcElements[i], dest = destElements[i], void 0, "input" === (nodeName = dest.nodeName.toLowerCase()) && rcheckableType.test(src.type) ? dest.checked = src.checked : "input" !== nodeName && "textarea" !== nodeName || (dest.defaultValue = src.defaultValue);
          if (dataAndEvents)
            if (deepDataAndEvents)
              for (srcElements = srcElements || getAll(elem), destElements = destElements || getAll(clone), i = 0, l = srcElements.length; i < l; i++) cloneCopyEvent(srcElements[i], destElements[i]);
            else cloneCopyEvent(elem, clone);
          return 0 < (destElements = getAll(clone, "script")).length && setGlobalEval(destElements, !inPage && getAll(elem, "script")), clone
        },
        cleanData: function (elems) {
          for (var data, elem, type, special = jQuery.event.special, i = 0; void 0 !== (elem = elems[i]); i++)
            if (acceptData(elem)) {
              if (data = elem[dataPriv.expando]) {
                if (data.events)
                  for (type in data.events) special[type] ? jQuery.event.remove(elem, type) : jQuery.removeEvent(elem, type, data.handle);
                elem[dataPriv.expando] = void 0
              }
              elem[dataUser.expando] && (elem[dataUser.expando] = void 0)
            }
        }
      }), jQuery.fn.extend({
        detach: function (selector) {
          return remove(this, selector, !0)
        },
        remove: function (selector) {
          return remove(this, selector)
        },
        text: function (value) {
          return access(this, function (value) {
            return void 0 === value ? jQuery.text(this) : this.empty().each(function () {
              1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = value)
            })
          }, null, value, arguments.length)
        },
        append: function () {
          return domManip(this, arguments, function (elem) {
            1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || manipulationTarget(this, elem).appendChild(elem)
          })
        },
        prepend: function () {
          return domManip(this, arguments, function (elem) {
            if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
              var target = manipulationTarget(this, elem);
              target.insertBefore(elem, target.firstChild)
            }
          })
        },
        before: function () {
          return domManip(this, arguments, function (elem) {
            this.parentNode && this.parentNode.insertBefore(elem, this)
          })
        },
        after: function () {
          return domManip(this, arguments, function (elem) {
            this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling)
          })
        },
        empty: function () {
          for (var elem, i = 0; null != (elem = this[i]); i++) 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), elem.textContent = "");
          return this
        },
        clone: function (dataAndEvents, deepDataAndEvents) {
          return dataAndEvents = null != dataAndEvents && dataAndEvents, deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents : deepDataAndEvents, this.map(function () {
            return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
          })
        },
        html: function (value) {
          return access(this, function (value) {
            var elem = this[0] || {},
              i = 0,
              l = this.length;
            if (void 0 === value && 1 === elem.nodeType) return elem.innerHTML;
            if ("string" == typeof value && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
              value = jQuery.htmlPrefilter(value);
              try {
                for (; i < l; i++) 1 === (elem = this[i] || {}).nodeType && (jQuery.cleanData(getAll(elem, !1)), elem.innerHTML = value);
                elem = 0
              } catch (e) {}
            }
            elem && this.empty().append(value)
          }, null, value, arguments.length)
        },
        replaceWith: function () {
          var ignored = [];
          return domManip(this, arguments, function (elem) {
            var parent = this.parentNode;
            jQuery.inArray(this, ignored) < 0 && (jQuery.cleanData(getAll(this)), parent && parent.replaceChild(elem, this))
          }, ignored)
        }
      }), jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function (name, original) {
        jQuery.fn[name] = function (selector) {
          for (var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0; i <= last; i++) elems = i === last ? this : this.clone(!0), jQuery(insert[i])[original](elems), push.apply(ret, elems.get());
          return this.pushStack(ret)
        }
      });
      var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i"),
        getStyles = function (elem) {
          var view = elem.ownerDocument.defaultView;
          return view && view.opener || (view = window), view.getComputedStyle(elem)
        },
        rboxStyle = new RegExp(cssExpand.join("|"), "i");

      function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        return (computed = computed || getStyles(elem)) && ("" !== (ret = computed.getPropertyValue(name) || computed[name]) || jQuery.contains(elem.ownerDocument, elem) || (ret = jQuery.style(elem, name)), !support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name) && (width = style.width, minWidth = style.minWidth, maxWidth = style.maxWidth, style.minWidth = style.maxWidth = style.width = ret, ret = computed.width, style.width = width, style.minWidth = minWidth, style.maxWidth = maxWidth)), void 0 !== ret ? ret + "" : ret
      }

      function addGetHookIf(conditionFn, hookFn) {
        return {
          get: function () {
            if (!conditionFn()) return (this.get = hookFn).apply(this, arguments);
            delete this.get
          }
        }
      }! function () {
        function computeStyleTests() {
          if (div) {
            container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", documentElement.appendChild(container).appendChild(div);
            var divStyle = window.getComputedStyle(div);
            pixelPositionVal = "1%" !== divStyle.top, reliableMarginLeftVal = 12 === roundPixelMeasures(divStyle.marginLeft), div.style.right = "60%", pixelBoxStylesVal = 36 === roundPixelMeasures(divStyle.right), boxSizingReliableVal = 36 === roundPixelMeasures(divStyle.width), div.style.position = "absolute", scrollboxSizeVal = 36 === div.offsetWidth || "absolute", documentElement.removeChild(container), div = null
          }
        }

        function roundPixelMeasures(measure) {
          return Math.round(parseFloat(measure))
        }
        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableMarginLeftVal, container = document.createElement("div"),
          div = document.createElement("div");
        div.style && (div.style.backgroundClip = "content-box", div.cloneNode(!0).style.backgroundClip = "", support.clearCloneStyle = "content-box" === div.style.backgroundClip, jQuery.extend(support, {
          boxSizingReliable: function () {
            return computeStyleTests(), boxSizingReliableVal
          },
          pixelBoxStyles: function () {
            return computeStyleTests(), pixelBoxStylesVal
          },
          pixelPosition: function () {
            return computeStyleTests(), pixelPositionVal
          },
          reliableMarginLeft: function () {
            return computeStyleTests(), reliableMarginLeftVal
          },
          scrollboxSize: function () {
            return computeStyleTests(), scrollboxSizeVal
          }
        }))
      }();
      var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rcustomProp = /^--/,
        cssShow = {
          position: "absolute",
          visibility: "hidden",
          display: "block"
        },
        cssNormalTransform = {
          letterSpacing: "0",
          fontWeight: "400"
        },
        cssPrefixes = ["Webkit", "Moz", "ms"],
        emptyStyle = document.createElement("div").style;

      function finalPropName(name) {
        var ret = jQuery.cssProps[name];
        return ret || (ret = jQuery.cssProps[name] = function (name) {
          if (name in emptyStyle) return name;
          for (var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length; i--;)
            if ((name = cssPrefixes[i] + capName) in emptyStyle) return name
        }(name) || name), ret
      }

      function setPositiveNumber(elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value
      }

      function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i = "width" === dimension ? 1 : 0,
          extra = 0,
          delta = 0;
        if (box === (isBorderBox ? "border" : "content")) return 0;
        for (; i < 4; i += 2) "margin" === box && (delta += jQuery.css(elem, box + cssExpand[i], !0, styles)), isBorderBox ? ("content" === box && (delta -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)), "margin" !== box && (delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) : (delta += jQuery.css(elem, "padding" + cssExpand[i], !0, styles), "padding" !== box ? delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles) : extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles));
        return !isBorderBox && 0 <= computedVal && (delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - .5))), delta
      }

      function getWidthOrHeight(elem, dimension, extra) {
        var styles = getStyles(elem),
          val = curCSS(elem, dimension, styles),
          isBorderBox = "border-box" === jQuery.css(elem, "boxSizing", !1, styles),
          valueIsBorderBox = isBorderBox;
        if (rnumnonpx.test(val)) {
          if (!extra) return val;
          val = "auto"
        }
        return valueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]), ("auto" === val || !parseFloat(val) && "inline" === jQuery.css(elem, "display", !1, styles)) && (val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)], valueIsBorderBox = !0), (val = parseFloat(val) || 0) + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, val) + "px"
      }

      function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing)
      }
      jQuery.extend({
        cssHooks: {
          opacity: {
            get: function (elem, computed) {
              if (computed) {
                var ret = curCSS(elem, "opacity");
                return "" === ret ? "1" : ret
              }
            }
          }
        },
        cssNumber: {
          animationIterationCount: !0,
          columnCount: !0,
          fillOpacity: !0,
          flexGrow: !0,
          flexShrink: !0,
          fontWeight: !0,
          lineHeight: !0,
          opacity: !0,
          order: !0,
          orphans: !0,
          widows: !0,
          zIndex: !0,
          zoom: !0
        },
        cssProps: {},
        style: function (elem, name, value, extra) {
          if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
            var ret, type, hooks, origName = camelCase(name),
              isCustomProp = rcustomProp.test(name),
              style = elem.style;
            if (isCustomProp || (name = finalPropName(origName)), hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], void 0 === value) return hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, !1, extra)) ? ret : style[name];
            "string" === (type = typeof value) && (ret = rcssNum.exec(value)) && ret[1] && (value = adjustCSS(elem, name, ret), type = "number"), null != value && value == value && ("number" === type && (value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px")), support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"), hooks && "set" in hooks && void 0 === (value = hooks.set(elem, value, extra)) || (isCustomProp ? style.setProperty(name, value) : style[name] = value))
          }
        },
        css: function (elem, name, extra, styles) {
          var val, num, hooks, origName = camelCase(name);
          return rcustomProp.test(name) || (name = finalPropName(origName)), (hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]) && "get" in hooks && (val = hooks.get(elem, !0, extra)), void 0 === val && (val = curCSS(elem, name, styles)), "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]), "" === extra || extra ? (num = parseFloat(val), !0 === extra || isFinite(num) ? num || 0 : val) : val
        }
      }), jQuery.each(["height", "width"], function (i, dimension) {
        jQuery.cssHooks[dimension] = {
          get: function (elem, computed, extra) {
            if (computed) return !rdisplayswap.test(jQuery.css(elem, "display")) || elem.getClientRects().length && elem.getBoundingClientRect().width ? getWidthOrHeight(elem, dimension, extra) : swap(elem, cssShow, function () {
              return getWidthOrHeight(elem, dimension, extra)
            })
          },
          set: function (elem, value, extra) {
            var matches, styles = getStyles(elem),
              isBorderBox = "border-box" === jQuery.css(elem, "boxSizing", !1, styles),
              subtract = extra && boxModelAdjustment(elem, dimension, extra, isBorderBox, styles);
            return isBorderBox && support.scrollboxSize() === styles.position && (subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", !1, styles) - .5)), subtract && (matches = rcssNum.exec(value)) && "px" !== (matches[3] || "px") && (elem.style[dimension] = value, value = jQuery.css(elem, dimension)), setPositiveNumber(0, value, subtract)
          }
        }
      }), jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
        if (computed) return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
          marginLeft: 0
        }, function () {
          return elem.getBoundingClientRect().left
        })) + "px"
      }), jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
          expand: function (value) {
            for (var i = 0, expanded = {}, parts = "string" == typeof value ? value.split(" ") : [value]; i < 4; i++) expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
            return expanded
          }
        }, "margin" !== prefix && (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber)
      }), jQuery.fn.extend({
        css: function (name, value) {
          return access(this, function (elem, name, value) {
            var styles, len, map = {},
              i = 0;
            if (Array.isArray(name)) {
              for (styles = getStyles(elem), len = name.length; i < len; i++) map[name[i]] = jQuery.css(elem, name[i], !1, styles);
              return map
            }
            return void 0 !== value ? jQuery.style(elem, name, value) : jQuery.css(elem, name)
          }, name, value, 1 < arguments.length)
        }
      }), ((jQuery.Tween = Tween).prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
          this.elem = elem, this.prop = prop, this.easing = easing || jQuery.easing._default, this.options = options, this.start = this.now = this.cur(), this.end = end, this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px")
        },
        cur: function () {
          var hooks = Tween.propHooks[this.prop];
          return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this)
        },
        run: function (percent) {
          var eased, hooks = Tween.propHooks[this.prop];
          return this.options.duration ? this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) : this.pos = eased = percent, this.now = (this.end - this.start) * eased + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), hooks && hooks.set ? hooks.set(this) : Tween.propHooks._default.set(this), this
        }
      }).init.prototype = Tween.prototype, (Tween.propHooks = {
        _default: {
          get: function (tween) {
            var result;
            return 1 !== tween.elem.nodeType || null != tween.elem[tween.prop] && null == tween.elem.style[tween.prop] ? tween.elem[tween.prop] : (result = jQuery.css(tween.elem, tween.prop, "")) && "auto" !== result ? result : 0
          },
          set: function (tween) {
            jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) : 1 !== tween.elem.nodeType || null == tween.elem.style[jQuery.cssProps[tween.prop]] && !jQuery.cssHooks[tween.prop] ? tween.elem[tween.prop] = tween.now : jQuery.style(tween.elem, tween.prop, tween.now + tween.unit)
          }
        }
      }).scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
          tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now)
        }
      }, jQuery.easing = {
        linear: function (p) {
          return p
        },
        swing: function (p) {
          return .5 - Math.cos(p * Math.PI) / 2
        },
        _default: "swing"
      }, jQuery.fx = Tween.prototype.init, jQuery.fx.step = {};
      var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/,
        rrun = /queueHooks$/;

      function schedule() {
        inProgress && (!1 === document.hidden && window.requestAnimationFrame ? window.requestAnimationFrame(schedule) : window.setTimeout(schedule, jQuery.fx.interval), jQuery.fx.tick())
      }

      function createFxNow() {
        return window.setTimeout(function () {
          fxNow = void 0
        }), fxNow = Date.now()
      }

      function genFx(type, includeWidth) {
        var which, i = 0,
          attrs = {
            height: type
          };
        for (includeWidth = includeWidth ? 1 : 0; i < 4; i += 2 - includeWidth) attrs["margin" + (which = cssExpand[i])] = attrs["padding" + which] = type;
        return includeWidth && (attrs.opacity = attrs.width = type), attrs
      }

      function createTween(value, prop, animation) {
        for (var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length; index < length; index++)
          if (tween = collection[index].call(animation, prop, value)) return tween
      }

      function Animation(elem, properties, options) {
        var result, stopped, index = 0,
          length = Animation.prefilters.length,
          deferred = jQuery.Deferred().always(function () {
            delete tick.elem
          }),
          tick = function () {
            if (stopped) return !1;
            for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), percent = 1 - (remaining / animation.duration || 0), index = 0, length = animation.tweens.length; index < length; index++) animation.tweens[index].run(percent);
            return deferred.notifyWith(elem, [animation, percent, remaining]), percent < 1 && length ? remaining : (length || deferred.notifyWith(elem, [animation, 1, 0]), deferred.resolveWith(elem, [animation]), !1)
          },
          animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(!0, {
              specialEasing: {},
              easing: jQuery.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function (prop, end) {
              var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
              return animation.tweens.push(tween), tween
            },
            stop: function (gotoEnd) {
              var index = 0,
                length = gotoEnd ? animation.tweens.length : 0;
              if (stopped) return this;
              for (stopped = !0; index < length; index++) animation.tweens[index].run(1);
              return gotoEnd ? (deferred.notifyWith(elem, [animation, 1, 0]), deferred.resolveWith(elem, [animation, gotoEnd])) : deferred.rejectWith(elem, [animation, gotoEnd]), this
            }
          }),
          props = animation.props;
        for (! function (props, specialEasing) {
            var index, name, easing, value, hooks;
            for (index in props)
              if (easing = specialEasing[name = camelCase(index)], value = props[index], Array.isArray(value) && (easing = value[1], value = props[index] = value[0]), index !== name && (props[name] = value, delete props[index]), (hooks = jQuery.cssHooks[name]) && "expand" in hooks)
                for (index in value = hooks.expand(value), delete props[name], value) index in props || (props[index] = value[index], specialEasing[index] = easing);
              else specialEasing[name] = easing
          }(props, animation.opts.specialEasing); index < length; index++)
          if (result = Animation.prefilters[index].call(animation, elem, props, animation.opts)) return isFunction(result.stop) && (jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result)), result;
        return jQuery.map(props, createTween, animation), isFunction(animation.opts.start) && animation.opts.start.call(elem, animation), animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always), jQuery.fx.timer(jQuery.extend(tick, {
          elem: elem,
          anim: animation,
          queue: animation.opts.queue
        })), animation
      }
      jQuery.Animation = jQuery.extend(Animation, {
          tweeners: {
            "*": [function (prop, value) {
              var tween = this.createTween(prop, value);
              return adjustCSS(tween.elem, prop, rcssNum.exec(value), tween), tween
            }]
          },
          tweener: function (props, callback) {
            isFunction(props) ? (callback = props, props = ["*"]) : props = props.match(rnothtmlwhite);
            for (var prop, index = 0, length = props.length; index < length; index++) prop = props[index], Animation.tweeners[prop] = Animation.tweeners[prop] || [], Animation.tweeners[prop].unshift(callback)
          },
          prefilters: [function (elem, props, opts) {
            var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props,
              anim = this,
              orig = {},
              style = elem.style,
              hidden = elem.nodeType && isHiddenWithinTree(elem),
              dataShow = dataPriv.get(elem, "fxshow");
            for (prop in opts.queue || (null == (hooks = jQuery._queueHooks(elem, "fx")).unqueued && (hooks.unqueued = 0, oldfire = hooks.empty.fire, hooks.empty.fire = function () {
                hooks.unqueued || oldfire()
              }), hooks.unqueued++, anim.always(function () {
                anim.always(function () {
                  hooks.unqueued--, jQuery.queue(elem, "fx").length || hooks.empty.fire()
                })
              })), props)
              if (value = props[prop], rfxtypes.test(value)) {
                if (delete props[prop], toggle = toggle || "toggle" === value, value === (hidden ? "hide" : "show")) {
                  if ("show" !== value || !dataShow || void 0 === dataShow[prop]) continue;
                  hidden = !0
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop)
              }
            if ((propTween = !jQuery.isEmptyObject(props)) || !jQuery.isEmptyObject(orig))
              for (prop in isBox && 1 === elem.nodeType && (opts.overflow = [style.overflow, style.overflowX, style.overflowY], null == (restoreDisplay = dataShow && dataShow.display) && (restoreDisplay = dataPriv.get(elem, "display")), "none" === (display = jQuery.css(elem, "display")) && (restoreDisplay ? display = restoreDisplay : (showHide([elem], !0), restoreDisplay = elem.style.display || restoreDisplay, display = jQuery.css(elem, "display"), showHide([elem]))), ("inline" === display || "inline-block" === display && null != restoreDisplay) && "none" === jQuery.css(elem, "float") && (propTween || (anim.done(function () {
                  style.display = restoreDisplay
                }), null == restoreDisplay && (display = style.display, restoreDisplay = "none" === display ? "" : display)), style.display = "inline-block")), opts.overflow && (style.overflow = "hidden", anim.always(function () {
                  style.overflow = opts.overflow[0], style.overflowX = opts.overflow[1], style.overflowY = opts.overflow[2]
                })), propTween = !1, orig) propTween || (dataShow ? "hidden" in dataShow && (hidden = dataShow.hidden) : dataShow = dataPriv.access(elem, "fxshow", {
                display: restoreDisplay
              }), toggle && (dataShow.hidden = !hidden), hidden && showHide([elem], !0), anim.done(function () {
                for (prop in hidden || showHide([elem]), dataPriv.remove(elem, "fxshow"), orig) jQuery.style(elem, prop, orig[prop])
              })), propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim), prop in dataShow || (dataShow[prop] = propTween.start, hidden && (propTween.end = propTween.start, propTween.start = 0))
          }],
          prefilter: function (callback, prepend) {
            prepend ? Animation.prefilters.unshift(callback) : Animation.prefilters.push(callback)
          }
        }), jQuery.speed = function (speed, easing, fn) {
          var opt = speed && "object" == typeof speed ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction(easing) && easing
          };
          return jQuery.fx.off ? opt.duration = 0 : "number" != typeof opt.duration && (opt.duration in jQuery.fx.speeds ? opt.duration = jQuery.fx.speeds[opt.duration] : opt.duration = jQuery.fx.speeds._default), null != opt.queue && !0 !== opt.queue || (opt.queue = "fx"), opt.old = opt.complete, opt.complete = function () {
            isFunction(opt.old) && opt.old.call(this), opt.queue && jQuery.dequeue(this, opt.queue)
          }, opt
        }, jQuery.fn.extend({
          fadeTo: function (speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({
              opacity: to
            }, speed, easing, callback)
          },
          animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop),
              optall = jQuery.speed(speed, easing, callback),
              doAnimation = function () {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                (empty || dataPriv.get(this, "finish")) && anim.stop(!0)
              };
            return doAnimation.finish = doAnimation, empty || !1 === optall.queue ? this.each(doAnimation) : this.queue(optall.queue, doAnimation)
          },
          stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
              var stop = hooks.stop;
              delete hooks.stop, stop(gotoEnd)
            };
            return "string" != typeof type && (gotoEnd = clearQueue, clearQueue = type, type = void 0), clearQueue && !1 !== type && this.queue(type || "fx", []), this.each(function () {
              var dequeue = !0,
                index = null != type && type + "queueHooks",
                timers = jQuery.timers,
                data = dataPriv.get(this);
              if (index) data[index] && data[index].stop && stopQueue(data[index]);
              else
                for (index in data) data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
              for (index = timers.length; index--;) timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd), dequeue = !1, timers.splice(index, 1));
              !dequeue && gotoEnd || jQuery.dequeue(this, type)
            })
          },
          finish: function (type) {
            return !1 !== type && (type = type || "fx"), this.each(function () {
              var index, data = dataPriv.get(this),
                queue = data[type + "queue"],
                hooks = data[type + "queueHooks"],
                timers = jQuery.timers,
                length = queue ? queue.length : 0;
              for (data.finish = !0, jQuery.queue(this, type, []), hooks && hooks.stop && hooks.stop.call(this, !0), index = timers.length; index--;) timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0), timers.splice(index, 1));
              for (index = 0; index < length; index++) queue[index] && queue[index].finish && queue[index].finish.call(this);
              delete data.finish
            })
          }
        }), jQuery.each(["toggle", "show", "hide"], function (i, name) {
          var cssFn = jQuery.fn[name];
          jQuery.fn[name] = function (speed, easing, callback) {
            return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) : this.animate(genFx(name, !0), speed, easing, callback)
          }
        }), jQuery.each({
          slideDown: genFx("show"),
          slideUp: genFx("hide"),
          slideToggle: genFx("toggle"),
          fadeIn: {
            opacity: "show"
          },
          fadeOut: {
            opacity: "hide"
          },
          fadeToggle: {
            opacity: "toggle"
          }
        }, function (name, props) {
          jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback)
          }
        }), jQuery.timers = [], jQuery.fx.tick = function () {
          var timer, i = 0,
            timers = jQuery.timers;
          for (fxNow = Date.now(); i < timers.length; i++)(timer = timers[i])() || timers[i] !== timer || timers.splice(i--, 1);
          timers.length || jQuery.fx.stop(), fxNow = void 0
        }, jQuery.fx.timer = function (timer) {
          jQuery.timers.push(timer), jQuery.fx.start()
        }, jQuery.fx.interval = 13, jQuery.fx.start = function () {
          inProgress || (inProgress = !0, schedule())
        }, jQuery.fx.stop = function () {
          inProgress = null
        }, jQuery.fx.speeds = {
          slow: 600,
          fast: 200,
          _default: 400
        }, jQuery.fn.delay = function (time, type) {
          return time = jQuery.fx && jQuery.fx.speeds[time] || time, type = type || "fx", this.queue(type, function (next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function () {
              window.clearTimeout(timeout)
            }
          })
        },
        function () {
          var input = document.createElement("input"),
            opt = document.createElement("select").appendChild(document.createElement("option"));
          input.type = "checkbox", support.checkOn = "" !== input.value, support.optSelected = opt.selected, (input = document.createElement("input")).value = "t", input.type = "radio", support.radioValue = "t" === input.value
        }();
      var boolHook, attrHandle = jQuery.expr.attrHandle;
      jQuery.fn.extend({
        attr: function (name, value) {
          return access(this, jQuery.attr, name, value, 1 < arguments.length)
        },
        removeAttr: function (name) {
          return this.each(function () {
            jQuery.removeAttr(this, name)
          })
        }
      }), jQuery.extend({
        attr: function (elem, name, value) {
          var ret, hooks, nType = elem.nodeType;
          if (3 !== nType && 8 !== nType && 2 !== nType) return void 0 === elem.getAttribute ? jQuery.prop(elem, name, value) : (1 === nType && jQuery.isXMLDoc(elem) || (hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0)), void 0 !== value ? null === value ? void jQuery.removeAttr(elem, name) : hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : (elem.setAttribute(name, value + ""), value) : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : null == (ret = jQuery.find.attr(elem, name)) ? void 0 : ret)
        },
        attrHooks: {
          type: {
            set: function (elem, value) {
              if (!support.radioValue && "radio" === value && nodeName(elem, "input")) {
                var val = elem.value;
                return elem.setAttribute("type", value), val && (elem.value = val), value
              }
            }
          }
        },
        removeAttr: function (elem, value) {
          var name, i = 0,
            attrNames = value && value.match(rnothtmlwhite);
          if (attrNames && 1 === elem.nodeType)
            for (; name = attrNames[i++];) elem.removeAttribute(name)
        }
      }), boolHook = {
        set: function (elem, value, name) {
          return !1 === value ? jQuery.removeAttr(elem, name) : elem.setAttribute(name, name), name
        }
      }, jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function (elem, name, isXML) {
          var ret, handle, lowercaseName = name.toLowerCase();
          return isXML || (handle = attrHandle[lowercaseName], attrHandle[lowercaseName] = ret, ret = null != getter(elem, name, isXML) ? lowercaseName : null, attrHandle[lowercaseName] = handle), ret
        }
      });
      var rfocusable = /^(?:input|select|textarea|button)$/i,
        rclickable = /^(?:a|area)$/i;

      function stripAndCollapse(value) {
        return (value.match(rnothtmlwhite) || []).join(" ")
      }

      function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || ""
      }

      function classesToArray(value) {
        return Array.isArray(value) ? value : "string" == typeof value && value.match(rnothtmlwhite) || []
      }
      jQuery.fn.extend({
        prop: function (name, value) {
          return access(this, jQuery.prop, name, value, 1 < arguments.length)
        },
        removeProp: function (name) {
          return this.each(function () {
            delete this[jQuery.propFix[name] || name]
          })
        }
      }), jQuery.extend({
        prop: function (elem, name, value) {
          var ret, hooks, nType = elem.nodeType;
          if (3 !== nType && 8 !== nType && 2 !== nType) return 1 === nType && jQuery.isXMLDoc(elem) || (name = jQuery.propFix[name] || name, hooks = jQuery.propHooks[name]), void 0 !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : elem[name] = value : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : elem[name]
        },
        propHooks: {
          tabIndex: {
            get: function (elem) {
              var tabindex = jQuery.find.attr(elem, "tabindex");
              return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1
            }
          }
        },
        propFix: {
          for: "htmlFor",
          class: "className"
        }
      }), support.optSelected || (jQuery.propHooks.selected = {
        get: function (elem) {
          var parent = elem.parentNode;
          return parent && parent.parentNode && parent.parentNode.selectedIndex, null
        },
        set: function (elem) {
          var parent = elem.parentNode;
          parent && (parent.selectedIndex, parent.parentNode && parent.parentNode.selectedIndex)
        }
      }), jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
        jQuery.propFix[this.toLowerCase()] = this
      }), jQuery.fn.extend({
        addClass: function (value) {
          var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
          if (isFunction(value)) return this.each(function (j) {
            jQuery(this).addClass(value.call(this, j, getClass(this)))
          });
          if ((classes = classesToArray(value)).length)
            for (; elem = this[i++];)
              if (curValue = getClass(elem), cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                for (j = 0; clazz = classes[j++];) cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
                curValue !== (finalValue = stripAndCollapse(cur)) && elem.setAttribute("class", finalValue)
              }
          return this
        },
        removeClass: function (value) {
          var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
          if (isFunction(value)) return this.each(function (j) {
            jQuery(this).removeClass(value.call(this, j, getClass(this)))
          });
          if (!arguments.length) return this.attr("class", "");
          if ((classes = classesToArray(value)).length)
            for (; elem = this[i++];)
              if (curValue = getClass(elem), cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                for (j = 0; clazz = classes[j++];)
                  for (; - 1 < cur.indexOf(" " + clazz + " ");) cur = cur.replace(" " + clazz + " ", " ");
                curValue !== (finalValue = stripAndCollapse(cur)) && elem.setAttribute("class", finalValue)
              }
          return this
        },
        toggleClass: function (value, stateVal) {
          var type = typeof value,
            isValidValue = "string" === type || Array.isArray(value);
          return "boolean" == typeof stateVal && isValidValue ? stateVal ? this.addClass(value) : this.removeClass(value) : isFunction(value) ? this.each(function (i) {
            jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal)
          }) : this.each(function () {
            var className, i, self, classNames;
            if (isValidValue)
              for (i = 0, self = jQuery(this), classNames = classesToArray(value); className = classNames[i++];) self.hasClass(className) ? self.removeClass(className) : self.addClass(className);
            else void 0 !== value && "boolean" !== type || ((className = getClass(this)) && dataPriv.set(this, "__className__", className), this.setAttribute && this.setAttribute("class", className || !1 === value ? "" : dataPriv.get(this, "__className__") || ""))
          })
        },
        hasClass: function (selector) {
          var className, elem, i = 0;
          for (className = " " + selector + " "; elem = this[i++];)
            if (1 === elem.nodeType && -1 < (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className)) return !0;
          return !1
        }
      });
      var rreturn = /\r/g;
      jQuery.fn.extend({
        val: function (value) {
          var hooks, ret, valueIsFunction, elem = this[0];
          return arguments.length ? (valueIsFunction = isFunction(value), this.each(function (i) {
            var val;
            1 === this.nodeType && (null == (val = valueIsFunction ? value.call(this, i, jQuery(this).val()) : value) ? val = "" : "number" == typeof val ? val += "" : Array.isArray(val) && (val = jQuery.map(val, function (value) {
              return null == value ? "" : value + ""
            })), (hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]) && "set" in hooks && void 0 !== hooks.set(this, val, "value") || (this.value = val))
          })) : elem ? (hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()]) && "get" in hooks && void 0 !== (ret = hooks.get(elem, "value")) ? ret : "string" == typeof (ret = elem.value) ? ret.replace(rreturn, "") : null == ret ? "" : ret : void 0
        }
      }), jQuery.extend({
        valHooks: {
          option: {
            get: function (elem) {
              var val = jQuery.find.attr(elem, "value");
              return null != val ? val : stripAndCollapse(jQuery.text(elem))
            }
          },
          select: {
            get: function (elem) {
              var value, option, i, options = elem.options,
                index = elem.selectedIndex,
                one = "select-one" === elem.type,
                values = one ? null : [],
                max = one ? index + 1 : options.length;
              for (i = index < 0 ? max : one ? index : 0; i < max; i++)
                if (((option = options[i]).selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                  if (value = jQuery(option).val(), one) return value;
                  values.push(value)
                }
              return values
            },
            set: function (elem, value) {
              for (var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length; i--;)((option = options[i]).selected = -1 < jQuery.inArray(jQuery.valHooks.option.get(option), values)) && (optionSet = !0);
              return optionSet || (elem.selectedIndex = -1), values
            }
          }
        }
      }), jQuery.each(["radio", "checkbox"], function () {
        jQuery.valHooks[this] = {
          set: function (elem, value) {
            if (Array.isArray(value)) return elem.checked = -1 < jQuery.inArray(jQuery(elem).val(), value)
          }
        }, support.checkOn || (jQuery.valHooks[this].get = function (elem) {
          return null === elem.getAttribute("value") ? "on" : elem.value
        })
      }), support.focusin = "onfocusin" in window;
      var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        stopPropagationCallback = function (e) {
          e.stopPropagation()
        };
      jQuery.extend(jQuery.event, {
        trigger: function (event, data, elem, onlyHandlers) {
          var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document],
            type = hasOwn.call(event, "type") ? event.type : event,
            namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
          if (cur = lastElement = tmp = elem = elem || document, 3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (-1 < type.indexOf(".") && (type = (namespaces = type.split(".")).shift(), namespaces.sort()), ontype = type.indexOf(":") < 0 && "on" + type, (event = event[jQuery.expando] ? event : new jQuery.Event(type, "object" == typeof event && event)).isTrigger = onlyHandlers ? 2 : 3, event.namespace = namespaces.join("."), event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, event.result = void 0, event.target || (event.target = elem), data = null == data ? [event] : jQuery.makeArray(data, [event]), special = jQuery.event.special[type] || {}, onlyHandlers || !special.trigger || !1 !== special.trigger.apply(elem, data))) {
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
              for (bubbleType = special.delegateType || type, rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode) eventPath.push(cur), tmp = cur;
              tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window)
            }
            for (i = 0;
              (cur = eventPath[i++]) && !event.isPropagationStopped();) lastElement = cur, event.type = 1 < i ? bubbleType : special.bindType || type, (handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle")) && handle.apply(cur, data), (handle = ontype && cur[ontype]) && handle.apply && acceptData(cur) && (event.result = handle.apply(cur, data), !1 === event.result && event.preventDefault());
            return event.type = type, onlyHandlers || event.isDefaultPrevented() || special._default && !1 !== special._default.apply(eventPath.pop(), data) || !acceptData(elem) || ontype && isFunction(elem[type]) && !isWindow(elem) && ((tmp = elem[ontype]) && (elem[ontype] = null), jQuery.event.triggered = type, event.isPropagationStopped() && lastElement.addEventListener(type, stopPropagationCallback), elem[type](), event.isPropagationStopped() && lastElement.removeEventListener(type, stopPropagationCallback), jQuery.event.triggered = void 0, tmp && (elem[ontype] = tmp)), event.result
          }
        },
        simulate: function (type, elem, event) {
          var e = jQuery.extend(new jQuery.Event, event, {
            type: type,
            isSimulated: !0
          });
          jQuery.event.trigger(e, null, elem)
        }
      }), jQuery.fn.extend({
        trigger: function (type, data) {
          return this.each(function () {
            jQuery.event.trigger(type, data, this)
          })
        },
        triggerHandler: function (type, data) {
          var elem = this[0];
          if (elem) return jQuery.event.trigger(type, data, elem, !0)
        }
      }), support.focusin || jQuery.each({
        focus: "focusin",
        blur: "focusout"
      }, function (orig, fix) {
        var handler = function (event) {
          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event))
        };
        jQuery.event.special[fix] = {
          setup: function () {
            var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix);
            attaches || doc.addEventListener(orig, handler, !0), dataPriv.access(doc, fix, (attaches || 0) + 1)
          },
          teardown: function () {
            var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix) - 1;
            attaches ? dataPriv.access(doc, fix, attaches) : (doc.removeEventListener(orig, handler, !0), dataPriv.remove(doc, fix))
          }
        }
      });
      var location = window.location,
        nonce = Date.now(),
        rquery = /\?/;
      jQuery.parseXML = function (data) {
        var xml;
        if (!data || "string" != typeof data) return null;
        try {
          xml = (new window.DOMParser).parseFromString(data, "text/xml")
        } catch (e) {
          xml = void 0
        }
        return xml && !xml.getElementsByTagName("parsererror").length || jQuery.error("Invalid XML: " + data), xml
      };
      var rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

      function buildParams(prefix, obj, traditional, add) {
        var name;
        if (Array.isArray(obj)) jQuery.each(obj, function (i, v) {
          traditional || rbracket.test(prefix) ? add(prefix, v) : buildParams(prefix + "[" + ("object" == typeof v && null != v ? i : "") + "]", v, traditional, add)
        });
        else if (traditional || "object" !== toType(obj)) add(prefix, obj);
        else
          for (name in obj) buildParams(prefix + "[" + name + "]", obj[name], traditional, add)
      }
      jQuery.param = function (a, traditional) {
        var prefix, s = [],
          add = function (key, valueOrFunction) {
            var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(null == value ? "" : value)
          };
        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) jQuery.each(a, function () {
          add(this.name, this.value)
        });
        else
          for (prefix in a) buildParams(prefix, a[prefix], traditional, add);
        return s.join("&")
      }, jQuery.fn.extend({
        serialize: function () {
          return jQuery.param(this.serializeArray())
        },
        serializeArray: function () {
          return this.map(function () {
            var elements = jQuery.prop(this, "elements");
            return elements ? jQuery.makeArray(elements) : this
          }).filter(function () {
            var type = this.type;
            return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type))
          }).map(function (i, elem) {
            var val = jQuery(this).val();
            return null == val ? null : Array.isArray(val) ? jQuery.map(val, function (val) {
              return {
                name: elem.name,
                value: val.replace(rCRLF, "\r\n")
              }
            }) : {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            }
          }).get()
        }
      });
      var r20 = /%20/g,
        rhash = /#.*$/,
        rantiCache = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        prefilters = {},
        transports = {},
        allTypes = "*/".concat("*"),
        originAnchor = document.createElement("a");

      function addToPrefiltersOrTransports(structure) {
        return function (dataTypeExpression, func) {
          "string" != typeof dataTypeExpression && (func = dataTypeExpression, dataTypeExpression = "*");
          var dataType, i = 0,
            dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
          if (isFunction(func))
            for (; dataType = dataTypes[i++];) "+" === dataType[0] ? (dataType = dataType.slice(1) || "*", (structure[dataType] = structure[dataType] || []).unshift(func)) : (structure[dataType] = structure[dataType] || []).push(func)
        }
      }

      function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {},
          seekingTransport = structure === transports;

        function inspect(dataType) {
          var selected;
          return inspected[dataType] = !0, jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
            return "string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) : void 0 : (options.dataTypes.unshift(dataTypeOrTransport), inspect(dataTypeOrTransport), !1)
          }), selected
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*")
      }

      function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) void 0 !== src[key] && ((flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]);
        return deep && jQuery.extend(!0, target, deep), target
      }
      originAnchor.href = location.href, jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: location.href,
          type: "GET",
          isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(location.protocol),
          global: !0,
          processData: !0,
          async: !0,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          converters: {
            "* text": String,
            "text html": !0,
            "text json": JSON.parse,
            "text xml": jQuery.parseXML
          },
          flatOptions: {
            url: !0,
            context: !0
          }
        },
        ajaxSetup: function (target, settings) {
          return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target)
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function (url, options) {
          "object" == typeof url && (options = url, url = void 0), options = options || {};
          var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options),
            callbackContext = s.context || s,
            globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
            deferred = jQuery.Deferred(),
            completeDeferred = jQuery.Callbacks("once memory"),
            statusCode = s.statusCode || {},
            requestHeaders = {},
            requestHeadersNames = {},
            strAbort = "canceled",
            jqXHR = {
              readyState: 0,
              getResponseHeader: function (key) {
                var match;
                if (completed) {
                  if (!responseHeaders)
                    for (responseHeaders = {}; match = rheaders.exec(responseHeadersString);) responseHeaders[match[1].toLowerCase()] = match[2];
                  match = responseHeaders[key.toLowerCase()]
                }
                return null == match ? null : match
              },
              getAllResponseHeaders: function () {
                return completed ? responseHeadersString : null
              },
              setRequestHeader: function (name, value) {
                return null == completed && (name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name, requestHeaders[name] = value), this
              },
              overrideMimeType: function (type) {
                return null == completed && (s.mimeType = type), this
              },
              statusCode: function (map) {
                var code;
                if (map)
                  if (completed) jqXHR.always(map[jqXHR.status]);
                  else
                    for (code in map) statusCode[code] = [statusCode[code], map[code]];
                return this
              },
              abort: function (statusText) {
                var finalText = statusText || strAbort;
                return transport && transport.abort(finalText), done(0, finalText), this
              }
            };
          if (deferred.promise(jqXHR), s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"), s.type = options.method || options.type || s.method || s.type, s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""], null == s.crossDomain) {
            urlAnchor = document.createElement("a");
            try {
              urlAnchor.href = s.url, urlAnchor.href = urlAnchor.href, s.crossDomain = originAnchor.protocol + "//" + originAnchor.host != urlAnchor.protocol + "//" + urlAnchor.host
            } catch (e) {
              s.crossDomain = !0
            }
          }
          if (s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)), inspectPrefiltersOrTransports(prefilters, s, options, jqXHR), completed) return jqXHR;
          for (i in (fireGlobals = jQuery.event && s.global) && 0 == jQuery.active++ && jQuery.event.trigger("ajaxStart"), s.type = s.type.toUpperCase(), s.hasContent = !rnoContent.test(s.type), cacheURL = s.url.replace(rhash, ""), s.hasContent ? s.data && s.processData && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && (s.data = s.data.replace(r20, "+")) : (uncached = s.url.slice(cacheURL.length), s.data && (s.processData || "string" == typeof s.data) && (cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data, delete s.data), !1 === s.cache && (cacheURL = cacheURL.replace(rantiCache, "$1"), uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached), s.url = cacheURL + uncached), s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]), jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])), (s.data && s.hasContent && !1 !== s.contentType || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType), jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]), s.headers) jqXHR.setRequestHeader(i, s.headers[i]);
          if (s.beforeSend && (!1 === s.beforeSend.call(callbackContext, jqXHR, s) || completed)) return jqXHR.abort();
          if (strAbort = "abort", completeDeferred.add(s.complete), jqXHR.done(s.success), jqXHR.fail(s.error), transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
            if (jqXHR.readyState = 1, fireGlobals && globalEventContext.trigger("ajaxSend", [jqXHR, s]), completed) return jqXHR;
            s.async && 0 < s.timeout && (timeoutTimer = window.setTimeout(function () {
              jqXHR.abort("timeout")
            }, s.timeout));
            try {
              completed = !1, transport.send(requestHeaders, done)
            } catch (e) {
              if (completed) throw e;
              done(-1, e)
            }
          } else done(-1, "No Transport");

          function done(status, nativeStatusText, responses, headers) {
            var isSuccess, success, error, response, modified, statusText = nativeStatusText;
            completed || (completed = !0, timeoutTimer && window.clearTimeout(timeoutTimer), transport = void 0, responseHeadersString = headers || "", jqXHR.readyState = 0 < status ? 4 : 0, isSuccess = 200 <= status && status < 300 || 304 === status, responses && (response = function (s, jqXHR, responses) {
              for (var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
                "*" === dataTypes[0];) dataTypes.shift(), void 0 === ct && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
              if (ct)
                for (type in contents)
                  if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break
                  }
              if (dataTypes[0] in responses) finalDataType = dataTypes[0];
              else {
                for (type in responses) {
                  if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break
                  }
                  firstDataType || (firstDataType = type)
                }
                finalDataType = finalDataType || firstDataType
              }
              if (finalDataType) return finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType), responses[finalDataType]
            }(s, jqXHR, responses)), response = function (s, response, jqXHR, isSuccess) {
              var conv2, current, conv, tmp, prev, converters = {},
                dataTypes = s.dataTypes.slice();
              if (dataTypes[1])
                for (conv in s.converters) converters[conv.toLowerCase()] = s.converters[conv];
              for (current = dataTypes.shift(); current;)
                if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response), !prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)), prev = current, current = dataTypes.shift())
                  if ("*" === current) current = prev;
                  else if ("*" !== prev && prev !== current) {
                if (!(conv = converters[prev + " " + current] || converters["* " + current]))
                  for (conv2 in converters)
                    if ((tmp = conv2.split(" "))[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
                      !0 === conv ? conv = converters[conv2] : !0 !== converters[conv2] && (current = tmp[0], dataTypes.unshift(tmp[1]));
                      break
                    }
                if (!0 !== conv)
                  if (conv && s.throws) response = conv(response);
                  else try {
                    response = conv(response)
                  } catch (e) {
                    return {
                      state: "parsererror",
                      error: conv ? e : "No conversion from " + prev + " to " + current
                    }
                  }
              }
              return {
                state: "success",
                data: response
              }
            }(s, response, jqXHR, isSuccess), isSuccess ? (s.ifModified && ((modified = jqXHR.getResponseHeader("Last-Modified")) && (jQuery.lastModified[cacheURL] = modified), (modified = jqXHR.getResponseHeader("etag")) && (jQuery.etag[cacheURL] = modified)), 204 === status || "HEAD" === s.type ? statusText = "nocontent" : 304 === status ? statusText = "notmodified" : (statusText = response.state, success = response.data, isSuccess = !(error = response.error))) : (error = statusText, !status && statusText || (statusText = "error", status < 0 && (status = 0))), jqXHR.status = status, jqXHR.statusText = (nativeStatusText || statusText) + "", isSuccess ? deferred.resolveWith(callbackContext, [success, statusText, jqXHR]) : deferred.rejectWith(callbackContext, [jqXHR, statusText, error]), jqXHR.statusCode(statusCode), statusCode = void 0, fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]), completeDeferred.fireWith(callbackContext, [jqXHR, statusText]), fireGlobals && (globalEventContext.trigger("ajaxComplete", [jqXHR, s]), --jQuery.active || jQuery.event.trigger("ajaxStop")))
          }
          return jqXHR
        },
        getJSON: function (url, data, callback) {
          return jQuery.get(url, data, callback, "json")
        },
        getScript: function (url, callback) {
          return jQuery.get(url, void 0, callback, "script")
        }
      }), jQuery.each(["get", "post"], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
          return isFunction(data) && (type = type || callback, callback = data, data = void 0), jQuery.ajax(jQuery.extend({
            url: url,
            type: method,
            dataType: type,
            data: data,
            success: callback
          }, jQuery.isPlainObject(url) && url))
        }
      }), jQuery._evalUrl = function (url) {
        return jQuery.ajax({
          url: url,
          type: "GET",
          dataType: "script",
          cache: !0,
          async: !1,
          global: !1,
          throws: !0
        })
      }, jQuery.fn.extend({
        wrapAll: function (html) {
          var wrap;
          return this[0] && (isFunction(html) && (html = html.call(this[0])), wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && wrap.insertBefore(this[0]), wrap.map(function () {
            for (var elem = this; elem.firstElementChild;) elem = elem.firstElementChild;
            return elem
          }).append(this)), this
        },
        wrapInner: function (html) {
          return isFunction(html) ? this.each(function (i) {
            jQuery(this).wrapInner(html.call(this, i))
          }) : this.each(function () {
            var self = jQuery(this),
              contents = self.contents();
            contents.length ? contents.wrapAll(html) : self.append(html)
          })
        },
        wrap: function (html) {
          var htmlIsFunction = isFunction(html);
          return this.each(function (i) {
            jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html)
          })
        },
        unwrap: function (selector) {
          return this.parent(selector).not("body").each(function () {
            jQuery(this).replaceWith(this.childNodes)
          }), this
        }
      }), jQuery.expr.pseudos.hidden = function (elem) {
        return !jQuery.expr.pseudos.visible(elem)
      }, jQuery.expr.pseudos.visible = function (elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length)
      }, jQuery.ajaxSettings.xhr = function () {
        try {
          return new window.XMLHttpRequest
        } catch (e) {}
      };
      var xhrSuccessStatus = {
          0: 200,
          1223: 204
        },
        xhrSupported = jQuery.ajaxSettings.xhr();
      support.cors = !!xhrSupported && "withCredentials" in xhrSupported, support.ajax = xhrSupported = !!xhrSupported, jQuery.ajaxTransport(function (options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) return {
          send: function (headers, complete) {
            var i, xhr = options.xhr();
            if (xhr.open(options.type, options.url, options.async, options.username, options.password), options.xhrFields)
              for (i in options.xhrFields) xhr[i] = options.xhrFields[i];
            for (i in options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType), options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest"), headers) xhr.setRequestHeader(i, headers[i]);
            callback = function (type) {
              return function () {
                callback && (callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null, "abort" === type ? xhr.abort() : "error" === type ? "number" != typeof xhr.status ? complete(0, "error") : complete(xhr.status, xhr.statusText) : complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, "text" !== (xhr.responseType || "text") || "string" != typeof xhr.responseText ? {
                  binary: xhr.response
                } : {
                  text: xhr.responseText
                }, xhr.getAllResponseHeaders()))
              }
            }, xhr.onload = callback(), errorCallback = xhr.onerror = xhr.ontimeout = callback("error"), void 0 !== xhr.onabort ? xhr.onabort = errorCallback : xhr.onreadystatechange = function () {
              4 === xhr.readyState && window.setTimeout(function () {
                callback && errorCallback()
              })
            }, callback = callback("abort");
            try {
              xhr.send(options.hasContent && options.data || null)
            } catch (e) {
              if (callback) throw e
            }
          },
          abort: function () {
            callback && callback()
          }
        }
      }), jQuery.ajaxPrefilter(function (s) {
        s.crossDomain && (s.contents.script = !1)
      }), jQuery.ajaxSetup({
        accepts: {
          script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
          script: /\b(?:java|ecma)script\b/
        },
        converters: {
          "text script": function (text) {
            return jQuery.globalEval(text), text
          }
        }
      }), jQuery.ajaxPrefilter("script", function (s) {
        void 0 === s.cache && (s.cache = !1), s.crossDomain && (s.type = "GET")
      }), jQuery.ajaxTransport("script", function (s) {
        var script, callback;
        if (s.crossDomain) return {
          send: function (_, complete) {
            script = jQuery("<script>").prop({
              charset: s.scriptCharset,
              src: s.url
            }).on("load error", callback = function (evt) {
              script.remove(), callback = null, evt && complete("error" === evt.type ? 404 : 200, evt.type)
            }), document.head.appendChild(script[0])
          },
          abort: function () {
            callback && callback()
          }
        }
      });
      var body, oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;
      jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function () {
          var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
          return this[callback] = !0, callback
        }
      }), jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = !1 !== s.jsonp && (rjsonp.test(s.url) ? "url" : "string" == typeof s.data && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        if (jsonProp || "jsonp" === s.dataTypes[0]) return callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback, jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) : !1 !== s.jsonp && (s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName), s.converters["script json"] = function () {
          return responseContainer || jQuery.error(callbackName + " was not called"), responseContainer[0]
        }, s.dataTypes[0] = "json", overwritten = window[callbackName], window[callbackName] = function () {
          responseContainer = arguments
        }, jqXHR.always(function () {
          void 0 === overwritten ? jQuery(window).removeProp(callbackName) : window[callbackName] = overwritten, s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback, oldCallbacks.push(callbackName)), responseContainer && isFunction(overwritten) && overwritten(responseContainer[0]), responseContainer = overwritten = void 0
        }), "script"
      }), support.createHTMLDocument = ((body = document.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === body.childNodes.length), jQuery.parseHTML = function (data, context, keepScripts) {
        return "string" != typeof data ? [] : ("boolean" == typeof context && (keepScripts = context, context = !1), context || (support.createHTMLDocument ? ((base = (context = document.implementation.createHTMLDocument("")).createElement("base")).href = document.location.href, context.head.appendChild(base)) : context = document), scripts = !keepScripts && [], (parsed = rsingleTag.exec(data)) ? [context.createElement(parsed[1])] : (parsed = buildFragment([data], context, scripts), scripts && scripts.length && jQuery(scripts).remove(), jQuery.merge([], parsed.childNodes)));
        var base, parsed, scripts
      }, jQuery.fn.load = function (url, params, callback) {
        var selector, type, response, self = this,
          off = url.indexOf(" ");
        return -1 < off && (selector = stripAndCollapse(url.slice(off)), url = url.slice(0, off)), isFunction(params) ? (callback = params, params = void 0) : params && "object" == typeof params && (type = "POST"), 0 < self.length && jQuery.ajax({
          url: url,
          type: type || "GET",
          dataType: "html",
          data: params
        }).done(function (responseText) {
          response = arguments, self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText)
        }).always(callback && function (jqXHR, status) {
          self.each(function () {
            callback.apply(this, response || [jqXHR.responseText, status, jqXHR])
          })
        }), this
      }, jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
        jQuery.fn[type] = function (fn) {
          return this.on(type, fn)
        }
      }), jQuery.expr.pseudos.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
          return elem === fn.elem
        }).length
      }, jQuery.offset = {
        setOffset: function (elem, options, i) {
          var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, position = jQuery.css(elem, "position"),
            curElem = jQuery(elem),
            props = {};
          "static" === position && (elem.style.position = "relative"), curOffset = curElem.offset(), curCSSTop = jQuery.css(elem, "top"), curCSSLeft = jQuery.css(elem, "left"), ("absolute" === position || "fixed" === position) && -1 < (curCSSTop + curCSSLeft).indexOf("auto") ? (curTop = (curPosition = curElem.position()).top, curLeft = curPosition.left) : (curTop = parseFloat(curCSSTop) || 0, curLeft = parseFloat(curCSSLeft) || 0), isFunction(options) && (options = options.call(elem, i, jQuery.extend({}, curOffset))), null != options.top && (props.top = options.top - curOffset.top + curTop), null != options.left && (props.left = options.left - curOffset.left + curLeft), "using" in options ? options.using.call(elem, props) : curElem.css(props)
        }
      }, jQuery.fn.extend({
        offset: function (options) {
          if (arguments.length) return void 0 === options ? this : this.each(function (i) {
            jQuery.offset.setOffset(this, options, i)
          });
          var rect, win, elem = this[0];
          return elem ? elem.getClientRects().length ? (rect = elem.getBoundingClientRect(), win = elem.ownerDocument.defaultView, {
            top: rect.top + win.pageYOffset,
            left: rect.left + win.pageXOffset
          }) : {
            top: 0,
            left: 0
          } : void 0
        },
        position: function () {
          if (this[0]) {
            var offsetParent, offset, doc, elem = this[0],
              parentOffset = {
                top: 0,
                left: 0
              };
            if ("fixed" === jQuery.css(elem, "position")) offset = elem.getBoundingClientRect();
            else {
              for (offset = this.offset(), doc = elem.ownerDocument, offsetParent = elem.offsetParent || doc.documentElement; offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && "static" === jQuery.css(offsetParent, "position");) offsetParent = offsetParent.parentNode;
              offsetParent && offsetParent !== elem && 1 === offsetParent.nodeType && ((parentOffset = jQuery(offsetParent).offset()).top += jQuery.css(offsetParent, "borderTopWidth", !0), parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", !0))
            }
            return {
              top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0),
              left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)
            }
          }
        },
        offsetParent: function () {
          return this.map(function () {
            for (var offsetParent = this.offsetParent; offsetParent && "static" === jQuery.css(offsetParent, "position");) offsetParent = offsetParent.offsetParent;
            return offsetParent || documentElement
          })
        }
      }), jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
      }, function (method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function (val) {
          return access(this, function (elem, method, val) {
            var win;
            if (isWindow(elem) ? win = elem : 9 === elem.nodeType && (win = elem.defaultView), void 0 === val) return win ? win[prop] : elem[method];
            win ? win.scrollTo(top ? win.pageXOffset : val, top ? val : win.pageYOffset) : elem[method] = val
          }, method, val, arguments.length)
        }
      }), jQuery.each(["top", "left"], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
          if (computed) return computed = curCSS(elem, prop), rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed
        })
      }), jQuery.each({
        Height: "height",
        Width: "width"
      }, function (name, type) {
        jQuery.each({
          padding: "inner" + name,
          content: type,
          "": "outer" + name
        }, function (defaultExtra, funcName) {
          jQuery.fn[funcName] = function (margin, value) {
            var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin),
              extra = defaultExtra || (!0 === margin || !0 === value ? "margin" : "border");
            return access(this, function (elem, type, value) {
              var doc;
              return isWindow(elem) ? 0 === funcName.indexOf("outer") ? elem["inner" + name] : elem.document.documentElement["client" + name] : 9 === elem.nodeType ? (doc = elem.documentElement, Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) : void 0 === value ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra)
            }, type, chainable ? margin : void 0, chainable)
          }
        })
      }), jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (i, name) {
        jQuery.fn[name] = function (data, fn) {
          return 0 < arguments.length ? this.on(name, null, data, fn) : this.trigger(name)
        }
      }), jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
          return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
        }
      }), jQuery.fn.extend({
        bind: function (types, data, fn) {
          return this.on(types, null, data, fn)
        },
        unbind: function (types, fn) {
          return this.off(types, null, fn)
        },
        delegate: function (selector, types, data, fn) {
          return this.on(types, selector, data, fn)
        },
        undelegate: function (selector, types, fn) {
          return 1 === arguments.length ? this.off(selector, "**") : this.off(types, selector || "**", fn)
        }
      }), jQuery.proxy = function (fn, context) {
        var tmp, args, proxy;
        if ("string" == typeof context && (tmp = fn[context], context = fn, fn = tmp), isFunction(fn)) return args = slice.call(arguments, 2), (proxy = function () {
          return fn.apply(context || this, args.concat(slice.call(arguments)))
        }).guid = fn.guid = fn.guid || jQuery.guid++, proxy
      }, jQuery.holdReady = function (hold) {
        hold ? jQuery.readyWait++ : jQuery.ready(!0)
      }, jQuery.isArray = Array.isArray, jQuery.parseJSON = JSON.parse, jQuery.nodeName = nodeName, jQuery.isFunction = isFunction, jQuery.isWindow = isWindow, jQuery.camelCase = camelCase, jQuery.type = toType, jQuery.now = Date.now, jQuery.isNumeric = function (obj) {
        var type = jQuery.type(obj);
        return ("number" === type || "string" === type) && !isNaN(obj - parseFloat(obj))
      }, "function" == typeof define && define.amd && define("jquery", [], function () {
        return jQuery
      });
      var _jQuery = window.jQuery,
        _$ = window.$;
      return jQuery.noConflict = function (deep) {
        return window.$ === jQuery && (window.$ = _$), deep && window.jQuery === jQuery && (window.jQuery = _jQuery), jQuery
      }, noGlobal || (window.jQuery = window.$ = jQuery), jQuery
    })
  }, {}],
  8: [function (require, module, exports) {
    (function (global) {
      (function () {
        var undefined, LARGE_ARRAY_SIZE = 200,
          CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
          FUNC_ERROR_TEXT = "Expected a function",
          HASH_UNDEFINED = "__lodash_hash_undefined__",
          MAX_MEMOIZE_SIZE = 500,
          PLACEHOLDER = "__lodash_placeholder__",
          CLONE_DEEP_FLAG = 1,
          CLONE_FLAT_FLAG = 2,
          CLONE_SYMBOLS_FLAG = 4,
          COMPARE_PARTIAL_FLAG = 1,
          COMPARE_UNORDERED_FLAG = 2,
          WRAP_BIND_FLAG = 1,
          WRAP_BIND_KEY_FLAG = 2,
          WRAP_CURRY_BOUND_FLAG = 4,
          WRAP_CURRY_FLAG = 8,
          WRAP_CURRY_RIGHT_FLAG = 16,
          WRAP_PARTIAL_FLAG = 32,
          WRAP_PARTIAL_RIGHT_FLAG = 64,
          WRAP_ARY_FLAG = 128,
          WRAP_REARG_FLAG = 256,
          WRAP_FLIP_FLAG = 512,
          DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = "...",
          HOT_COUNT = 800,
          HOT_SPAN = 16,
          LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2,
          INFINITY = 1 / 0,
          MAX_SAFE_INTEGER = 9007199254740991,
          MAX_INTEGER = 1.7976931348623157e308,
          NAN = NaN,
          MAX_ARRAY_LENGTH = 4294967295,
          MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
          HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1,
          wrapFlags = [
            ["ary", WRAP_ARY_FLAG],
            ["bind", WRAP_BIND_FLAG],
            ["bindKey", WRAP_BIND_KEY_FLAG],
            ["curry", WRAP_CURRY_FLAG],
            ["curryRight", WRAP_CURRY_RIGHT_FLAG],
            ["flip", WRAP_FLIP_FLAG],
            ["partial", WRAP_PARTIAL_FLAG],
            ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
            ["rearg", WRAP_REARG_FLAG]
          ],
          argsTag = "[object Arguments]",
          arrayTag = "[object Array]",
          asyncTag = "[object AsyncFunction]",
          boolTag = "[object Boolean]",
          dateTag = "[object Date]",
          domExcTag = "[object DOMException]",
          errorTag = "[object Error]",
          funcTag = "[object Function]",
          genTag = "[object GeneratorFunction]",
          mapTag = "[object Map]",
          numberTag = "[object Number]",
          nullTag = "[object Null]",
          objectTag = "[object Object]",
          proxyTag = "[object Proxy]",
          regexpTag = "[object RegExp]",
          setTag = "[object Set]",
          stringTag = "[object String]",
          symbolTag = "[object Symbol]",
          undefinedTag = "[object Undefined]",
          weakMapTag = "[object WeakMap]",
          weakSetTag = "[object WeakSet]",
          arrayBufferTag = "[object ArrayBuffer]",
          dataViewTag = "[object DataView]",
          float32Tag = "[object Float32Array]",
          float64Tag = "[object Float64Array]",
          int8Tag = "[object Int8Array]",
          int16Tag = "[object Int16Array]",
          int32Tag = "[object Int32Array]",
          uint8Tag = "[object Uint8Array]",
          uint8ClampedTag = "[object Uint8ClampedArray]",
          uint16Tag = "[object Uint16Array]",
          uint32Tag = "[object Uint32Array]",
          reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
          reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
          reUnescapedHtml = /[&<>"']/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source),
          reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g,
          reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
          reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
          reHasRegExpChar = RegExp(reRegExpChar.source),
          reTrim = /^\s+|\s+$/g,
          reTrimStart = /^\s+/,
          reTrimEnd = /\s+$/,
          reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
          reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
          reSplitDetails = /,? & /,
          reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
          reEscapeChar = /\\(\\)?/g,
          reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
          reFlags = /\w*$/,
          reIsBadHex = /^[-+]0x[0-9a-f]+$/i,
          reIsBinary = /^0b[01]+$/i,
          reIsHostCtor = /^\[object .+?Constructor\]$/,
          reIsOctal = /^0o[0-7]+$/i,
          reIsUint = /^(?:0|[1-9]\d*)$/,
          reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
          reNoMatch = /($^)/,
          reUnescapedString = /['\n\r\u2028\u2029\\]/g,
          rsComboRange = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",
          rsBreakRange = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
          rsAstral = "[\\ud800-\\udfff]",
          rsBreak = "[" + rsBreakRange + "]",
          rsCombo = "[" + rsComboRange + "]",
          rsDigits = "\\d+",
          rsDingbat = "[\\u2700-\\u27bf]",
          rsLower = "[a-z\\xdf-\\xf6\\xf8-\\xff]",
          rsMisc = "[^\\ud800-\\udfff" + rsBreakRange + rsDigits + "\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]",
          rsFitz = "\\ud83c[\\udffb-\\udfff]",
          rsNonAstral = "[^\\ud800-\\udfff]",
          rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
          rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
          rsUpper = "[A-Z\\xc0-\\xd6\\xd8-\\xde]",
          rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")",
          rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")",
          reOptMod = "(?:" + rsCombo + "|" + rsFitz + ")" + "?",
          rsSeq = "[\\ufe0e\\ufe0f]?" + reOptMod + ("(?:\\u200d(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")[\\ufe0e\\ufe0f]?" + reOptMod + ")*"),
          rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq,
          rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")",
          reApos = RegExp("['’]", "g"),
          reComboMark = RegExp(rsCombo, "g"),
          reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"),
          reUnicodeWord = RegExp([rsUpper + "?" + rsLower + "+(?:['’](?:d|ll|m|re|s|t|ve))?(?=" + [rsBreak, rsUpper, "$"].join("|") + ")", rsMiscUpper + "+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")", rsUpper + "?" + rsMiscLower + "+(?:['’](?:d|ll|m|re|s|t|ve))?", rsUpper + "+(?:['’](?:D|LL|M|RE|S|T|VE))?", "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsDigits, rsEmoji].join("|"), "g"),
          reHasUnicode = RegExp("[\\u200d\\ud800-\\udfff" + rsComboRange + "\\ufe0e\\ufe0f]"),
          reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
          contextProps = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
          templateCounter = -1,
          typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
        var stringEscapes = {
            "\\": "\\",
            "'": "'",
            "\n": "n",
            "\r": "r",
            "\u2028": "u2028",
            "\u2029": "u2029"
          },
          freeParseFloat = parseFloat,
          freeParseInt = parseInt,
          freeGlobal = "object" == typeof global && global && global.Object === Object && global,
          freeSelf = "object" == typeof self && self && self.Object === Object && self,
          root = freeGlobal || freeSelf || Function("return this")(),
          freeExports = "object" == typeof exports && exports && !exports.nodeType && exports,
          freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module,
          moduleExports = freeModule && freeModule.exports === freeExports,
          freeProcess = moduleExports && freeGlobal.process,
          nodeUtil = function () {
            try {
              var types = freeModule && freeModule.require && freeModule.require("util").types;
              return types || freeProcess && freeProcess.binding && freeProcess.binding("util")
            } catch (e) {}
          }(),
          nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
          nodeIsDate = nodeUtil && nodeUtil.isDate,
          nodeIsMap = nodeUtil && nodeUtil.isMap,
          nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
          nodeIsSet = nodeUtil && nodeUtil.isSet,
          nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2])
          }
          return func.apply(thisArg, args)
        }

        function arrayAggregator(array, setter, iteratee, accumulator) {
          for (var index = -1, length = null == array ? 0 : array.length; ++index < length;) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array)
          }
          return accumulator
        }

        function arrayEach(array, iteratee) {
          for (var index = -1, length = null == array ? 0 : array.length; ++index < length && !1 !== iteratee(array[index], index, array););
          return array
        }

        function arrayEachRight(array, iteratee) {
          for (var length = null == array ? 0 : array.length; length-- && !1 !== iteratee(array[length], length, array););
          return array
        }

        function arrayEvery(array, predicate) {
          for (var index = -1, length = null == array ? 0 : array.length; ++index < length;)
            if (!predicate(array[index], index, array)) return !1;
          return !0
        }

        function arrayFilter(array, predicate) {
          for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length;) {
            var value = array[index];
            predicate(value, index, array) && (result[resIndex++] = value)
          }
          return result
        }

        function arrayIncludes(array, value) {
          return !!(null == array ? 0 : array.length) && -1 < baseIndexOf(array, value, 0)
        }

        function arrayIncludesWith(array, value, comparator) {
          for (var index = -1, length = null == array ? 0 : array.length; ++index < length;)
            if (comparator(value, array[index])) return !0;
          return !1
        }

        function arrayMap(array, iteratee) {
          for (var index = -1, length = null == array ? 0 : array.length, result = Array(length); ++index < length;) result[index] = iteratee(array[index], index, array);
          return result
        }

        function arrayPush(array, values) {
          for (var index = -1, length = values.length, offset = array.length; ++index < length;) array[offset + index] = values[index];
          return array
        }

        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1,
            length = null == array ? 0 : array.length;
          for (initAccum && length && (accumulator = array[++index]); ++index < length;) accumulator = iteratee(accumulator, array[index], index, array);
          return accumulator
        }

        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = null == array ? 0 : array.length;
          for (initAccum && length && (accumulator = array[--length]); length--;) accumulator = iteratee(accumulator, array[length], length, array);
          return accumulator
        }

        function arraySome(array, predicate) {
          for (var index = -1, length = null == array ? 0 : array.length; ++index < length;)
            if (predicate(array[index], index, array)) return !0;
          return !1
        }
        var asciiSize = baseProperty("length");

        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          return eachFunc(collection, function (value, key, collection) {
            if (predicate(value, key, collection)) return result = key, !1
          }), result
        }

        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          for (var length = array.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length;)
            if (predicate(array[index], index, array)) return index;
          return -1
        }

        function baseIndexOf(array, value, fromIndex) {
          return value == value ? function (array, value, fromIndex) {
            var index = fromIndex - 1,
              length = array.length;
            for (; ++index < length;)
              if (array[index] === value) return index;
            return -1
          }(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex)
        }

        function baseIndexOfWith(array, value, fromIndex, comparator) {
          for (var index = fromIndex - 1, length = array.length; ++index < length;)
            if (comparator(array[index], value)) return index;
          return -1
        }

        function baseIsNaN(value) {
          return value != value
        }

        function baseMean(array, iteratee) {
          var length = null == array ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN
        }

        function baseProperty(key) {
          return function (object) {
            return null == object ? undefined : object[key]
          }
        }

        function basePropertyOf(object) {
          return function (key) {
            return null == object ? undefined : object[key]
          }
        }

        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          return eachFunc(collection, function (value, index, collection) {
            accumulator = initAccum ? (initAccum = !1, value) : iteratee(accumulator, value, index, collection)
          }), accumulator
        }

        function baseSum(array, iteratee) {
          for (var result, index = -1, length = array.length; ++index < length;) {
            var current = iteratee(array[index]);
            current !== undefined && (result = result === undefined ? current : result + current)
          }
          return result
        }

        function baseTimes(n, iteratee) {
          for (var index = -1, result = Array(n); ++index < n;) result[index] = iteratee(index);
          return result
        }

        function baseUnary(func) {
          return function (value) {
            return func(value)
          }
        }

        function baseValues(object, props) {
          return arrayMap(props, function (key) {
            return object[key]
          })
        }

        function cacheHas(cache, key) {
          return cache.has(key)
        }

        function charsStartIndex(strSymbols, chrSymbols) {
          for (var index = -1, length = strSymbols.length; ++index < length && -1 < baseIndexOf(chrSymbols, strSymbols[index], 0););
          return index
        }

        function charsEndIndex(strSymbols, chrSymbols) {
          for (var index = strSymbols.length; index-- && -1 < baseIndexOf(chrSymbols, strSymbols[index], 0););
          return index
        }
        var deburrLetter = basePropertyOf({
            "À": "A",
            "Á": "A",
            "Â": "A",
            "Ã": "A",
            "Ä": "A",
            "Å": "A",
            "à": "a",
            "á": "a",
            "â": "a",
            "ã": "a",
            "ä": "a",
            "å": "a",
            "Ç": "C",
            "ç": "c",
            "Ð": "D",
            "ð": "d",
            "È": "E",
            "É": "E",
            "Ê": "E",
            "Ë": "E",
            "è": "e",
            "é": "e",
            "ê": "e",
            "ë": "e",
            "Ì": "I",
            "Í": "I",
            "Î": "I",
            "Ï": "I",
            "ì": "i",
            "í": "i",
            "î": "i",
            "ï": "i",
            "Ñ": "N",
            "ñ": "n",
            "Ò": "O",
            "Ó": "O",
            "Ô": "O",
            "Õ": "O",
            "Ö": "O",
            "Ø": "O",
            "ò": "o",
            "ó": "o",
            "ô": "o",
            "õ": "o",
            "ö": "o",
            "ø": "o",
            "Ù": "U",
            "Ú": "U",
            "Û": "U",
            "Ü": "U",
            "ù": "u",
            "ú": "u",
            "û": "u",
            "ü": "u",
            "Ý": "Y",
            "ý": "y",
            "ÿ": "y",
            "Æ": "Ae",
            "æ": "ae",
            "Þ": "Th",
            "þ": "th",
            "ß": "ss",
            "Ā": "A",
            "Ă": "A",
            "Ą": "A",
            "ā": "a",
            "ă": "a",
            "ą": "a",
            "Ć": "C",
            "Ĉ": "C",
            "Ċ": "C",
            "Č": "C",
            "ć": "c",
            "ĉ": "c",
            "ċ": "c",
            "č": "c",
            "Ď": "D",
            "Đ": "D",
            "ď": "d",
            "đ": "d",
            "Ē": "E",
            "Ĕ": "E",
            "Ė": "E",
            "Ę": "E",
            "Ě": "E",
            "ē": "e",
            "ĕ": "e",
            "ė": "e",
            "ę": "e",
            "ě": "e",
            "Ĝ": "G",
            "Ğ": "G",
            "Ġ": "G",
            "Ģ": "G",
            "ĝ": "g",
            "ğ": "g",
            "ġ": "g",
            "ģ": "g",
            "Ĥ": "H",
            "Ħ": "H",
            "ĥ": "h",
            "ħ": "h",
            "Ĩ": "I",
            "Ī": "I",
            "Ĭ": "I",
            "Į": "I",
            "İ": "I",
            "ĩ": "i",
            "ī": "i",
            "ĭ": "i",
            "į": "i",
            "ı": "i",
            "Ĵ": "J",
            "ĵ": "j",
            "Ķ": "K",
            "ķ": "k",
            "ĸ": "k",
            "Ĺ": "L",
            "Ļ": "L",
            "Ľ": "L",
            "Ŀ": "L",
            "Ł": "L",
            "ĺ": "l",
            "ļ": "l",
            "ľ": "l",
            "ŀ": "l",
            "ł": "l",
            "Ń": "N",
            "Ņ": "N",
            "Ň": "N",
            "Ŋ": "N",
            "ń": "n",
            "ņ": "n",
            "ň": "n",
            "ŋ": "n",
            "Ō": "O",
            "Ŏ": "O",
            "Ő": "O",
            "ō": "o",
            "ŏ": "o",
            "ő": "o",
            "Ŕ": "R",
            "Ŗ": "R",
            "Ř": "R",
            "ŕ": "r",
            "ŗ": "r",
            "ř": "r",
            "Ś": "S",
            "Ŝ": "S",
            "Ş": "S",
            "Š": "S",
            "ś": "s",
            "ŝ": "s",
            "ş": "s",
            "š": "s",
            "Ţ": "T",
            "Ť": "T",
            "Ŧ": "T",
            "ţ": "t",
            "ť": "t",
            "ŧ": "t",
            "Ũ": "U",
            "Ū": "U",
            "Ŭ": "U",
            "Ů": "U",
            "Ű": "U",
            "Ų": "U",
            "ũ": "u",
            "ū": "u",
            "ŭ": "u",
            "ů": "u",
            "ű": "u",
            "ų": "u",
            "Ŵ": "W",
            "ŵ": "w",
            "Ŷ": "Y",
            "ŷ": "y",
            "Ÿ": "Y",
            "Ź": "Z",
            "Ż": "Z",
            "Ž": "Z",
            "ź": "z",
            "ż": "z",
            "ž": "z",
            "Ĳ": "IJ",
            "ĳ": "ij",
            "Œ": "Oe",
            "œ": "oe",
            "ŉ": "'n",
            "ſ": "s"
          }),
          escapeHtmlChar = basePropertyOf({
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
          });

        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr]
        }

        function hasUnicode(string) {
          return reHasUnicode.test(string)
        }

        function mapToArray(map) {
          var index = -1,
            result = Array(map.size);
          return map.forEach(function (value, key) {
            result[++index] = [key, value]
          }), result
        }

        function overArg(func, transform) {
          return function (arg) {
            return func(transform(arg))
          }
        }

        function replaceHolders(array, placeholder) {
          for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length;) {
            var value = array[index];
            value !== placeholder && value !== PLACEHOLDER || (array[index] = PLACEHOLDER, result[resIndex++] = index)
          }
          return result
        }

        function setToArray(set) {
          var index = -1,
            result = Array(set.size);
          return set.forEach(function (value) {
            result[++index] = value
          }), result
        }

        function setToPairs(set) {
          var index = -1,
            result = Array(set.size);
          return set.forEach(function (value) {
            result[++index] = [value, value]
          }), result
        }

        function stringSize(string) {
          return hasUnicode(string) ? function (string) {
            var result = reUnicode.lastIndex = 0;
            for (; reUnicode.test(string);) ++result;
            return result
          }(string) : asciiSize(string)
        }

        function stringToArray(string) {
          return hasUnicode(string) ? function (string) {
            return string.match(reUnicode) || []
          }(string) : function (string) {
            return string.split("")
          }(string)
        }
        var unescapeHtmlChar = basePropertyOf({
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        });
        var _ = function runInContext(context) {
          var uid, Array = (context = null == context ? root : _.defaults(root.Object(), context, _.pick(root, contextProps))).Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError,
            arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype,
            coreJsData = context["__core-js_shared__"],
            funcToString = funcProto.toString,
            hasOwnProperty = objectProto.hasOwnProperty,
            idCounter = 0,
            maskSrcKey = (uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "")) ? "Symbol(src)_1." + uid : "",
            nativeObjectToString = objectProto.toString,
            objectCtorString = funcToString.call(Object),
            oldDash = root._,
            reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
            Buffer = moduleExports ? context.Buffer : undefined,
            Symbol = context.Symbol,
            Uint8Array = context.Uint8Array,
            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
            getPrototype = overArg(Object.getPrototypeOf, Object),
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice,
            spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
            symIterator = Symbol ? Symbol.iterator : undefined,
            symToStringTag = Symbol ? Symbol.toStringTag : undefined,
            defineProperty = function () {
              try {
                var func = getNative(Object, "defineProperty");
                return func({}, "", {}), func
              } catch (e) {}
            }(),
            ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
            ctxNow = Date && Date.now !== root.Date.now && Date.now,
            ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout,
            nativeCeil = Math.ceil,
            nativeFloor = Math.floor,
            nativeGetSymbols = Object.getOwnPropertySymbols,
            nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
            nativeIsFinite = context.isFinite,
            nativeJoin = arrayProto.join,
            nativeKeys = overArg(Object.keys, Object),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = Date.now,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random,
            nativeReverse = arrayProto.reverse,
            DataView = getNative(context, "DataView"),
            Map = getNative(context, "Map"),
            Promise = getNative(context, "Promise"),
            Set = getNative(context, "Set"),
            WeakMap = getNative(context, "WeakMap"),
            nativeCreate = getNative(Object, "create"),
            metaMap = WeakMap && new WeakMap,
            realNames = {},
            dataViewCtorString = toSource(DataView),
            mapCtorString = toSource(Map),
            promiseCtorString = toSource(Promise),
            setCtorString = toSource(Set),
            weakMapCtorString = toSource(WeakMap),
            symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
            symbolToString = symbolProto ? symbolProto.toString : undefined;

          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) return value;
              if (hasOwnProperty.call(value, "__wrapped__")) return wrapperClone(value)
            }
            return new LodashWrapper(value)
          }
          var baseCreate = function () {
            function object() {}
            return function (proto) {
              if (!isObject(proto)) return {};
              if (objectCreate) return objectCreate(proto);
              object.prototype = proto;
              var result = new object;
              return object.prototype = undefined, result
            }
          }();

          function baseLodash() {}

          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value, this.__actions__ = [], this.__chain__ = !!chainAll, this.__index__ = 0, this.__values__ = undefined
          }

          function LazyWrapper(value) {
            this.__wrapped__ = value, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = MAX_ARRAY_LENGTH, this.__views__ = []
          }

          function Hash(entries) {
            var index = -1,
              length = null == entries ? 0 : entries.length;
            for (this.clear(); ++index < length;) {
              var entry = entries[index];
              this.set(entry[0], entry[1])
            }
          }

          function ListCache(entries) {
            var index = -1,
              length = null == entries ? 0 : entries.length;
            for (this.clear(); ++index < length;) {
              var entry = entries[index];
              this.set(entry[0], entry[1])
            }
          }

          function MapCache(entries) {
            var index = -1,
              length = null == entries ? 0 : entries.length;
            for (this.clear(); ++index < length;) {
              var entry = entries[index];
              this.set(entry[0], entry[1])
            }
          }

          function SetCache(values) {
            var index = -1,
              length = null == values ? 0 : values.length;
            for (this.__data__ = new MapCache; ++index < length;) this.add(values[index])
          }

          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size
          }

          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value),
              isArg = !isArr && isArguments(value),
              isBuff = !isArr && !isArg && isBuffer(value),
              isType = !isArr && !isArg && !isBuff && isTypedArray(value),
              skipIndexes = isArr || isArg || isBuff || isType,
              result = skipIndexes ? baseTimes(value.length, String) : [],
              length = result.length;
            for (var key in value) !inherited && !hasOwnProperty.call(value, key) || skipIndexes && ("length" == key || isBuff && ("offset" == key || "parent" == key) || isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || isIndex(key, length)) || result.push(key);
            return result
          }

          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined
          }

          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length))
          }

          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array))
          }

          function assignMergeValue(object, key, value) {
            (value === undefined || eq(object[key], value)) && (value !== undefined || key in object) || baseAssignValue(object, key, value)
          }

          function assignValue(object, key, value) {
            var objValue = object[key];
            hasOwnProperty.call(object, key) && eq(objValue, value) && (value !== undefined || key in object) || baseAssignValue(object, key, value)
          }

          function assocIndexOf(array, key) {
            for (var length = array.length; length--;)
              if (eq(array[length][0], key)) return length;
            return -1
          }

          function baseAggregator(collection, setter, iteratee, accumulator) {
            return baseEach(collection, function (value, key, collection) {
              setter(accumulator, value, iteratee(value), collection)
            }), accumulator
          }

          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object)
          }

          function baseAssignValue(object, key, value) {
            "__proto__" == key && defineProperty ? defineProperty(object, key, {
              configurable: !0,
              enumerable: !0,
              value: value,
              writable: !0
            }) : object[key] = value
          }

          function baseAt(object, paths) {
            for (var index = -1, length = paths.length, result = Array(length), skip = null == object; ++index < length;) result[index] = skip ? undefined : get(object, paths[index]);
            return result
          }

          function baseClamp(number, lower, upper) {
            return number == number && (upper !== undefined && (number = number <= upper ? number : upper), lower !== undefined && (number = lower <= number ? number : lower)), number
          }

          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result, isDeep = bitmask & CLONE_DEEP_FLAG,
              isFlat = bitmask & CLONE_FLAT_FLAG,
              isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer && (result = object ? customizer(value, key, object, stack) : customizer(value)), result !== undefined) return result;
            if (!isObject(value)) return value;
            var isArr = isArray(value);
            if (isArr) {
              if (result = function (array) {
                  var length = array.length,
                    result = new array.constructor(length);
                  return length && "string" == typeof array[0] && hasOwnProperty.call(array, "index") && (result.index = array.index, result.input = array.input), result
                }(value), !isDeep) return copyArray(value, result)
            } else {
              var tag = getTag(value),
                isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) return cloneBuffer(value, isDeep);
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                if (result = isFlat || isFunc ? {} : initCloneObject(value), !isDeep) return isFlat ? function (source, object) {
                  return copyObject(source, getSymbolsIn(source), object)
                }(value, function (object, source) {
                  return object && copyObject(source, keysIn(source), object)
                }(result, value)) : function (source, object) {
                  return copyObject(source, getSymbols(source), object)
                }(value, baseAssign(result, value))
              } else {
                if (!cloneableTags[tag]) return object ? value : {};
                result = function (object, tag, isDeep) {
                  var symbol, regexp, result, Ctor = object.constructor;
                  switch (tag) {
                    case arrayBufferTag:
                      return cloneArrayBuffer(object);
                    case boolTag:
                    case dateTag:
                      return new Ctor(+object);
                    case dataViewTag:
                      return function (dataView, isDeep) {
                        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength)
                      }(object, isDeep);
                    case float32Tag:
                    case float64Tag:
                    case int8Tag:
                    case int16Tag:
                    case int32Tag:
                    case uint8Tag:
                    case uint8ClampedTag:
                    case uint16Tag:
                    case uint32Tag:
                      return cloneTypedArray(object, isDeep);
                    case mapTag:
                      return new Ctor;
                    case numberTag:
                    case stringTag:
                      return new Ctor(object);
                    case regexpTag:
                      return (result = new(regexp = object).constructor(regexp.source, reFlags.exec(regexp))).lastIndex = regexp.lastIndex, result;
                    case setTag:
                      return new Ctor;
                    case symbolTag:
                      return symbol = object, symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}
                  }
                }(value, tag, isDeep)
              }
            }
            stack || (stack = new Stack);
            var stacked = stack.get(value);
            if (stacked) return stacked;
            if (stack.set(value, result), isSet(value)) return value.forEach(function (subValue) {
              result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))
            }), result;
            if (isMap(value)) return value.forEach(function (subValue, key) {
              result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))
            }), result;
            var props = isArr ? undefined : (isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys)(value);
            return arrayEach(props || value, function (subValue, key) {
              props && (subValue = value[key = subValue]), assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))
            }), result
          }

          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (null == object) return !length;
            for (object = Object(object); length--;) {
              var key = props[length],
                predicate = source[key],
                value = object[key];
              if (value === undefined && !(key in object) || !predicate(value)) return !1
            }
            return !0
          }

          function baseDelay(func, wait, args) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return setTimeout(function () {
              func.apply(undefined, args)
            }, wait)
          }

          function baseDifference(array, values, iteratee, comparator) {
            var index = -1,
              includes = arrayIncludes,
              isCommon = !0,
              length = array.length,
              result = [],
              valuesLength = values.length;
            if (!length) return result;
            iteratee && (values = arrayMap(values, baseUnary(iteratee))), comparator ? (includes = arrayIncludesWith, isCommon = !1) : values.length >= LARGE_ARRAY_SIZE && (includes = cacheHas, isCommon = !1, values = new SetCache(values));
            outer: for (; ++index < length;) {
              var value = array[index],
                computed = null == iteratee ? value : iteratee(value);
              if (value = comparator || 0 !== value ? value : 0, isCommon && computed == computed) {
                for (var valuesIndex = valuesLength; valuesIndex--;)
                  if (values[valuesIndex] === computed) continue outer;
                result.push(value)
              } else includes(values, computed, comparator) || result.push(value)
            }
            return result
          }
          lodash.templateSettings = {
            escape: reEscape,
            evaluate: reEvaluate,
            interpolate: reInterpolate,
            variable: "",
            imports: {
              _: lodash
            }
          }, (lodash.prototype = baseLodash.prototype).constructor = lodash, (LodashWrapper.prototype = baseCreate(baseLodash.prototype)).constructor = LodashWrapper, (LazyWrapper.prototype = baseCreate(baseLodash.prototype)).constructor = LazyWrapper, Hash.prototype.clear = function () {
            this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0
          }, Hash.prototype.delete = function (key) {
            var result = this.has(key) && delete this.__data__[key];
            return this.size -= result ? 1 : 0, result
          }, Hash.prototype.get = function (key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? undefined : result
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined
          }, Hash.prototype.has = function (key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key)
          }, Hash.prototype.set = function (key, value) {
            var data = this.__data__;
            return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value, this
          }, ListCache.prototype.clear = function () {
            this.__data__ = [], this.size = 0
          }, ListCache.prototype.delete = function (key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            return !(index < 0 || (index == data.length - 1 ? data.pop() : splice.call(data, index, 1), --this.size, 0))
          }, ListCache.prototype.get = function (key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1]
          }, ListCache.prototype.has = function (key) {
            return -1 < assocIndexOf(this.__data__, key)
          }, ListCache.prototype.set = function (key, value) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            return index < 0 ? (++this.size, data.push([key, value])) : data[index][1] = value, this
          }, MapCache.prototype.clear = function () {
            this.size = 0, this.__data__ = {
              hash: new Hash,
              map: new(Map || ListCache),
              string: new Hash
            }
          }, MapCache.prototype.delete = function (key) {
            var result = getMapData(this, key).delete(key);
            return this.size -= result ? 1 : 0, result
          }, MapCache.prototype.get = function (key) {
            return getMapData(this, key).get(key)
          }, MapCache.prototype.has = function (key) {
            return getMapData(this, key).has(key)
          }, MapCache.prototype.set = function (key, value) {
            var data = getMapData(this, key),
              size = data.size;
            return data.set(key, value), this.size += data.size == size ? 0 : 1, this
          }, SetCache.prototype.add = SetCache.prototype.push = function (value) {
            return this.__data__.set(value, HASH_UNDEFINED), this
          }, SetCache.prototype.has = function (value) {
            return this.__data__.has(value)
          }, Stack.prototype.clear = function () {
            this.__data__ = new ListCache, this.size = 0
          }, Stack.prototype.delete = function (key) {
            var data = this.__data__,
              result = data.delete(key);
            return this.size = data.size, result
          }, Stack.prototype.get = function (key) {
            return this.__data__.get(key)
          }, Stack.prototype.has = function (key) {
            return this.__data__.has(key)
          }, Stack.prototype.set = function (key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) return pairs.push([key, value]), this.size = ++data.size, this;
              data = this.__data__ = new MapCache(pairs)
            }
            return data.set(key, value), this.size = data.size, this
          };
          var baseEach = createBaseEach(baseForOwn),
            baseEachRight = createBaseEach(baseForOwnRight, !0);

          function baseEvery(collection, predicate) {
            var result = !0;
            return baseEach(collection, function (value, index, collection) {
              return result = !!predicate(value, index, collection)
            }), result
          }

          function baseExtremum(array, iteratee, comparator) {
            for (var index = -1, length = array.length; ++index < length;) {
              var value = array[index],
                current = iteratee(value);
              if (null != current && (computed === undefined ? current == current && !isSymbol(current) : comparator(current, computed))) var computed = current,
                result = value
            }
            return result
          }

          function baseFilter(collection, predicate) {
            var result = [];
            return baseEach(collection, function (value, index, collection) {
              predicate(value, index, collection) && result.push(value)
            }), result
          }

          function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1,
              length = array.length;
            for (predicate || (predicate = isFlattenable), result || (result = []); ++index < length;) {
              var value = array[index];
              0 < depth && predicate(value) ? 1 < depth ? baseFlatten(value, depth - 1, predicate, isStrict, result) : arrayPush(result, value) : isStrict || (result[result.length] = value)
            }
            return result
          }
          var baseFor = createBaseFor(),
            baseForRight = createBaseFor(!0);

          function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys)
          }

          function baseForOwnRight(object, iteratee) {
            return object && baseForRight(object, iteratee, keys)
          }

          function baseFunctions(object, props) {
            return arrayFilter(props, function (key) {
              return isFunction(object[key])
            })
          }

          function baseGet(object, path) {
            for (var index = 0, length = (path = castPath(path, object)).length; null != object && index < length;) object = object[toKey(path[index++])];
            return index && index == length ? object : undefined
          }

          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object))
          }

          function baseGetTag(value) {
            return null == value ? value === undefined ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? function (value) {
              var isOwn = hasOwnProperty.call(value, symToStringTag),
                tag = value[symToStringTag];
              try {
                value[symToStringTag] = undefined;
                var unmasked = !0
              } catch (e) {}
              var result = nativeObjectToString.call(value);
              return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result
            }(value) : function (value) {
              return nativeObjectToString.call(value)
            }(value)
          }

          function baseGt(value, other) {
            return other < value
          }

          function baseHas(object, key) {
            return null != object && hasOwnProperty.call(object, key)
          }

          function baseHasIn(object, key) {
            return null != object && key in Object(object)
          }

          function baseIntersection(arrays, iteratee, comparator) {
            for (var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = 1 / 0, result = []; othIndex--;) {
              var array = arrays[othIndex];
              othIndex && iteratee && (array = arrayMap(array, baseUnary(iteratee))), maxLength = nativeMin(array.length, maxLength), caches[othIndex] = !comparator && (iteratee || 120 <= length && 120 <= array.length) ? new SetCache(othIndex && array) : undefined
            }
            array = arrays[0];
            var index = -1,
              seen = caches[0];
            outer: for (; ++index < length && result.length < maxLength;) {
              var value = array[index],
                computed = iteratee ? iteratee(value) : value;
              if (value = comparator || 0 !== value ? value : 0, !(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                for (othIndex = othLength; --othIndex;) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) continue outer
                }
                seen && seen.push(computed), result.push(value)
              }
            }
            return result
          }

          function baseInvoke(object, path, args) {
            var func = null == (object = parent(object, path = castPath(path, object))) ? object : object[toKey(last(path))];
            return null == func ? undefined : apply(func, object, args)
          }

          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag
          }

          function baseIsEqual(value, other, bitmask, customizer, stack) {
            return value === other || (null == value || null == other || !isObjectLike(value) && !isObjectLike(other) ? value != value && other != other : function (object, other, bitmask, customizer, equalFunc, stack) {
              var objIsArr = isArray(object),
                othIsArr = isArray(other),
                objTag = objIsArr ? arrayTag : getTag(object),
                othTag = othIsArr ? arrayTag : getTag(other),
                objIsObj = (objTag = objTag == argsTag ? objectTag : objTag) == objectTag,
                othIsObj = (othTag = othTag == argsTag ? objectTag : othTag) == objectTag,
                isSameTag = objTag == othTag;
              if (isSameTag && isBuffer(object)) {
                if (!isBuffer(other)) return !1;
                objIsObj = !(objIsArr = !0)
              }
              if (isSameTag && !objIsObj) return stack || (stack = new Stack), objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : function (object, other, tag, bitmask, customizer, equalFunc, stack) {
                switch (tag) {
                  case dataViewTag:
                    if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return !1;
                    object = object.buffer, other = other.buffer;
                  case arrayBufferTag:
                    return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other)));
                  case boolTag:
                  case dateTag:
                  case numberTag:
                    return eq(+object, +other);
                  case errorTag:
                    return object.name == other.name && object.message == other.message;
                  case regexpTag:
                  case stringTag:
                    return object == other + "";
                  case mapTag:
                    var convert = mapToArray;
                  case setTag:
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                    if (convert || (convert = setToArray), object.size != other.size && !isPartial) return !1;
                    var stacked = stack.get(object);
                    if (stacked) return stacked == other;
                    bitmask |= COMPARE_UNORDERED_FLAG, stack.set(object, other);
                    var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                    return stack.delete(object), result;
                  case symbolTag:
                    if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other)
                }
                return !1
              }(object, other, objTag, bitmask, customizer, equalFunc, stack);
              if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"),
                  othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                if (objIsWrapped || othIsWrapped) {
                  var objUnwrapped = objIsWrapped ? object.value() : object,
                    othUnwrapped = othIsWrapped ? other.value() : other;
                  return stack || (stack = new Stack), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack)
                }
              }
              return !!isSameTag && (stack || (stack = new Stack), function (object, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                  objProps = getAllKeys(object),
                  objLength = objProps.length,
                  othLength = getAllKeys(other).length;
                if (objLength != othLength && !isPartial) return !1;
                for (var index = objLength; index--;) {
                  var key = objProps[index];
                  if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return !1
                }
                var stacked = stack.get(object);
                if (stacked && stack.get(other)) return stacked == other;
                var result = !0;
                stack.set(object, other), stack.set(other, object);
                for (var skipCtor = isPartial; ++index < objLength;) {
                  key = objProps[index];
                  var objValue = object[key],
                    othValue = other[key];
                  if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                  if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                    result = !1;
                    break
                  }
                  skipCtor || (skipCtor = "constructor" == key)
                }
                if (result && !skipCtor) {
                  var objCtor = object.constructor,
                    othCtor = other.constructor;
                  objCtor != othCtor && "constructor" in object && "constructor" in other && !("function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor) && (result = !1)
                }
                return stack.delete(object), stack.delete(other), result
              }(object, other, bitmask, customizer, equalFunc, stack))
            }(value, other, bitmask, customizer, baseIsEqual, stack))
          }

          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length,
              length = index,
              noCustomizer = !customizer;
            if (null == object) return !length;
            for (object = Object(object); index--;) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return !1
            }
            for (; ++index < length;) {
              var key = (data = matchData[index])[0],
                objValue = object[key],
                srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined && !(key in object)) return !1
              } else {
                var stack = new Stack;
                if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);
                if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) return !1
              }
            }
            return !0
          }

          function baseIsNative(value) {
            return !(!isObject(value) || (func = value, maskSrcKey && maskSrcKey in func)) && (isFunction(value) ? reIsNative : reIsHostCtor).test(toSource(value));
            var func
          }

          function baseIteratee(value) {
            return "function" == typeof value ? value : null == value ? identity : "object" == typeof value ? isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value) : property(value)
          }

          function baseKeys(object) {
            if (!isPrototype(object)) return nativeKeys(object);
            var result = [];
            for (var key in Object(object)) hasOwnProperty.call(object, key) && "constructor" != key && result.push(key);
            return result
          }

          function baseKeysIn(object) {
            if (!isObject(object)) return function (object) {
              var result = [];
              if (null != object)
                for (var key in Object(object)) result.push(key);
              return result
            }(object);
            var isProto = isPrototype(object),
              result = [];
            for (var key in object)("constructor" != key || !isProto && hasOwnProperty.call(object, key)) && result.push(key);
            return result
          }

          function baseLt(value, other) {
            return value < other
          }

          function baseMap(collection, iteratee) {
            var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];
            return baseEach(collection, function (value, key, collection) {
              result[++index] = iteratee(value, key, collection)
            }), result
          }

          function baseMatches(source) {
            var matchData = getMatchData(source);
            return 1 == matchData.length && matchData[0][2] ? matchesStrictComparable(matchData[0][0], matchData[0][1]) : function (object) {
              return object === source || baseIsMatch(object, source, matchData)
            }
          }

          function baseMatchesProperty(path, srcValue) {
            return isKey(path) && isStrictComparable(srcValue) ? matchesStrictComparable(toKey(path), srcValue) : function (object) {
              var objValue = get(object, path);
              return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)
            }
          }

          function baseMerge(object, source, srcIndex, customizer, stack) {
            object !== source && baseFor(source, function (srcValue, key) {
              if (isObject(srcValue)) stack || (stack = new Stack),
                function (object, source, key, srcIndex, mergeFunc, customizer, stack) {
                  var objValue = safeGet(object, key),
                    srcValue = safeGet(source, key),
                    stacked = stack.get(srcValue);
                  if (stacked) return assignMergeValue(object, key, stacked);
                  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined,
                    isCommon = newValue === undefined;
                  if (isCommon) {
                    var isArr = isArray(srcValue),
                      isBuff = !isArr && isBuffer(srcValue),
                      isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                    newValue = srcValue, isArr || isBuff || isTyped ? newValue = isArray(objValue) ? objValue : isArrayLikeObject(objValue) ? copyArray(objValue) : isBuff ? cloneBuffer(srcValue, !(isCommon = !1)) : isTyped ? cloneTypedArray(srcValue, !(isCommon = !1)) : [] : isPlainObject(srcValue) || isArguments(srcValue) ? isArguments(newValue = objValue) ? newValue = toPlainObject(objValue) : isObject(objValue) && !isFunction(objValue) || (newValue = initCloneObject(srcValue)) : isCommon = !1
                  }
                  isCommon && (stack.set(srcValue, newValue), mergeFunc(newValue, srcValue, srcIndex, customizer, stack), stack.delete(srcValue)), assignMergeValue(object, key, newValue)
                }(object, source, key, srcIndex, baseMerge, customizer, stack);
              else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined;
                newValue === undefined && (newValue = srcValue), assignMergeValue(object, key, newValue)
              }
            }, keysIn)
          }

          function baseNth(array, n) {
            var length = array.length;
            if (length) return isIndex(n += n < 0 ? length : 0, length) ? array[n] : undefined
          }

          function baseOrderBy(collection, iteratees, orders) {
            var index = -1;
            return iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee())),
              function (array, comparer) {
                var length = array.length;
                for (array.sort(comparer); length--;) array[length] = array[length].value;
                return array
              }(baseMap(collection, function (value, key, collection) {
                return {
                  criteria: arrayMap(iteratees, function (iteratee) {
                    return iteratee(value)
                  }),
                  index: ++index,
                  value: value
                }
              }), function (object, other) {
                return function (object, other, orders) {
                  for (var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; ++index < length;) {
                    var result = compareAscending(objCriteria[index], othCriteria[index]);
                    if (result) {
                      if (ordersLength <= index) return result;
                      var order = orders[index];
                      return result * ("desc" == order ? -1 : 1)
                    }
                  }
                  return object.index - other.index
                }(object, other, orders)
              })
          }

          function basePickBy(object, paths, predicate) {
            for (var index = -1, length = paths.length, result = {}; ++index < length;) {
              var path = paths[index],
                value = baseGet(object, path);
              predicate(value, path) && baseSet(result, castPath(path, object), value)
            }
            return result
          }

          function basePullAll(array, values, iteratee, comparator) {
            var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
              index = -1,
              length = values.length,
              seen = array;
            for (array === values && (values = copyArray(values)), iteratee && (seen = arrayMap(array, baseUnary(iteratee))); ++index < length;)
              for (var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value; - 1 < (fromIndex = indexOf(seen, computed, fromIndex, comparator));) seen !== array && splice.call(seen, fromIndex, 1), splice.call(array, fromIndex, 1);
            return array
          }

          function basePullAt(array, indexes) {
            for (var length = array ? indexes.length : 0, lastIndex = length - 1; length--;) {
              var index = indexes[length];
              if (length == lastIndex || index !== previous) {
                var previous = index;
                isIndex(index) ? splice.call(array, index, 1) : baseUnset(array, index)
              }
            }
            return array
          }

          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1))
          }

          function baseRepeat(string, n) {
            var result = "";
            if (!string || n < 1 || MAX_SAFE_INTEGER < n) return result;
            for (; n % 2 && (result += string), (n = nativeFloor(n / 2)) && (string += string), n;);
            return result
          }

          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "")
          }

          function baseSample(collection) {
            return arraySample(values(collection))
          }

          function baseSampleSize(collection, n) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length))
          }

          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) return object;
            for (var index = -1, length = (path = castPath(path, object)).length, lastIndex = length - 1, nested = object; null != nested && ++index < length;) {
              var key = toKey(path[index]),
                newValue = value;
              if (index != lastIndex) {
                var objValue = nested[key];
                (newValue = customizer ? customizer(objValue, key, nested) : undefined) === undefined && (newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {})
              }
              assignValue(nested, key, newValue), nested = nested[key]
            }
            return object
          }
          var baseSetData = metaMap ? function (func, data) {
              return metaMap.set(func, data), func
            } : identity,
            baseSetToString = defineProperty ? function (func, string) {
              return defineProperty(func, "toString", {
                configurable: !0,
                enumerable: !1,
                value: constant(string),
                writable: !0
              })
            } : identity;

          function baseShuffle(collection) {
            return shuffleSelf(values(collection))
          }

          function baseSlice(array, start, end) {
            var index = -1,
              length = array.length;
            start < 0 && (start = length < -start ? 0 : length + start), (end = length < end ? length : end) < 0 && (end += length), length = end < start ? 0 : end - start >>> 0, start >>>= 0;
            for (var result = Array(length); ++index < length;) result[index] = array[index + start];
            return result
          }

          function baseSome(collection, predicate) {
            var result;
            return baseEach(collection, function (value, index, collection) {
              return !(result = predicate(value, index, collection))
            }), !!result
          }

          function baseSortedIndex(array, value, retHighest) {
            var low = 0,
              high = null == array ? low : array.length;
            if ("number" == typeof value && value == value && high <= HALF_MAX_ARRAY_LENGTH) {
              for (; low < high;) {
                var mid = low + high >>> 1,
                  computed = array[mid];
                null !== computed && !isSymbol(computed) && (retHighest ? computed <= value : computed < value) ? low = mid + 1 : high = mid
              }
              return high
            }
            return baseSortedIndexBy(array, value, identity, retHighest)
          }

          function baseSortedIndexBy(array, value, iteratee, retHighest) {
            value = iteratee(value);
            for (var low = 0, high = null == array ? 0 : array.length, valIsNaN = value != value, valIsNull = null === value, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined; low < high;) {
              var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                othIsDefined = computed !== undefined,
                othIsNull = null === computed,
                othIsReflexive = computed == computed,
                othIsSymbol = isSymbol(computed);
              if (valIsNaN) var setLow = retHighest || othIsReflexive;
              else setLow = valIsUndefined ? othIsReflexive && (retHighest || othIsDefined) : valIsNull ? othIsReflexive && othIsDefined && (retHighest || !othIsNull) : valIsSymbol ? othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol) : !othIsNull && !othIsSymbol && (retHighest ? computed <= value : computed < value);
              setLow ? low = mid + 1 : high = mid
            }
            return nativeMin(high, MAX_ARRAY_INDEX)
          }

          function baseSortedUniq(array, iteratee) {
            for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length;) {
              var value = array[index],
                computed = iteratee ? iteratee(value) : value;
              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result[resIndex++] = 0 === value ? 0 : value
              }
            }
            return result
          }

          function baseToNumber(value) {
            return "number" == typeof value ? value : isSymbol(value) ? NAN : +value
          }

          function baseToString(value) {
            if ("string" == typeof value) return value;
            if (isArray(value)) return arrayMap(value, baseToString) + "";
            if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
            var result = value + "";
            return "0" == result && 1 / value == -INFINITY ? "-0" : result
          }

          function baseUniq(array, iteratee, comparator) {
            var index = -1,
              includes = arrayIncludes,
              length = array.length,
              isCommon = !0,
              result = [],
              seen = result;
            if (comparator) isCommon = !1, includes = arrayIncludesWith;
            else if (LARGE_ARRAY_SIZE <= length) {
              var set = iteratee ? null : createSet(array);
              if (set) return setToArray(set);
              isCommon = !1, includes = cacheHas, seen = new SetCache
            } else seen = iteratee ? [] : result;
            outer: for (; ++index < length;) {
              var value = array[index],
                computed = iteratee ? iteratee(value) : value;
              if (value = comparator || 0 !== value ? value : 0, isCommon && computed == computed) {
                for (var seenIndex = seen.length; seenIndex--;)
                  if (seen[seenIndex] === computed) continue outer;
                iteratee && seen.push(computed), result.push(value)
              } else includes(seen, computed, comparator) || (seen !== result && seen.push(computed), result.push(value))
            }
            return result
          }

          function baseUnset(object, path) {
            return null == (object = parent(object, path = castPath(path, object))) || delete object[toKey(last(path))]
          }

          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer)
          }

          function baseWhile(array, predicate, isDrop, fromRight) {
            for (var length = array.length, index = fromRight ? length : -1;
              (fromRight ? index-- : ++index < length) && predicate(array[index], index, array););
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index)
          }

          function baseWrapperValue(value, actions) {
            var result = value;
            return result instanceof LazyWrapper && (result = result.value()), arrayReduce(actions, function (result, action) {
              return action.func.apply(action.thisArg, arrayPush([result], action.args))
            }, result)
          }

          function baseXor(arrays, iteratee, comparator) {
            var length = arrays.length;
            if (length < 2) return length ? baseUniq(arrays[0]) : [];
            for (var index = -1, result = Array(length); ++index < length;)
              for (var array = arrays[index], othIndex = -1; ++othIndex < length;) othIndex != index && (result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator));
            return baseUniq(baseFlatten(result, 1), iteratee, comparator)
          }

          function baseZipObject(props, values, assignFunc) {
            for (var index = -1, length = props.length, valsLength = values.length, result = {}; ++index < length;) {
              var value = index < valsLength ? values[index] : undefined;
              assignFunc(result, props[index], value)
            }
            return result
          }

          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : []
          }

          function castFunction(value) {
            return "function" == typeof value ? value : identity
          }

          function castPath(value, object) {
            return isArray(value) ? value : isKey(value, object) ? [value] : stringToPath(toString(value))
          }
          var castRest = baseRest;

          function castSlice(array, start, end) {
            var length = array.length;
            return end = end === undefined ? length : end, !start && length <= end ? array : baseSlice(array, start, end)
          }
          var clearTimeout = ctxClearTimeout || function (id) {
            return root.clearTimeout(id)
          };

          function cloneBuffer(buffer, isDeep) {
            if (isDeep) return buffer.slice();
            var length = buffer.length,
              result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            return buffer.copy(result), result
          }

          function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            return new Uint8Array(result).set(new Uint8Array(arrayBuffer)), result
          }

          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length)
          }

          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined,
                valIsNull = null === value,
                valIsReflexive = value == value,
                valIsSymbol = isSymbol(value),
                othIsDefined = other !== undefined,
                othIsNull = null === other,
                othIsReflexive = other == other,
                othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && other < value || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1
            }
            return 0
          }

          function composeArgs(args, partials, holders, isCurried) {
            for (var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried; ++leftIndex < leftLength;) result[leftIndex] = partials[leftIndex];
            for (; ++argsIndex < holdersLength;)(isUncurried || argsIndex < argsLength) && (result[holders[argsIndex]] = args[argsIndex]);
            for (; rangeLength--;) result[leftIndex++] = args[argsIndex++];
            return result
          }

          function composeArgsRight(args, partials, holders, isCurried) {
            for (var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried; ++argsIndex < rangeLength;) result[argsIndex] = args[argsIndex];
            for (var offset = argsIndex; ++rightIndex < rightLength;) result[offset + rightIndex] = partials[rightIndex];
            for (; ++holdersIndex < holdersLength;)(isUncurried || argsIndex < argsLength) && (result[offset + holders[holdersIndex]] = args[argsIndex++]);
            return result
          }

          function copyArray(source, array) {
            var index = -1,
              length = source.length;
            for (array || (array = Array(length)); ++index < length;) array[index] = source[index];
            return array
          }

          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            for (var index = -1, length = props.length; ++index < length;) {
              var key = props[index],
                newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
              newValue === undefined && (newValue = source[key]), isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue)
            }
            return object
          }

          function createAggregator(setter, initializer) {
            return function (collection, iteratee) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator,
                accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee, 2), accumulator)
            }
          }

          function createAssigner(assigner) {
            return baseRest(function (object, sources) {
              var index = -1,
                length = sources.length,
                customizer = 1 < length ? sources[length - 1] : undefined,
                guard = 2 < length ? sources[2] : undefined;
              for (customizer = 3 < assigner.length && "function" == typeof customizer ? (length--, customizer) : undefined, guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = length < 3 ? undefined : customizer, length = 1), object = Object(object); ++index < length;) {
                var source = sources[index];
                source && assigner(object, source, index, customizer)
              }
              return object
            })
          }

          function createBaseEach(eachFunc, fromRight) {
            return function (collection, iteratee) {
              if (null == collection) return collection;
              if (!isArrayLike(collection)) return eachFunc(collection, iteratee);
              for (var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
                (fromRight ? index-- : ++index < length) && !1 !== iteratee(iterable[index], index, iterable););
              return collection
            }
          }

          function createBaseFor(fromRight) {
            return function (object, iteratee, keysFunc) {
              for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--;) {
                var key = props[fromRight ? length : ++index];
                if (!1 === iteratee(iterable[key], key, iterable)) break
              }
              return object
            }
          }

          function createCaseFirst(methodName) {
            return function (string) {
              var strSymbols = hasUnicode(string = toString(string)) ? stringToArray(string) : undefined,
                chr = strSymbols ? strSymbols[0] : string.charAt(0),
                trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing
            }
          }

          function createCompounder(callback) {
            return function (string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "")
            }
          }

          function createCtor(Ctor) {
            return function () {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor;
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6])
              }
              var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);
              return isObject(result) ? result : thisBinding
            }
          }

          function createFind(findIndexFunc) {
            return function (collection, predicate, fromIndex) {
              var iterable = Object(collection);
              if (!isArrayLike(collection)) {
                var iteratee = getIteratee(predicate, 3);
                collection = keys(collection), predicate = function (key) {
                  return iteratee(iterable[key], key, iterable)
                }
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return -1 < index ? iterable[iteratee ? collection[index] : index] : undefined
            }
          }

          function createFlow(fromRight) {
            return flatRest(function (funcs) {
              var length = funcs.length,
                index = length,
                prereq = LodashWrapper.prototype.thru;
              for (fromRight && funcs.reverse(); index--;) {
                var func = funcs[index];
                if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                if (prereq && !wrapper && "wrapper" == getFuncName(func)) var wrapper = new LodashWrapper([], !0)
              }
              for (index = wrapper ? index : length; ++index < length;) {
                var funcName = getFuncName(func = funcs[index]),
                  data = "wrapper" == funcName ? getData(func) : undefined;
                wrapper = data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && 1 == data[9] ? wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : 1 == func.length && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func)
              }
              return function () {
                var args = arguments,
                  value = args[0];
                if (wrapper && 1 == args.length && isArray(value)) return wrapper.plant(value).value();
                for (var index = 0, result = length ? funcs[index].apply(this, args) : value; ++index < length;) result = funcs[index].call(this, result);
                return result
              }
            })
          }

          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG,
              isBind = bitmask & WRAP_BIND_FLAG,
              isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
              isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
              isFlip = bitmask & WRAP_FLIP_FLAG,
              Ctor = isBindKey ? undefined : createCtor(func);
            return function wrapper() {
              for (var length = arguments.length, args = Array(length), index = length; index--;) args[index] = arguments[index];
              if (isCurried) var placeholder = getHolder(wrapper),
                holdersCount = function (array, placeholder) {
                  for (var length = array.length, result = 0; length--;) array[length] === placeholder && ++result;
                  return result
                }(args, placeholder);
              if (partials && (args = composeArgs(args, partials, holders, isCurried)), partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried)), length -= holdersCount, isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length)
              }
              var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;
              return length = args.length, argPos ? args = function (array, indexes) {
                for (var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array); length--;) {
                  var index = indexes[length];
                  array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined
                }
                return array
              }(args, argPos) : isFlip && 1 < length && args.reverse(), isAry && ary < length && (args.length = ary), this && this !== root && this instanceof wrapper && (fn = Ctor || createCtor(fn)), fn.apply(thisBinding, args)
            }
          }

          function createInverter(setter, toIteratee) {
            return function (object, iteratee) {
              return function (object, setter, iteratee, accumulator) {
                return baseForOwn(object, function (value, key, object) {
                  setter(accumulator, iteratee(value), key, object)
                }), accumulator
              }(object, setter, toIteratee(iteratee), {})
            }
          }

          function createMathOperation(operator, defaultValue) {
            return function (value, other) {
              var result;
              if (value === undefined && other === undefined) return defaultValue;
              if (value !== undefined && (result = value), other !== undefined) {
                if (result === undefined) return other;
                "string" == typeof value || "string" == typeof other ? (value = baseToString(value), other = baseToString(other)) : (value = baseToNumber(value), other = baseToNumber(other)), result = operator(value, other)
              }
              return result
            }
          }

          function createOver(arrayFunc) {
            return flatRest(function (iteratees) {
              return iteratees = arrayMap(iteratees, baseUnary(getIteratee())), baseRest(function (args) {
                var thisArg = this;
                return arrayFunc(iteratees, function (iteratee) {
                  return apply(iteratee, thisArg, args)
                })
              })
            })
          }

          function createPadding(length, chars) {
            var charsLength = (chars = chars === undefined ? " " : baseToString(chars)).length;
            if (charsLength < 2) return charsLength ? baseRepeat(chars, length) : chars;
            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length)
          }

          function createRange(fromRight) {
            return function (start, end, step) {
              return step && "number" != typeof step && isIterateeCall(start, end, step) && (end = step = undefined), start = toFinite(start), end === undefined ? (end = start, start = 0) : end = toFinite(end),
                function (start, end, step, fromRight) {
                  for (var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length); length--;) result[fromRight ? length : ++index] = start, start += step;
                  return result
                }(start, end, step = step === undefined ? start < end ? 1 : -1 : toFinite(step), fromRight)
            }
          }

          function createRelationalOperation(operator) {
            return function (value, other) {
              return "string" == typeof value && "string" == typeof other || (value = toNumber(value), other = toNumber(other)), operator(value, other)
            }
          }

          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG, (bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG)) & WRAP_CURRY_BOUND_FLAG || (bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG));
            var newData = [func, bitmask, thisArg, isCurry ? partials : undefined, isCurry ? holders : undefined, isCurry ? undefined : partials, isCurry ? undefined : holders, argPos, ary, arity],
              result = wrapFunc.apply(undefined, newData);
            return isLaziable(func) && setData(result, newData), result.placeholder = placeholder, setWrapToString(result, func, bitmask)
          }

          function createRound(methodName) {
            var func = Math[methodName];
            return function (number, precision) {
              if (number = toNumber(number), precision = null == precision ? 0 : nativeMin(toInteger(precision), 292)) {
                var pair = (toString(number) + "e").split("e");
                return +((pair = (toString(func(pair[0] + "e" + (+pair[1] + precision))) + "e").split("e"))[0] + "e" + (+pair[1] - precision))
              }
              return func(number)
            }
          }
          var createSet = Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY ? function (values) {
            return new Set(values)
          } : noop;

          function createToPairs(keysFunc) {
            return function (object) {
              var tag = getTag(object);
              return tag == mapTag ? mapToArray(object) : tag == setTag ? setToPairs(object) : function (object, props) {
                return arrayMap(props, function (key) {
                  return [key, object[key]]
                })
              }(object, keysFunc(object))
            }
          }

          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && "function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            var length = partials ? partials.length : 0;
            if (length || (bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG), partials = holders = undefined), ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0), arity = arity === undefined ? arity : toInteger(arity), length -= holders ? holders.length : 0, bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials,
                holdersRight = holders;
              partials = holders = undefined
            }
            var data = isBindKey ? undefined : getData(func),
              newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
            if (data && function (data, source) {
                var bitmask = data[1],
                  srcBitmask = source[1],
                  newBitmask = bitmask | srcBitmask,
                  isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG),
                  isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                if (isCommon || isCombo) {
                  srcBitmask & WRAP_BIND_FLAG && (data[2] = source[2], newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG);
                  var value = source[3];
                  if (value) {
                    var partials = data[3];
                    data[3] = partials ? composeArgs(partials, value, source[4]) : value, data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4]
                  }(value = source[5]) && (partials = data[5], data[5] = partials ? composeArgsRight(partials, value, source[6]) : value, data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6]), (value = source[7]) && (data[7] = value), srcBitmask & WRAP_ARY_FLAG && (data[8] = null == data[8] ? source[8] : nativeMin(data[8], source[8])), null == data[9] && (data[9] = source[9]), data[0] = source[0], data[1] = newBitmask
                }
              }(newData, data), func = newData[0], bitmask = newData[1], thisArg = newData[2], partials = newData[3], holders = newData[4], !(arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0)) && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG) && (bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)), bitmask && bitmask != WRAP_BIND_FLAG) result = bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG ? function (func, bitmask, arity) {
              var Ctor = createCtor(func);
              return function wrapper() {
                for (var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper); index--;) args[index] = arguments[index];
                var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                return (length -= holders.length) < arity ? createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length) : apply(this && this !== root && this instanceof wrapper ? Ctor : func, this, args)
              }
            }(func, bitmask, arity) : bitmask != WRAP_PARTIAL_FLAG && bitmask != (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG) || holders.length ? createHybrid.apply(undefined, newData) : function (func, bitmask, thisArg, partials) {
              var isBind = bitmask & WRAP_BIND_FLAG,
                Ctor = createCtor(func);
              return function wrapper() {
                for (var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func; ++leftIndex < leftLength;) args[leftIndex] = partials[leftIndex];
                for (; argsLength--;) args[leftIndex++] = arguments[++argsIndex];
                return apply(fn, isBind ? thisArg : this, args)
              }
            }(func, bitmask, thisArg, partials);
            else var result = function (func, bitmask, thisArg) {
              var isBind = bitmask & WRAP_BIND_FLAG,
                Ctor = createCtor(func);
              return function wrapper() {
                return (this && this !== root && this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, arguments)
              }
            }(func, bitmask, thisArg);
            return setWrapToString((data ? baseSetData : setData)(result, newData), func, bitmask)
          }

          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            return objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key) ? srcValue : objValue
          }

          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            return isObject(objValue) && isObject(srcValue) && (stack.set(srcValue, objValue), baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack), stack.delete(srcValue)), objValue
          }

          function customOmitClone(value) {
            return isPlainObject(value) ? undefined : value
          }

          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              arrLength = array.length,
              othLength = other.length;
            if (arrLength != othLength && !(isPartial && arrLength < othLength)) return !1;
            var stacked = stack.get(array);
            if (stacked && stack.get(other)) return stacked == other;
            var index = -1,
              result = !0,
              seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined;
            for (stack.set(array, other), stack.set(other, array); ++index < arrLength;) {
              var arrValue = array[index],
                othValue = other[index];
              if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              if (compared !== undefined) {
                if (compared) continue;
                result = !1;
                break
              }
              if (seen) {
                if (!arraySome(other, function (othValue, othIndex) {
                    if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex)
                  })) {
                  result = !1;
                  break
                }
              } else if (arrValue !== othValue && !equalFunc(arrValue, othValue, bitmask, customizer, stack)) {
                result = !1;
                break
              }
            }
            return stack.delete(array), stack.delete(other), result
          }

          function flatRest(func) {
            return setToString(overRest(func, undefined, flatten), func + "")
          }

          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols)
          }

          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn)
          }
          var getData = metaMap ? function (func) {
            return metaMap.get(func)
          } : noop;

          function getFuncName(func) {
            for (var result = func.name + "", array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0; length--;) {
              var data = array[length],
                otherFunc = data.func;
              if (null == otherFunc || otherFunc == func) return data.name
            }
            return result
          }

          function getHolder(func) {
            return (hasOwnProperty.call(lodash, "placeholder") ? lodash : func).placeholder
          }

          function getIteratee() {
            var result = lodash.iteratee || iteratee;
            return result = result === iteratee ? baseIteratee : result, arguments.length ? result(arguments[0], arguments[1]) : result
          }

          function getMapData(map, key) {
            var value, type, data = map.__data__;
            return ("string" == (type = typeof (value = key)) || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value) ? data["string" == typeof key ? "string" : "hash"] : data.map
          }

          function getMatchData(object) {
            for (var result = keys(object), length = result.length; length--;) {
              var key = result[length],
                value = object[key];
              result[length] = [key, value, isStrictComparable(value)]
            }
            return result
          }

          function getNative(object, key) {
            var value = function (object, key) {
              return null == object ? undefined : object[key]
            }(object, key);
            return baseIsNative(value) ? value : undefined
          }
          var getSymbols = nativeGetSymbols ? function (object) {
              return null == object ? [] : (object = Object(object), arrayFilter(nativeGetSymbols(object), function (symbol) {
                return propertyIsEnumerable.call(object, symbol)
              }))
            } : stubArray,
            getSymbolsIn = nativeGetSymbols ? function (object) {
              for (var result = []; object;) arrayPush(result, getSymbols(object)), object = getPrototype(object);
              return result
            } : stubArray,
            getTag = baseGetTag;

          function hasPath(object, path, hasFunc) {
            for (var index = -1, length = (path = castPath(path, object)).length, result = !1; ++index < length;) {
              var key = toKey(path[index]);
              if (!(result = null != object && hasFunc(object, key))) break;
              object = object[key]
            }
            return result || ++index != length ? result : !!(length = null == object ? 0 : object.length) && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object))
          }

          function initCloneObject(object) {
            return "function" != typeof object.constructor || isPrototype(object) ? {} : baseCreate(getPrototype(object))
          }

          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol])
          }

          function isIndex(value, length) {
            var type = typeof value;
            return !!(length = null == length ? MAX_SAFE_INTEGER : length) && ("number" == type || "symbol" != type && reIsUint.test(value)) && -1 < value && value % 1 == 0 && value < length
          }

          function isIterateeCall(value, index, object) {
            if (!isObject(object)) return !1;
            var type = typeof index;
            return !!("number" == type ? isArrayLike(object) && isIndex(index, object.length) : "string" == type && index in object) && eq(object[index], value)
          }

          function isKey(value, object) {
            if (isArray(value)) return !1;
            var type = typeof value;
            return !("number" != type && "symbol" != type && "boolean" != type && null != value && !isSymbol(value)) || reIsPlainProp.test(value) || !reIsDeepProp.test(value) || null != object && value in Object(object)
          }

          function isLaziable(func) {
            var funcName = getFuncName(func),
              other = lodash[funcName];
            if ("function" != typeof other || !(funcName in LazyWrapper.prototype)) return !1;
            if (func === other) return !0;
            var data = getData(other);
            return !!data && func === data[0]
          }(DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && "[object Promise]" != getTag(Promise.resolve()) || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) && (getTag = function (value) {
            var result = baseGetTag(value),
              Ctor = result == objectTag ? value.constructor : undefined,
              ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return "[object Promise]";
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag
            }
            return result
          });
          var isMaskable = coreJsData ? isFunction : stubFalse;

          function isPrototype(value) {
            var Ctor = value && value.constructor;
            return value === ("function" == typeof Ctor && Ctor.prototype || objectProto)
          }

          function isStrictComparable(value) {
            return value == value && !isObject(value)
          }

          function matchesStrictComparable(key, srcValue) {
            return function (object) {
              return null != object && object[key] === srcValue && (srcValue !== undefined || key in Object(object))
            }
          }

          function overRest(func, start, transform) {
            return start = nativeMax(start === undefined ? func.length - 1 : start, 0),
              function () {
                for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length;) array[index] = args[start + index];
                index = -1;
                for (var otherArgs = Array(start + 1); ++index < start;) otherArgs[index] = args[index];
                return otherArgs[start] = transform(array), apply(func, this, otherArgs)
              }
          }

          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1))
          }

          function safeGet(object, key) {
            if ("__proto__" != key) return object[key]
          }
          var setData = shortOut(baseSetData),
            setTimeout = ctxSetTimeout || function (func, wait) {
              return root.setTimeout(func, wait)
            },
            setToString = shortOut(baseSetToString);

          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, function (source, details) {
              var length = details.length;
              if (!length) return source;
              var lastIndex = length - 1;
              return details[lastIndex] = (1 < length ? "& " : "") + details[lastIndex], details = details.join(2 < length ? ", " : " "), source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n")
            }(source, function (details, bitmask) {
              return arrayEach(wrapFlags, function (pair) {
                var value = "_." + pair[0];
                bitmask & pair[1] && !arrayIncludes(details, value) && details.push(value)
              }), details.sort()
            }(function (source) {
              var match = source.match(reWrapDetails);
              return match ? match[1].split(reSplitDetails) : []
            }(source), bitmask)))
          }

          function shortOut(func) {
            var count = 0,
              lastCalled = 0;
            return function () {
              var stamp = nativeNow(),
                remaining = HOT_SPAN - (stamp - lastCalled);
              if (lastCalled = stamp, 0 < remaining) {
                if (++count >= HOT_COUNT) return arguments[0]
              } else count = 0;
              return func.apply(undefined, arguments)
            }
          }

          function shuffleSelf(array, size) {
            var index = -1,
              length = array.length,
              lastIndex = length - 1;
            for (size = size === undefined ? length : size; ++index < size;) {
              var rand = baseRandom(index, lastIndex),
                value = array[rand];
              array[rand] = array[index], array[index] = value
            }
            return array.length = size, array
          }
          var stringToPath = function (func) {
            var result = memoize(func, function (key) {
                return cache.size === MAX_MEMOIZE_SIZE && cache.clear(), key
              }),
              cache = result.cache;
            return result
          }(function (string) {
            var result = [];
            return 46 === string.charCodeAt(0) && result.push(""), string.replace(rePropName, function (match, number, quote, subString) {
              result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match)
            }), result
          });

          function toKey(value) {
            if ("string" == typeof value || isSymbol(value)) return value;
            var result = value + "";
            return "0" == result && 1 / value == -INFINITY ? "-0" : result
          }

          function toSource(func) {
            if (null != func) {
              try {
                return funcToString.call(func)
              } catch (e) {}
              try {
                return func + ""
              } catch (e) {}
            }
            return ""
          }

          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) return wrapper.clone();
            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            return result.__actions__ = copyArray(wrapper.__actions__), result.__index__ = wrapper.__index__, result.__values__ = wrapper.__values__, result
          }
          var difference = baseRest(function (array, values) {
              return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0)) : []
            }),
            differenceBy = baseRest(function (array, values) {
              var iteratee = last(values);
              return isArrayLikeObject(iteratee) && (iteratee = undefined), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), getIteratee(iteratee, 2)) : []
            }),
            differenceWith = baseRest(function (array, values) {
              var comparator = last(values);
              return isArrayLikeObject(comparator) && (comparator = undefined), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), undefined, comparator) : []
            });

          function findIndex(array, predicate, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = null == fromIndex ? 0 : toInteger(fromIndex);
            return index < 0 && (index = nativeMax(length + index, 0)), baseFindIndex(array, getIteratee(predicate, 3), index)
          }

          function findLastIndex(array, predicate, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = length - 1;
            return fromIndex !== undefined && (index = toInteger(fromIndex), index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), baseFindIndex(array, getIteratee(predicate, 3), index, !0)
          }

          function flatten(array) {
            return null != array && array.length ? baseFlatten(array, 1) : []
          }

          function head(array) {
            return array && array.length ? array[0] : undefined
          }
          var intersection = baseRest(function (arrays) {
              var mapped = arrayMap(arrays, castArrayLikeObject);
              return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : []
            }),
            intersectionBy = baseRest(function (arrays) {
              var iteratee = last(arrays),
                mapped = arrayMap(arrays, castArrayLikeObject);
              return iteratee === last(mapped) ? iteratee = undefined : mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : []
            }),
            intersectionWith = baseRest(function (arrays) {
              var comparator = last(arrays),
                mapped = arrayMap(arrays, castArrayLikeObject);
              return (comparator = "function" == typeof comparator ? comparator : undefined) && mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : []
            });

          function last(array) {
            var length = null == array ? 0 : array.length;
            return length ? array[length - 1] : undefined
          }
          var pull = baseRest(pullAll);

          function pullAll(array, values) {
            return array && array.length && values && values.length ? basePullAll(array, values) : array
          }
          var pullAt = flatRest(function (array, indexes) {
            var length = null == array ? 0 : array.length,
              result = baseAt(array, indexes);
            return basePullAt(array, arrayMap(indexes, function (index) {
              return isIndex(index, length) ? +index : index
            }).sort(compareAscending)), result
          });

          function reverse(array) {
            return null == array ? array : nativeReverse.call(array)
          }
          var union = baseRest(function (arrays) {
              return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0))
            }),
            unionBy = baseRest(function (arrays) {
              var iteratee = last(arrays);
              return isArrayLikeObject(iteratee) && (iteratee = undefined), baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), getIteratee(iteratee, 2))
            }),
            unionWith = baseRest(function (arrays) {
              var comparator = last(arrays);
              return comparator = "function" == typeof comparator ? comparator : undefined, baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), undefined, comparator)
            });

          function unzip(array) {
            if (!array || !array.length) return [];
            var length = 0;
            return array = arrayFilter(array, function (group) {
              if (isArrayLikeObject(group)) return length = nativeMax(group.length, length), !0
            }), baseTimes(length, function (index) {
              return arrayMap(array, baseProperty(index))
            })
          }

          function unzipWith(array, iteratee) {
            if (!array || !array.length) return [];
            var result = unzip(array);
            return null == iteratee ? result : arrayMap(result, function (group) {
              return apply(iteratee, undefined, group)
            })
          }
          var without = baseRest(function (array, values) {
              return isArrayLikeObject(array) ? baseDifference(array, values) : []
            }),
            xor = baseRest(function (arrays) {
              return baseXor(arrayFilter(arrays, isArrayLikeObject))
            }),
            xorBy = baseRest(function (arrays) {
              var iteratee = last(arrays);
              return isArrayLikeObject(iteratee) && (iteratee = undefined), baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2))
            }),
            xorWith = baseRest(function (arrays) {
              var comparator = last(arrays);
              return comparator = "function" == typeof comparator ? comparator : undefined, baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator)
            }),
            zip = baseRest(unzip);
          var zipWith = baseRest(function (arrays) {
            var length = arrays.length,
              iteratee = 1 < length ? arrays[length - 1] : undefined;
            return unzipWith(arrays, iteratee = "function" == typeof iteratee ? (arrays.pop(), iteratee) : undefined)
          });

          function chain(value) {
            var result = lodash(value);
            return result.__chain__ = !0, result
          }

          function thru(value, interceptor) {
            return interceptor(value)
          }
          var wrapperAt = flatRest(function (paths) {
            var length = paths.length,
              start = length ? paths[0] : 0,
              value = this.__wrapped__,
              interceptor = function (object) {
                return baseAt(object, paths)
              };
            return !(1 < length || this.__actions__.length) && value instanceof LazyWrapper && isIndex(start) ? ((value = value.slice(start, +start + (length ? 1 : 0))).__actions__.push({
              func: thru,
              args: [interceptor],
              thisArg: undefined
            }), new LodashWrapper(value, this.__chain__).thru(function (array) {
              return length && !array.length && array.push(undefined), array
            })) : this.thru(interceptor)
          });
          var countBy = createAggregator(function (result, value, key) {
            hasOwnProperty.call(result, key) ? ++result[key] : baseAssignValue(result, key, 1)
          });
          var find = createFind(findIndex),
            findLast = createFind(findLastIndex);

          function forEach(collection, iteratee) {
            return (isArray(collection) ? arrayEach : baseEach)(collection, getIteratee(iteratee, 3))
          }

          function forEachRight(collection, iteratee) {
            return (isArray(collection) ? arrayEachRight : baseEachRight)(collection, getIteratee(iteratee, 3))
          }
          var groupBy = createAggregator(function (result, value, key) {
            hasOwnProperty.call(result, key) ? result[key].push(value) : baseAssignValue(result, key, [value])
          });
          var invokeMap = baseRest(function (collection, path, args) {
              var index = -1,
                isFunc = "function" == typeof path,
                result = isArrayLike(collection) ? Array(collection.length) : [];
              return baseEach(collection, function (value) {
                result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args)
              }), result
            }),
            keyBy = createAggregator(function (result, value, key) {
              baseAssignValue(result, key, value)
            });

          function map(collection, iteratee) {
            return (isArray(collection) ? arrayMap : baseMap)(collection, getIteratee(iteratee, 3))
          }
          var partition = createAggregator(function (result, value, key) {
            result[key ? 0 : 1].push(value)
          }, function () {
            return [
              [],
              []
            ]
          });
          var sortBy = baseRest(function (collection, iteratees) {
              if (null == collection) return [];
              var length = iteratees.length;
              return 1 < length && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : 2 < length && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [iteratees[0]]), baseOrderBy(collection, baseFlatten(iteratees, 1), [])
            }),
            now = ctxNow || function () {
              return root.Date.now()
            };

          function ary(func, n, guard) {
            return n = guard ? undefined : n, n = func && null == n ? func.length : n, createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n)
          }

          function before(n, func) {
            var result;
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return n = toInteger(n),
              function () {
                return 0 < --n && (result = func.apply(this, arguments)), n <= 1 && (func = undefined), result
              }
          }
          var bind = baseRest(function (func, thisArg, partials) {
              var bitmask = WRAP_BIND_FLAG;
              if (partials.length) {
                var holders = replaceHolders(partials, getHolder(bind));
                bitmask |= WRAP_PARTIAL_FLAG
              }
              return createWrap(func, bitmask, thisArg, partials, holders)
            }),
            bindKey = baseRest(function (object, key, partials) {
              var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
              if (partials.length) {
                var holders = replaceHolders(partials, getHolder(bindKey));
                bitmask |= WRAP_PARTIAL_FLAG
              }
              return createWrap(key, bitmask, object, partials, holders)
            });

          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0,
              leading = !1,
              maxing = !1,
              trailing = !0;
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);

            function invokeFunc(time) {
              var args = lastArgs,
                thisArg = lastThis;
              return lastArgs = lastThis = undefined, lastInvokeTime = time, result = func.apply(thisArg, args)
            }

            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime;
              return lastCallTime === undefined || wait <= timeSinceLastCall || timeSinceLastCall < 0 || maxing && maxWait <= time - lastInvokeTime
            }

            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) return trailingEdge(time);
              timerId = setTimeout(timerExpired, function (time) {
                var timeWaiting = wait - (time - lastCallTime);
                return maxing ? nativeMin(timeWaiting, maxWait - (time - lastInvokeTime)) : timeWaiting
              }(time))
            }

            function trailingEdge(time) {
              return timerId = undefined, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = undefined, result)
            }

            function debounced() {
              var time = now(),
                isInvoking = shouldInvoke(time);
              if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
                if (timerId === undefined) return function (time) {
                  return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result
                }(lastCallTime);
                if (maxing) return timerId = setTimeout(timerExpired, wait), invokeFunc(lastCallTime)
              }
              return timerId === undefined && (timerId = setTimeout(timerExpired, wait)), result
            }
            return wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading, maxWait = (maxing = "maxWait" in options) ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait, trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = function () {
              timerId !== undefined && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = undefined
            }, debounced.flush = function () {
              return timerId === undefined ? result : trailingEdge(now())
            }, debounced
          }
          var defer = baseRest(function (func, args) {
              return baseDelay(func, 1, args)
            }),
            delay = baseRest(function (func, wait, args) {
              return baseDelay(func, toNumber(wait) || 0, args)
            });

          function memoize(func, resolver) {
            if ("function" != typeof func || null != resolver && "function" != typeof resolver) throw new TypeError(FUNC_ERROR_TEXT);
            var memoized = function () {
              var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;
              if (cache.has(key)) return cache.get(key);
              var result = func.apply(this, args);
              return memoized.cache = cache.set(key, result) || cache, result
            };
            return memoized.cache = new(memoize.Cache || MapCache), memoized
          }

          function negate(predicate) {
            if ("function" != typeof predicate) throw new TypeError(FUNC_ERROR_TEXT);
            return function () {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2])
              }
              return !predicate.apply(this, args)
            }
          }
          memoize.Cache = MapCache;
          var overArgs = castRest(function (func, transforms) {
              var funcsLength = (transforms = 1 == transforms.length && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()))).length;
              return baseRest(function (args) {
                for (var index = -1, length = nativeMin(args.length, funcsLength); ++index < length;) args[index] = transforms[index].call(this, args[index]);
                return apply(func, this, args)
              })
            }),
            partial = baseRest(function (func, partials) {
              var holders = replaceHolders(partials, getHolder(partial));
              return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders)
            }),
            partialRight = baseRest(function (func, partials) {
              var holders = replaceHolders(partials, getHolder(partialRight));
              return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders)
            }),
            rearg = flatRest(function (func, indexes) {
              return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes)
            });

          function eq(value, other) {
            return value === other || value != value && other != other
          }
          var gt = createRelationalOperation(baseGt),
            gte = createRelationalOperation(function (value, other) {
              return other <= value
            }),
            isArguments = baseIsArguments(function () {
              return arguments
            }()) ? baseIsArguments : function (value) {
              return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee")
            },
            isArray = Array.isArray,
            isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : function (value) {
              return isObjectLike(value) && baseGetTag(value) == arrayBufferTag
            };

          function isArrayLike(value) {
            return null != value && isLength(value.length) && !isFunction(value)
          }

          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value)
          }
          var isBuffer = nativeIsBuffer || stubFalse,
            isDate = nodeIsDate ? baseUnary(nodeIsDate) : function (value) {
              return isObjectLike(value) && baseGetTag(value) == dateTag
            };

          function isError(value) {
            if (!isObjectLike(value)) return !1;
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || "string" == typeof value.message && "string" == typeof value.name && !isPlainObject(value)
          }

          function isFunction(value) {
            if (!isObject(value)) return !1;
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag
          }

          function isInteger(value) {
            return "number" == typeof value && value == toInteger(value)
          }

          function isLength(value) {
            return "number" == typeof value && -1 < value && value % 1 == 0 && value <= MAX_SAFE_INTEGER
          }

          function isObject(value) {
            var type = typeof value;
            return null != value && ("object" == type || "function" == type)
          }

          function isObjectLike(value) {
            return null != value && "object" == typeof value
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : function (value) {
            return isObjectLike(value) && getTag(value) == mapTag
          };

          function isNumber(value) {
            return "number" == typeof value || isObjectLike(value) && baseGetTag(value) == numberTag
          }

          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) return !1;
            var proto = getPrototype(value);
            if (null === proto) return !0;
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return "function" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : function (value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag
          };
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : function (value) {
            return isObjectLike(value) && getTag(value) == setTag
          };

          function isString(value) {
            return "string" == typeof value || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag
          }

          function isSymbol(value) {
            return "symbol" == typeof value || isObjectLike(value) && baseGetTag(value) == symbolTag
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : function (value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)]
          };
          var lt = createRelationalOperation(baseLt),
            lte = createRelationalOperation(function (value, other) {
              return value <= other
            });

          function toArray(value) {
            if (!value) return [];
            if (isArrayLike(value)) return isString(value) ? stringToArray(value) : copyArray(value);
            if (symIterator && value[symIterator]) return function (iterator) {
              for (var data, result = []; !(data = iterator.next()).done;) result.push(data.value);
              return result
            }(value[symIterator]());
            var tag = getTag(value);
            return (tag == mapTag ? mapToArray : tag == setTag ? setToArray : values)(value)
          }

          function toFinite(value) {
            return value ? (value = toNumber(value)) === INFINITY || value === -INFINITY ? (value < 0 ? -1 : 1) * MAX_INTEGER : value == value ? value : 0 : 0 === value ? value : 0
          }

          function toInteger(value) {
            var result = toFinite(value),
              remainder = result % 1;
            return result == result ? remainder ? result - remainder : result : 0
          }

          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0
          }

          function toNumber(value) {
            if ("number" == typeof value) return value;
            if (isSymbol(value)) return NAN;
            if (isObject(value)) {
              var other = "function" == typeof value.valueOf ? value.valueOf() : value;
              value = isObject(other) ? other + "" : other
            }
            if ("string" != typeof value) return 0 === value ? value : +value;
            value = value.replace(reTrim, "");
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value
          }

          function toPlainObject(value) {
            return copyObject(value, keysIn(value))
          }

          function toString(value) {
            return null == value ? "" : baseToString(value)
          }
          var assign = createAssigner(function (object, source) {
              if (isPrototype(source) || isArrayLike(source)) copyObject(source, keys(source), object);
              else
                for (var key in source) hasOwnProperty.call(source, key) && assignValue(object, key, source[key])
            }),
            assignIn = createAssigner(function (object, source) {
              copyObject(source, keysIn(source), object)
            }),
            assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
              copyObject(source, keysIn(source), object, customizer)
            }),
            assignWith = createAssigner(function (object, source, srcIndex, customizer) {
              copyObject(source, keys(source), object, customizer)
            }),
            at = flatRest(baseAt);
          var defaults = baseRest(function (object, sources) {
              object = Object(object);
              var index = -1,
                length = sources.length,
                guard = 2 < length ? sources[2] : undefined;
              for (guard && isIterateeCall(sources[0], sources[1], guard) && (length = 1); ++index < length;)
                for (var source = sources[index], props = keysIn(source), propsIndex = -1, propsLength = props.length; ++propsIndex < propsLength;) {
                  var key = props[propsIndex],
                    value = object[key];
                  (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) && (object[key] = source[key])
                }
              return object
            }),
            defaultsDeep = baseRest(function (args) {
              return args.push(undefined, customDefaultsMerge), apply(mergeWith, undefined, args)
            });

          function get(object, path, defaultValue) {
            var result = null == object ? undefined : baseGet(object, path);
            return result === undefined ? defaultValue : result
          }

          function hasIn(object, path) {
            return null != object && hasPath(object, path, baseHasIn)
          }
          var invert = createInverter(function (result, value, key) {
              null != value && "function" != typeof value.toString && (value = nativeObjectToString.call(value)), result[value] = key
            }, constant(identity)),
            invertBy = createInverter(function (result, value, key) {
              null != value && "function" != typeof value.toString && (value = nativeObjectToString.call(value)), hasOwnProperty.call(result, value) ? result[value].push(key) : result[value] = [key]
            }, getIteratee),
            invoke = baseRest(baseInvoke);

          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object)
          }

          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object)
          }
          var merge = createAssigner(function (object, source, srcIndex) {
              baseMerge(object, source, srcIndex)
            }),
            mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
              baseMerge(object, source, srcIndex, customizer)
            }),
            omit = flatRest(function (object, paths) {
              var result = {};
              if (null == object) return result;
              var isDeep = !1;
              paths = arrayMap(paths, function (path) {
                return path = castPath(path, object), isDeep || (isDeep = 1 < path.length), path
              }), copyObject(object, getAllKeysIn(object), result), isDeep && (result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
              for (var length = paths.length; length--;) baseUnset(result, paths[length]);
              return result
            });
          var pick = flatRest(function (object, paths) {
            return null == object ? {} : function (object, paths) {
              return basePickBy(object, paths, function (value, path) {
                return hasIn(object, path)
              })
            }(object, paths)
          });

          function pickBy(object, predicate) {
            if (null == object) return {};
            var props = arrayMap(getAllKeysIn(object), function (prop) {
              return [prop]
            });
            return predicate = getIteratee(predicate), basePickBy(object, props, function (value, path) {
              return predicate(value, path[0])
            })
          }
          var toPairs = createToPairs(keys),
            toPairsIn = createToPairs(keysIn);

          function values(object) {
            return null == object ? [] : baseValues(object, keys(object))
          }
          var camelCase = createCompounder(function (result, word, index) {
            return word = word.toLowerCase(), result + (index ? capitalize(word) : word)
          });

          function capitalize(string) {
            return upperFirst(toString(string).toLowerCase())
          }

          function deburr(string) {
            return (string = toString(string)) && string.replace(reLatin, deburrLetter).replace(reComboMark, "")
          }
          var kebabCase = createCompounder(function (result, word, index) {
              return result + (index ? "-" : "") + word.toLowerCase()
            }),
            lowerCase = createCompounder(function (result, word, index) {
              return result + (index ? " " : "") + word.toLowerCase()
            }),
            lowerFirst = createCaseFirst("toLowerCase");
          var snakeCase = createCompounder(function (result, word, index) {
            return result + (index ? "_" : "") + word.toLowerCase()
          });
          var startCase = createCompounder(function (result, word, index) {
            return result + (index ? " " : "") + upperFirst(word)
          });
          var upperCase = createCompounder(function (result, word, index) {
              return result + (index ? " " : "") + word.toUpperCase()
            }),
            upperFirst = createCaseFirst("toUpperCase");

          function words(string, pattern, guard) {
            return string = toString(string), (pattern = guard ? undefined : pattern) === undefined ? function (string) {
              return reHasUnicodeWord.test(string)
            }(string) ? function (string) {
              return string.match(reUnicodeWord) || []
            }(string) : function (string) {
              return string.match(reAsciiWord) || []
            }(string) : string.match(pattern) || []
          }
          var attempt = baseRest(function (func, args) {
              try {
                return apply(func, undefined, args)
              } catch (e) {
                return isError(e) ? e : new Error(e)
              }
            }),
            bindAll = flatRest(function (object, methodNames) {
              return arrayEach(methodNames, function (key) {
                key = toKey(key), baseAssignValue(object, key, bind(object[key], object))
              }), object
            });

          function constant(value) {
            return function () {
              return value
            }
          }
          var flow = createFlow(),
            flowRight = createFlow(!0);

          function identity(value) {
            return value
          }

          function iteratee(func) {
            return baseIteratee("function" == typeof func ? func : baseClone(func, CLONE_DEEP_FLAG))
          }
          var method = baseRest(function (path, args) {
              return function (object) {
                return baseInvoke(object, path, args)
              }
            }),
            methodOf = baseRest(function (object, args) {
              return function (path) {
                return baseInvoke(object, path, args)
              }
            });

          function mixin(object, source, options) {
            var props = keys(source),
              methodNames = baseFunctions(source, props);
            null != options || isObject(source) && (methodNames.length || !props.length) || (options = source, source = object, object = this, methodNames = baseFunctions(source, keys(source)));
            var chain = !(isObject(options) && "chain" in options && !options.chain),
              isFunc = isFunction(object);
            return arrayEach(methodNames, function (methodName) {
              var func = source[methodName];
              object[methodName] = func, isFunc && (object.prototype[methodName] = function () {
                var chainAll = this.__chain__;
                if (chain || chainAll) {
                  var result = object(this.__wrapped__);
                  return (result.__actions__ = copyArray(this.__actions__)).push({
                    func: func,
                    args: arguments,
                    thisArg: object
                  }), result.__chain__ = chainAll, result
                }
                return func.apply(object, arrayPush([this.value()], arguments))
              })
            }), object
          }

          function noop() {}
          var over = createOver(arrayMap),
            overEvery = createOver(arrayEvery),
            overSome = createOver(arraySome);

          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : function (path) {
              return function (object) {
                return baseGet(object, path)
              }
            }(path)
          }
          var range = createRange(),
            rangeRight = createRange(!0);

          function stubArray() {
            return []
          }

          function stubFalse() {
            return !1
          }
          var add = createMathOperation(function (augend, addend) {
              return augend + addend
            }, 0),
            ceil = createRound("ceil"),
            divide = createMathOperation(function (dividend, divisor) {
              return dividend / divisor
            }, 1),
            floor = createRound("floor");
          var source, multiply = createMathOperation(function (multiplier, multiplicand) {
              return multiplier * multiplicand
            }, 1),
            round = createRound("round"),
            subtract = createMathOperation(function (minuend, subtrahend) {
              return minuend - subtrahend
            }, 0);
          return lodash.after = function (n, func) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return n = toInteger(n),
              function () {
                if (--n < 1) return func.apply(this, arguments)
              }
          }, lodash.ary = ary, lodash.assign = assign, lodash.assignIn = assignIn, lodash.assignInWith = assignInWith, lodash.assignWith = assignWith, lodash.at = at, lodash.before = before, lodash.bind = bind, lodash.bindAll = bindAll, lodash.bindKey = bindKey, lodash.castArray = function () {
            if (!arguments.length) return [];
            var value = arguments[0];
            return isArray(value) ? value : [value]
          }, lodash.chain = chain, lodash.chunk = function (array, size, guard) {
            size = (guard ? isIterateeCall(array, size, guard) : size === undefined) ? 1 : nativeMax(toInteger(size), 0);
            var length = null == array ? 0 : array.length;
            if (!length || size < 1) return [];
            for (var index = 0, resIndex = 0, result = Array(nativeCeil(length / size)); index < length;) result[resIndex++] = baseSlice(array, index, index += size);
            return result
          }, lodash.compact = function (array) {
            for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length;) {
              var value = array[index];
              value && (result[resIndex++] = value)
            }
            return result
          }, lodash.concat = function () {
            var length = arguments.length;
            if (!length) return [];
            for (var args = Array(length - 1), array = arguments[0], index = length; index--;) args[index - 1] = arguments[index];
            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1))
          }, lodash.cond = function (pairs) {
            var length = null == pairs ? 0 : pairs.length,
              toIteratee = getIteratee();
            return pairs = length ? arrayMap(pairs, function (pair) {
              if ("function" != typeof pair[1]) throw new TypeError(FUNC_ERROR_TEXT);
              return [toIteratee(pair[0]), pair[1]]
            }) : [], baseRest(function (args) {
              for (var index = -1; ++index < length;) {
                var pair = pairs[index];
                if (apply(pair[0], this, args)) return apply(pair[1], this, args)
              }
            })
          }, lodash.conforms = function (source) {
            return function (source) {
              var props = keys(source);
              return function (object) {
                return baseConformsTo(object, source, props)
              }
            }(baseClone(source, CLONE_DEEP_FLAG))
          }, lodash.constant = constant, lodash.countBy = countBy, lodash.create = function (prototype, properties) {
            var result = baseCreate(prototype);
            return null == properties ? result : baseAssign(result, properties)
          }, lodash.curry = function curry(func, arity, guard) {
            var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity = guard ? undefined : arity);
            return result.placeholder = curry.placeholder, result
          }, lodash.curryRight = function curryRight(func, arity, guard) {
            var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity = guard ? undefined : arity);
            return result.placeholder = curryRight.placeholder, result
          }, lodash.debounce = debounce, lodash.defaults = defaults, lodash.defaultsDeep = defaultsDeep, lodash.defer = defer, lodash.delay = delay, lodash.difference = difference, lodash.differenceBy = differenceBy, lodash.differenceWith = differenceWith, lodash.drop = function (array, n, guard) {
            var length = null == array ? 0 : array.length;
            return length ? baseSlice(array, (n = guard || n === undefined ? 1 : toInteger(n)) < 0 ? 0 : n, length) : []
          }, lodash.dropRight = function (array, n, guard) {
            var length = null == array ? 0 : array.length;
            return length ? baseSlice(array, 0, (n = length - (n = guard || n === undefined ? 1 : toInteger(n))) < 0 ? 0 : n) : []
          }, lodash.dropRightWhile = function (array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0, !0) : []
          }, lodash.dropWhile = function (array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0) : []
          }, lodash.fill = function (array, value, start, end) {
            var length = null == array ? 0 : array.length;
            return length ? (start && "number" != typeof start && isIterateeCall(array, value, start) && (start = 0, end = length), function (array, value, start, end) {
              var length = array.length;
              for ((start = toInteger(start)) < 0 && (start = length < -start ? 0 : length + start), (end = end === undefined || length < end ? length : toInteger(end)) < 0 && (end += length), end = end < start ? 0 : toLength(end); start < end;) array[start++] = value;
              return array
            }(array, value, start, end)) : []
          }, lodash.filter = function (collection, predicate) {
            return (isArray(collection) ? arrayFilter : baseFilter)(collection, getIteratee(predicate, 3))
          }, lodash.flatMap = function (collection, iteratee) {
            return baseFlatten(map(collection, iteratee), 1)
          }, lodash.flatMapDeep = function (collection, iteratee) {
            return baseFlatten(map(collection, iteratee), INFINITY)
          }, lodash.flatMapDepth = function (collection, iteratee, depth) {
            return depth = depth === undefined ? 1 : toInteger(depth), baseFlatten(map(collection, iteratee), depth)
          }, lodash.flatten = flatten, lodash.flattenDeep = function (array) {
            return null != array && array.length ? baseFlatten(array, INFINITY) : []
          }, lodash.flattenDepth = function (array, depth) {
            return null != array && array.length ? baseFlatten(array, depth = depth === undefined ? 1 : toInteger(depth)) : []
          }, lodash.flip = function (func) {
            return createWrap(func, WRAP_FLIP_FLAG)
          }, lodash.flow = flow, lodash.flowRight = flowRight, lodash.fromPairs = function (pairs) {
            for (var index = -1, length = null == pairs ? 0 : pairs.length, result = {}; ++index < length;) {
              var pair = pairs[index];
              result[pair[0]] = pair[1]
            }
            return result
          }, lodash.functions = function (object) {
            return null == object ? [] : baseFunctions(object, keys(object))
          }, lodash.functionsIn = function (object) {
            return null == object ? [] : baseFunctions(object, keysIn(object))
          }, lodash.groupBy = groupBy, lodash.initial = function (array) {
            return null != array && array.length ? baseSlice(array, 0, -1) : []
          }, lodash.intersection = intersection, lodash.intersectionBy = intersectionBy, lodash.intersectionWith = intersectionWith, lodash.invert = invert, lodash.invertBy = invertBy, lodash.invokeMap = invokeMap, lodash.iteratee = iteratee, lodash.keyBy = keyBy, lodash.keys = keys, lodash.keysIn = keysIn, lodash.map = map, lodash.mapKeys = function (object, iteratee) {
            var result = {};
            return iteratee = getIteratee(iteratee, 3), baseForOwn(object, function (value, key, object) {
              baseAssignValue(result, iteratee(value, key, object), value)
            }), result
          }, lodash.mapValues = function (object, iteratee) {
            var result = {};
            return iteratee = getIteratee(iteratee, 3), baseForOwn(object, function (value, key, object) {
              baseAssignValue(result, key, iteratee(value, key, object))
            }), result
          }, lodash.matches = function (source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG))
          }, lodash.matchesProperty = function (path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG))
          }, lodash.memoize = memoize, lodash.merge = merge, lodash.mergeWith = mergeWith, lodash.method = method, lodash.methodOf = methodOf, lodash.mixin = mixin, lodash.negate = negate, lodash.nthArg = function (n) {
            return n = toInteger(n), baseRest(function (args) {
              return baseNth(args, n)
            })
          }, lodash.omit = omit, lodash.omitBy = function (object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)))
          }, lodash.once = function (func) {
            return before(2, func)
          }, lodash.orderBy = function (collection, iteratees, orders, guard) {
            return null == collection ? [] : (isArray(iteratees) || (iteratees = null == iteratees ? [] : [iteratees]), isArray(orders = guard ? undefined : orders) || (orders = null == orders ? [] : [orders]), baseOrderBy(collection, iteratees, orders))
          }, lodash.over = over, lodash.overArgs = overArgs, lodash.overEvery = overEvery, lodash.overSome = overSome, lodash.partial = partial, lodash.partialRight = partialRight, lodash.partition = partition, lodash.pick = pick, lodash.pickBy = pickBy, lodash.property = property, lodash.propertyOf = function (object) {
            return function (path) {
              return null == object ? undefined : baseGet(object, path)
            }
          }, lodash.pull = pull, lodash.pullAll = pullAll, lodash.pullAllBy = function (array, values, iteratee) {
            return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array
          }, lodash.pullAllWith = function (array, values, comparator) {
            return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array
          }, lodash.pullAt = pullAt, lodash.range = range, lodash.rangeRight = rangeRight, lodash.rearg = rearg, lodash.reject = function (collection, predicate) {
            return (isArray(collection) ? arrayFilter : baseFilter)(collection, negate(getIteratee(predicate, 3)))
          }, lodash.remove = function (array, predicate) {
            var result = [];
            if (!array || !array.length) return result;
            var index = -1,
              indexes = [],
              length = array.length;
            for (predicate = getIteratee(predicate, 3); ++index < length;) {
              var value = array[index];
              predicate(value, index, array) && (result.push(value), indexes.push(index))
            }
            return basePullAt(array, indexes), result
          }, lodash.rest = function (func, start) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return baseRest(func, start = start === undefined ? start : toInteger(start))
          }, lodash.reverse = reverse, lodash.sampleSize = function (collection, n, guard) {
            return n = (guard ? isIterateeCall(collection, n, guard) : n === undefined) ? 1 : toInteger(n), (isArray(collection) ? arraySampleSize : baseSampleSize)(collection, n)
          }, lodash.set = function (object, path, value) {
            return null == object ? object : baseSet(object, path, value)
          }, lodash.setWith = function (object, path, value, customizer) {
            return customizer = "function" == typeof customizer ? customizer : undefined, null == object ? object : baseSet(object, path, value, customizer)
          }, lodash.shuffle = function (collection) {
            return (isArray(collection) ? arrayShuffle : baseShuffle)(collection)
          }, lodash.slice = function (array, start, end) {
            var length = null == array ? 0 : array.length;
            return length ? (end && "number" != typeof end && isIterateeCall(array, start, end) ? (start = 0, end = length) : (start = null == start ? 0 : toInteger(start), end = end === undefined ? length : toInteger(end)), baseSlice(array, start, end)) : []
          }, lodash.sortBy = sortBy, lodash.sortedUniq = function (array) {
            return array && array.length ? baseSortedUniq(array) : []
          }, lodash.sortedUniqBy = function (array, iteratee) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : []
          }, lodash.split = function (string, separator, limit) {
            return limit && "number" != typeof limit && isIterateeCall(string, separator, limit) && (separator = limit = undefined), (limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0) ? (string = toString(string)) && ("string" == typeof separator || null != separator && !isRegExp(separator)) && !(separator = baseToString(separator)) && hasUnicode(string) ? castSlice(stringToArray(string), 0, limit) : string.split(separator, limit) : []
          }, lodash.spread = function (func, start) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return start = null == start ? 0 : nativeMax(toInteger(start), 0), baseRest(function (args) {
              var array = args[start],
                otherArgs = castSlice(args, 0, start);
              return array && arrayPush(otherArgs, array), apply(func, this, otherArgs)
            })
          }, lodash.tail = function (array) {
            var length = null == array ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : []
          }, lodash.take = function (array, n, guard) {
            return array && array.length ? baseSlice(array, 0, (n = guard || n === undefined ? 1 : toInteger(n)) < 0 ? 0 : n) : []
          }, lodash.takeRight = function (array, n, guard) {
            var length = null == array ? 0 : array.length;
            return length ? baseSlice(array, (n = length - (n = guard || n === undefined ? 1 : toInteger(n))) < 0 ? 0 : n, length) : []
          }, lodash.takeRightWhile = function (array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !1, !0) : []
          }, lodash.takeWhile = function (array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : []
          }, lodash.tap = function (value, interceptor) {
            return interceptor(value), value
          }, lodash.throttle = function (func, wait, options) {
            var leading = !0,
              trailing = !0;
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return isObject(options) && (leading = "leading" in options ? !!options.leading : leading, trailing = "trailing" in options ? !!options.trailing : trailing), debounce(func, wait, {
              leading: leading,
              maxWait: wait,
              trailing: trailing
            })
          }, lodash.thru = thru, lodash.toArray = toArray, lodash.toPairs = toPairs, lodash.toPairsIn = toPairsIn, lodash.toPath = function (value) {
            return isArray(value) ? arrayMap(value, toKey) : isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)))
          }, lodash.toPlainObject = toPlainObject, lodash.transform = function (object, iteratee, accumulator) {
            var isArr = isArray(object),
              isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            if (iteratee = getIteratee(iteratee, 4), null == accumulator) {
              var Ctor = object && object.constructor;
              accumulator = isArrLike ? isArr ? new Ctor : [] : isObject(object) && isFunction(Ctor) ? baseCreate(getPrototype(object)) : {}
            }
            return (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
              return iteratee(accumulator, value, index, object)
            }), accumulator
          }, lodash.unary = function (func) {
            return ary(func, 1)
          }, lodash.union = union, lodash.unionBy = unionBy, lodash.unionWith = unionWith, lodash.uniq = function (array) {
            return array && array.length ? baseUniq(array) : []
          }, lodash.uniqBy = function (array, iteratee) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : []
          }, lodash.uniqWith = function (array, comparator) {
            return comparator = "function" == typeof comparator ? comparator : undefined, array && array.length ? baseUniq(array, undefined, comparator) : []
          }, lodash.unset = function (object, path) {
            return null == object || baseUnset(object, path)
          }, lodash.unzip = unzip, lodash.unzipWith = unzipWith, lodash.update = function (object, path, updater) {
            return null == object ? object : baseUpdate(object, path, castFunction(updater))
          }, lodash.updateWith = function (object, path, updater, customizer) {
            return customizer = "function" == typeof customizer ? customizer : undefined, null == object ? object : baseUpdate(object, path, castFunction(updater), customizer)
          }, lodash.values = values, lodash.valuesIn = function (object) {
            return null == object ? [] : baseValues(object, keysIn(object))
          }, lodash.without = without, lodash.words = words, lodash.wrap = function (value, wrapper) {
            return partial(castFunction(wrapper), value)
          }, lodash.xor = xor, lodash.xorBy = xorBy, lodash.xorWith = xorWith, lodash.zip = zip, lodash.zipObject = function (props, values) {
            return baseZipObject(props || [], values || [], assignValue)
          }, lodash.zipObjectDeep = function (props, values) {
            return baseZipObject(props || [], values || [], baseSet)
          }, lodash.zipWith = zipWith, lodash.entries = toPairs, lodash.entriesIn = toPairsIn, lodash.extend = assignIn, lodash.extendWith = assignInWith, mixin(lodash, lodash), lodash.add = add, lodash.attempt = attempt, lodash.camelCase = camelCase, lodash.capitalize = capitalize, lodash.ceil = ceil, lodash.clamp = function (number, lower, upper) {
            return upper === undefined && (upper = lower, lower = undefined), upper !== undefined && (upper = (upper = toNumber(upper)) == upper ? upper : 0), lower !== undefined && (lower = (lower = toNumber(lower)) == lower ? lower : 0), baseClamp(toNumber(number), lower, upper)
          }, lodash.clone = function (value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG)
          }, lodash.cloneDeep = function (value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)
          }, lodash.cloneDeepWith = function (value, customizer) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer = "function" == typeof customizer ? customizer : undefined)
          }, lodash.cloneWith = function (value, customizer) {
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer = "function" == typeof customizer ? customizer : undefined)
          }, lodash.conformsTo = function (object, source) {
            return null == source || baseConformsTo(object, source, keys(source))
          }, lodash.deburr = deburr, lodash.defaultTo = function (value, defaultValue) {
            return null == value || value != value ? defaultValue : value
          }, lodash.divide = divide, lodash.endsWith = function (string, target, position) {
            string = toString(string), target = baseToString(target);
            var length = string.length,
              end = position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
            return 0 <= (position -= target.length) && string.slice(position, end) == target
          }, lodash.eq = eq, lodash.escape = function (string) {
            return (string = toString(string)) && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string
          }, lodash.escapeRegExp = function (string) {
            return (string = toString(string)) && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string
          }, lodash.every = function (collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined), func(collection, getIteratee(predicate, 3))
          }, lodash.find = find, lodash.findIndex = findIndex, lodash.findKey = function (object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn)
          }, lodash.findLast = findLast, lodash.findLastIndex = findLastIndex, lodash.findLastKey = function (object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight)
          }, lodash.floor = floor, lodash.forEach = forEach, lodash.forEachRight = forEachRight, lodash.forIn = function (object, iteratee) {
            return null == object ? object : baseFor(object, getIteratee(iteratee, 3), keysIn)
          }, lodash.forInRight = function (object, iteratee) {
            return null == object ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn)
          }, lodash.forOwn = function (object, iteratee) {
            return object && baseForOwn(object, getIteratee(iteratee, 3))
          }, lodash.forOwnRight = function (object, iteratee) {
            return object && baseForOwnRight(object, getIteratee(iteratee, 3))
          }, lodash.get = get, lodash.gt = gt, lodash.gte = gte, lodash.has = function (object, path) {
            return null != object && hasPath(object, path, baseHas)
          }, lodash.hasIn = hasIn, lodash.head = head, lodash.identity = identity, lodash.includes = function (collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection), fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            return fromIndex < 0 && (fromIndex = nativeMax(length + fromIndex, 0)), isString(collection) ? fromIndex <= length && -1 < collection.indexOf(value, fromIndex) : !!length && -1 < baseIndexOf(collection, value, fromIndex)
          }, lodash.indexOf = function (array, value, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = null == fromIndex ? 0 : toInteger(fromIndex);
            return index < 0 && (index = nativeMax(length + index, 0)), baseIndexOf(array, value, index)
          }, lodash.inRange = function (number, start, end) {
            return start = toFinite(start), end === undefined ? (end = start, start = 0) : end = toFinite(end),
              function (number, start, end) {
                return number >= nativeMin(start, end) && number < nativeMax(start, end)
              }(number = toNumber(number), start, end)
          }, lodash.invoke = invoke, lodash.isArguments = isArguments, lodash.isArray = isArray, lodash.isArrayBuffer = isArrayBuffer, lodash.isArrayLike = isArrayLike, lodash.isArrayLikeObject = isArrayLikeObject, lodash.isBoolean = function (value) {
            return !0 === value || !1 === value || isObjectLike(value) && baseGetTag(value) == boolTag
          }, lodash.isBuffer = isBuffer, lodash.isDate = isDate, lodash.isElement = function (value) {
            return isObjectLike(value) && 1 === value.nodeType && !isPlainObject(value)
          }, lodash.isEmpty = function (value) {
            if (null == value) return !0;
            if (isArrayLike(value) && (isArray(value) || "string" == typeof value || "function" == typeof value.splice || isBuffer(value) || isTypedArray(value) || isArguments(value))) return !value.length;
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) return !value.size;
            if (isPrototype(value)) return !baseKeys(value).length;
            for (var key in value)
              if (hasOwnProperty.call(value, key)) return !1;
            return !0
          }, lodash.isEqual = function (value, other) {
            return baseIsEqual(value, other)
          }, lodash.isEqualWith = function (value, other, customizer) {
            var result = (customizer = "function" == typeof customizer ? customizer : undefined) ? customizer(value, other) : undefined;
            return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result
          }, lodash.isError = isError, lodash.isFinite = function (value) {
            return "number" == typeof value && nativeIsFinite(value)
          }, lodash.isFunction = isFunction, lodash.isInteger = isInteger, lodash.isLength = isLength, lodash.isMap = isMap, lodash.isMatch = function (object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source))
          }, lodash.isMatchWith = function (object, source, customizer) {
            return customizer = "function" == typeof customizer ? customizer : undefined, baseIsMatch(object, source, getMatchData(source), customizer)
          }, lodash.isNaN = function (value) {
            return isNumber(value) && value != +value
          }, lodash.isNative = function (value) {
            if (isMaskable(value)) throw new Error(CORE_ERROR_TEXT);
            return baseIsNative(value)
          }, lodash.isNil = function (value) {
            return null == value
          }, lodash.isNull = function (value) {
            return null === value
          }, lodash.isNumber = isNumber, lodash.isObject = isObject, lodash.isObjectLike = isObjectLike, lodash.isPlainObject = isPlainObject, lodash.isRegExp = isRegExp, lodash.isSafeInteger = function (value) {
            return isInteger(value) && -MAX_SAFE_INTEGER <= value && value <= MAX_SAFE_INTEGER
          }, lodash.isSet = isSet, lodash.isString = isString, lodash.isSymbol = isSymbol, lodash.isTypedArray = isTypedArray, lodash.isUndefined = function (value) {
            return value === undefined
          }, lodash.isWeakMap = function (value) {
            return isObjectLike(value) && getTag(value) == weakMapTag
          }, lodash.isWeakSet = function (value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag
          }, lodash.join = function (array, separator) {
            return null == array ? "" : nativeJoin.call(array, separator)
          }, lodash.kebabCase = kebabCase, lodash.last = last, lodash.lastIndexOf = function (array, value, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = length;
            return fromIndex !== undefined && (index = (index = toInteger(fromIndex)) < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), value == value ? function (array, value, fromIndex) {
              for (var index = fromIndex + 1; index--;)
                if (array[index] === value) return index;
              return index
            }(array, value, index) : baseFindIndex(array, baseIsNaN, index, !0)
          }, lodash.lowerCase = lowerCase, lodash.lowerFirst = lowerFirst, lodash.lt = lt, lodash.lte = lte, lodash.max = function (array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined
          }, lodash.maxBy = function (array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined
          }, lodash.mean = function (array) {
            return baseMean(array, identity)
          }, lodash.meanBy = function (array, iteratee) {
            return baseMean(array, getIteratee(iteratee, 2))
          }, lodash.min = function (array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined
          }, lodash.minBy = function (array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined
          }, lodash.stubArray = stubArray, lodash.stubFalse = stubFalse, lodash.stubObject = function () {
            return {}
          }, lodash.stubString = function () {
            return ""
          }, lodash.stubTrue = function () {
            return !0
          }, lodash.multiply = multiply, lodash.nth = function (array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined
          }, lodash.noConflict = function () {
            return root._ === this && (root._ = oldDash), this
          }, lodash.noop = noop, lodash.now = now, lodash.pad = function (string, length, chars) {
            string = toString(string);
            var strLength = (length = toInteger(length)) ? stringSize(string) : 0;
            if (!length || length <= strLength) return string;
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars)
          }, lodash.padEnd = function (string, length, chars) {
            string = toString(string);
            var strLength = (length = toInteger(length)) ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string
          }, lodash.padStart = function (string, length, chars) {
            string = toString(string);
            var strLength = (length = toInteger(length)) ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string
          }, lodash.parseInt = function (string, radix, guard) {
            return guard || null == radix ? radix = 0 : radix && (radix = +radix), nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0)
          }, lodash.random = function (lower, upper, floating) {
            if (floating && "boolean" != typeof floating && isIterateeCall(lower, upper, floating) && (upper = floating = undefined), floating === undefined && ("boolean" == typeof upper ? (floating = upper, upper = undefined) : "boolean" == typeof lower && (floating = lower, lower = undefined)), lower === undefined && upper === undefined ? (lower = 0, upper = 1) : (lower = toFinite(lower), upper === undefined ? (upper = lower, lower = 0) : upper = toFinite(upper)), upper < lower) {
              var temp = lower;
              lower = upper, upper = temp
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper)
            }
            return baseRandom(lower, upper)
          }, lodash.reduce = function (collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce,
              initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach)
          }, lodash.reduceRight = function (collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce,
              initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight)
          }, lodash.repeat = function (string, n, guard) {
            return n = (guard ? isIterateeCall(string, n, guard) : n === undefined) ? 1 : toInteger(n), baseRepeat(toString(string), n)
          }, lodash.replace = function () {
            var args = arguments,
              string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2])
          }, lodash.result = function (object, path, defaultValue) {
            var index = -1,
              length = (path = castPath(path, object)).length;
            for (length || (length = 1, object = undefined); ++index < length;) {
              var value = null == object ? undefined : object[toKey(path[index])];
              value === undefined && (index = length, value = defaultValue), object = isFunction(value) ? value.call(object) : value
            }
            return object
          }, lodash.round = round, lodash.runInContext = runInContext, lodash.sample = function (collection) {
            return (isArray(collection) ? arraySample : baseSample)(collection)
          }, lodash.size = function (collection) {
            if (null == collection) return 0;
            if (isArrayLike(collection)) return isString(collection) ? stringSize(collection) : collection.length;
            var tag = getTag(collection);
            return tag == mapTag || tag == setTag ? collection.size : baseKeys(collection).length
          }, lodash.snakeCase = snakeCase, lodash.some = function (collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined), func(collection, getIteratee(predicate, 3))
          }, lodash.sortedIndex = function (array, value) {
            return baseSortedIndex(array, value)
          }, lodash.sortedIndexBy = function (array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2))
          }, lodash.sortedIndexOf = function (array, value) {
            var length = null == array ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value);
              if (index < length && eq(array[index], value)) return index
            }
            return -1
          }, lodash.sortedLastIndex = function (array, value) {
            return baseSortedIndex(array, value, !0)
          }, lodash.sortedLastIndexBy = function (array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), !0)
          }, lodash.sortedLastIndexOf = function (array, value) {
            if (null != array && array.length) {
              var index = baseSortedIndex(array, value, !0) - 1;
              if (eq(array[index], value)) return index
            }
            return -1
          }, lodash.startCase = startCase, lodash.startsWith = function (string, target, position) {
            return string = toString(string), position = null == position ? 0 : baseClamp(toInteger(position), 0, string.length), target = baseToString(target), string.slice(position, position + target.length) == target
          }, lodash.subtract = subtract, lodash.sum = function (array) {
            return array && array.length ? baseSum(array, identity) : 0
          }, lodash.sumBy = function (array, iteratee) {
            return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0
          }, lodash.template = function (string, options, guard) {
            var settings = lodash.templateSettings;
            guard && isIterateeCall(string, options, guard) && (options = undefined), string = toString(string), options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var isEscaping, isEvaluating, imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys),
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '",
              reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g"),
              sourceURL = "//# sourceURL=" + ("sourceURL" in options ? options.sourceURL : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              return interpolateValue || (interpolateValue = esTemplateValue), source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar), escapeValue && (isEscaping = !0, source += "' +\n__e(" + escapeValue + ") +\n'"), evaluateValue && (isEvaluating = !0, source += "';\n" + evaluateValue + ";\n__p += '"), interpolateValue && (source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"), index = offset + match.length, match
            }), source += "';\n";
            var variable = options.variable;
            variable || (source = "with (obj) {\n" + source + "\n}\n"), source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"), source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result = attempt(function () {
              return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues)
            });
            if (result.source = source, isError(result)) throw result;
            return result
          }, lodash.times = function (n, iteratee) {
            if ((n = toInteger(n)) < 1 || MAX_SAFE_INTEGER < n) return [];
            var index = MAX_ARRAY_LENGTH,
              length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee = getIteratee(iteratee), n -= MAX_ARRAY_LENGTH;
            for (var result = baseTimes(length, iteratee); ++index < n;) iteratee(index);
            return result
          }, lodash.toFinite = toFinite, lodash.toInteger = toInteger, lodash.toLength = toLength, lodash.toLower = function (value) {
            return toString(value).toLowerCase()
          }, lodash.toNumber = toNumber, lodash.toSafeInteger = function (value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : 0 === value ? value : 0
          }, lodash.toString = toString, lodash.toUpper = function (value) {
            return toString(value).toUpperCase()
          }, lodash.trim = function (string, chars, guard) {
            if ((string = toString(string)) && (guard || chars === undefined)) return string.replace(reTrim, "");
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string),
              chrSymbols = stringToArray(chars);
            return castSlice(strSymbols, charsStartIndex(strSymbols, chrSymbols), charsEndIndex(strSymbols, chrSymbols) + 1).join("")
          }, lodash.trimEnd = function (string, chars, guard) {
            if ((string = toString(string)) && (guard || chars === undefined)) return string.replace(reTrimEnd, "");
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string);
            return castSlice(strSymbols, 0, charsEndIndex(strSymbols, stringToArray(chars)) + 1).join("")
          }, lodash.trimStart = function (string, chars, guard) {
            if ((string = toString(string)) && (guard || chars === undefined)) return string.replace(reTrimStart, "");
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string);
            return castSlice(strSymbols, charsStartIndex(strSymbols, stringToArray(chars))).join("")
          }, lodash.truncate = function (string, options) {
            var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length, omission = "omission" in options ? baseToString(options.omission) : omission
            }
            var strLength = (string = toString(string)).length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length
            }
            if (strLength <= length) return string;
            var end = length - stringSize(omission);
            if (end < 1) return omission;
            var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined) return result + omission;
            if (strSymbols && (end += result.length - end), isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result;
                for (separator.global || (separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g")), separator.lastIndex = 0; match = separator.exec(substring);) var newEnd = match.index;
                result = result.slice(0, newEnd === undefined ? end : newEnd)
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result.lastIndexOf(separator); - 1 < index && (result = result.slice(0, index))
            }
            return result + omission
          }, lodash.unescape = function (string) {
            return (string = toString(string)) && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string
          }, lodash.uniqueId = function (prefix) {
            var id = ++idCounter;
            return toString(prefix) + id
          }, lodash.upperCase = upperCase, lodash.upperFirst = upperFirst, lodash.each = forEach, lodash.eachRight = forEachRight, lodash.first = head, mixin(lodash, (source = {}, baseForOwn(lodash, function (func, methodName) {
            hasOwnProperty.call(lodash.prototype, methodName) || (source[methodName] = func)
          }), source), {
            chain: !1
          }), lodash.VERSION = "4.17.11", arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (methodName) {
            lodash[methodName].placeholder = lodash
          }), arrayEach(["drop", "take"], function (methodName, index) {
            LazyWrapper.prototype[methodName] = function (n) {
              n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
              var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              return result.__filtered__ ? result.__takeCount__ = nativeMin(n, result.__takeCount__) : result.__views__.push({
                size: nativeMin(n, MAX_ARRAY_LENGTH),
                type: methodName + (result.__dir__ < 0 ? "Right" : "")
              }), result
            }, LazyWrapper.prototype[methodName + "Right"] = function (n) {
              return this.reverse()[methodName](n).reverse()
            }
          }), arrayEach(["filter", "map", "takeWhile"], function (methodName, index) {
            var type = index + 1,
              isFilter = type == LAZY_FILTER_FLAG || 3 == type;
            LazyWrapper.prototype[methodName] = function (iteratee) {
              var result = this.clone();
              return result.__iteratees__.push({
                iteratee: getIteratee(iteratee, 3),
                type: type
              }), result.__filtered__ = result.__filtered__ || isFilter, result
            }
          }), arrayEach(["head", "last"], function (methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function () {
              return this[takeName](1).value()[0]
            }
          }), arrayEach(["initial", "tail"], function (methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function () {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1)
            }
          }), LazyWrapper.prototype.compact = function () {
            return this.filter(identity)
          }, LazyWrapper.prototype.find = function (predicate) {
            return this.filter(predicate).head()
          }, LazyWrapper.prototype.findLast = function (predicate) {
            return this.reverse().find(predicate)
          }, LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
            return "function" == typeof path ? new LazyWrapper(this) : this.map(function (value) {
              return baseInvoke(value, path, args)
            })
          }), LazyWrapper.prototype.reject = function (predicate) {
            return this.filter(negate(getIteratee(predicate)))
          }, LazyWrapper.prototype.slice = function (start, end) {
            start = toInteger(start);
            var result = this;
            return result.__filtered__ && (0 < start || end < 0) ? new LazyWrapper(result) : (start < 0 ? result = result.takeRight(-start) : start && (result = result.drop(start)), end !== undefined && (result = (end = toInteger(end)) < 0 ? result.dropRight(-end) : result.take(end - start)), result)
          }, LazyWrapper.prototype.takeRightWhile = function (predicate) {
            return this.reverse().takeWhile(predicate).reverse()
          }, LazyWrapper.prototype.toArray = function () {
            return this.take(MAX_ARRAY_LENGTH)
          }, baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
              isTaker = /^(?:head|last)$/.test(methodName),
              lodashFunc = lodash[isTaker ? "take" + ("last" == methodName ? "Right" : "") : methodName],
              retUnwrapped = isTaker || /^find/.test(methodName);
            lodashFunc && (lodash.prototype[methodName] = function () {
              var value = this.__wrapped__,
                args = isTaker ? [1] : arguments,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value),
                interceptor = function (value) {
                  var result = lodashFunc.apply(lodash, arrayPush([value], args));
                  return isTaker && chainAll ? result[0] : result
                };
              useLazy && checkIteratee && "function" == typeof iteratee && 1 != iteratee.length && (isLazy = useLazy = !1);
              var chainAll = this.__chain__,
                isHybrid = !!this.__actions__.length,
                isUnwrapped = retUnwrapped && !chainAll,
                onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result = func.apply(value, args);
                return result.__actions__.push({
                  func: thru,
                  args: [interceptor],
                  thisArg: undefined
                }), new LodashWrapper(result, chainAll)
              }
              return isUnwrapped && onlyLazy ? func.apply(this, args) : (result = this.thru(interceptor), isUnwrapped ? isTaker ? result.value()[0] : result.value() : result)
            })
          }), arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function (methodName) {
            var func = arrayProto[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru",
              retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function () {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args)
              }
              return this[chainName](function (value) {
                return func.apply(isArray(value) ? value : [], args)
              })
            }
          }), baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              (realNames[key] || (realNames[key] = [])).push({
                name: methodName,
                func: lodashFunc
              })
            }
          }), realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
            name: "wrapper",
            func: undefined
          }], LazyWrapper.prototype.clone = function () {
            var result = new LazyWrapper(this.__wrapped__);
            return result.__actions__ = copyArray(this.__actions__), result.__dir__ = this.__dir__, result.__filtered__ = this.__filtered__, result.__iteratees__ = copyArray(this.__iteratees__), result.__takeCount__ = this.__takeCount__, result.__views__ = copyArray(this.__views__), result
          }, LazyWrapper.prototype.reverse = function () {
            if (this.__filtered__) {
              var result = new LazyWrapper(this);
              result.__dir__ = -1, result.__filtered__ = !0
            } else(result = this.clone()).__dir__ *= -1;
            return result
          }, LazyWrapper.prototype.value = function () {
            var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = function (start, end, transforms) {
                for (var index = -1, length = transforms.length; ++index < length;) {
                  var data = transforms[index],
                    size = data.size;
                  switch (data.type) {
                    case "drop":
                      start += size;
                      break;
                    case "dropRight":
                      end -= size;
                      break;
                    case "take":
                      end = nativeMin(end, start + size);
                      break;
                    case "takeRight":
                      start = nativeMax(start, end - size)
                  }
                }
                return {
                  start: start,
                  end: end
                }
              }(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : start - 1,
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) return baseWrapperValue(array, this.__actions__);
            var result = [];
            outer: for (; length-- && resIndex < takeCount;) {
              for (var iterIndex = -1, value = array[index += dir]; ++iterIndex < iterLength;) {
                var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);
                if (type == LAZY_MAP_FLAG) value = computed;
                else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) continue outer;
                  break outer
                }
              }
              result[resIndex++] = value
            }
            return result
          }, lodash.prototype.at = wrapperAt, lodash.prototype.chain = function () {
            return chain(this)
          }, lodash.prototype.commit = function () {
            return new LodashWrapper(this.value(), this.__chain__)
          }, lodash.prototype.next = function () {
            this.__values__ === undefined && (this.__values__ = toArray(this.value()));
            var done = this.__index__ >= this.__values__.length;
            return {
              done: done,
              value: done ? undefined : this.__values__[this.__index__++]
            }
          }, lodash.prototype.plant = function (value) {
            for (var result, parent = this; parent instanceof baseLodash;) {
              var clone = wrapperClone(parent);
              clone.__index__ = 0, clone.__values__ = undefined, result ? previous.__wrapped__ = clone : result = clone;
              var previous = clone;
              parent = parent.__wrapped__
            }
            return previous.__wrapped__ = value, result
          }, lodash.prototype.reverse = function () {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              return this.__actions__.length && (wrapped = new LazyWrapper(this)), (wrapped = wrapped.reverse()).__actions__.push({
                func: thru,
                args: [reverse],
                thisArg: undefined
              }), new LodashWrapper(wrapped, this.__chain__)
            }
            return this.thru(reverse)
          }, lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = function () {
            return baseWrapperValue(this.__wrapped__, this.__actions__)
          }, lodash.prototype.first = lodash.prototype.head, symIterator && (lodash.prototype[symIterator] = function () {
            return this
          }), lodash
        }();
        "function" == typeof define && "object" == typeof define.amd && define.amd ? (root._ = _, define(function () {
          return _
        })) : freeModule ? ((freeModule.exports = _)._ = _, freeExports._ = _) : root._ = _
      }).call(this)
    }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
  }, {}],
  9: [function (require, module, exports) {
    (function (global) {
      ! function (global, factory) {
        "object" == typeof exports && void 0 !== module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : global.Popper = factory()
      }(this, function () {
        "use strict";
        for (var isBrowser = "undefined" != typeof window && "undefined" != typeof document, longerTimeoutBrowsers = ["Edge", "Trident", "Firefox"], timeoutDuration = 0, i = 0; i < longerTimeoutBrowsers.length; i += 1)
          if (isBrowser && 0 <= navigator.userAgent.indexOf(longerTimeoutBrowsers[i])) {
            timeoutDuration = 1;
            break
          }
        var debounce = isBrowser && window.Promise ? function (fn) {
          var called = !1;
          return function () {
            called || (called = !0, window.Promise.resolve().then(function () {
              called = !1, fn()
            }))
          }
        } : function (fn) {
          var scheduled = !1;
          return function () {
            scheduled || (scheduled = !0, setTimeout(function () {
              scheduled = !1, fn()
            }, timeoutDuration))
          }
        };

        function isFunction(functionToCheck) {
          return functionToCheck && "[object Function]" === {}.toString.call(functionToCheck)
        }

        function getStyleComputedProperty(element, property) {
          if (1 !== element.nodeType) return [];
          var css = getComputedStyle(element, null);
          return property ? css[property] : css
        }

        function getParentNode(element) {
          return "HTML" === element.nodeName ? element : element.parentNode || element.host
        }

        function getScrollParent(element) {
          if (!element) return document.body;
          switch (element.nodeName) {
            case "HTML":
            case "BODY":
              return element.ownerDocument.body;
            case "#document":
              return element.body
          }
          var _getStyleComputedProp = getStyleComputedProperty(element),
            overflow = _getStyleComputedProp.overflow,
            overflowX = _getStyleComputedProp.overflowX,
            overflowY = _getStyleComputedProp.overflowY;
          return /(auto|scroll|overlay)/.test(overflow + overflowY + overflowX) ? element : getScrollParent(getParentNode(element))
        }
        var isIE11 = isBrowser && !(!window.MSInputMethodContext || !document.documentMode),
          isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

        function isIE(version) {
          return 11 === version ? isIE11 : 10 === version ? isIE10 : isIE11 || isIE10
        }

        function getOffsetParent(element) {
          if (!element) return document.documentElement;
          for (var noOffsetParent = isIE(10) ? document.body : null, offsetParent = element.offsetParent; offsetParent === noOffsetParent && element.nextElementSibling;) offsetParent = (element = element.nextElementSibling).offsetParent;
          var nodeName = offsetParent && offsetParent.nodeName;
          return nodeName && "BODY" !== nodeName && "HTML" !== nodeName ? -1 !== ["TD", "TABLE"].indexOf(offsetParent.nodeName) && "static" === getStyleComputedProperty(offsetParent, "position") ? getOffsetParent(offsetParent) : offsetParent : element ? element.ownerDocument.documentElement : document.documentElement
        }

        function getRoot(node) {
          return null !== node.parentNode ? getRoot(node.parentNode) : node
        }

        function findCommonOffsetParent(element1, element2) {
          if (!(element1 && element1.nodeType && element2 && element2.nodeType)) return document.documentElement;
          var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING,
            start = order ? element1 : element2,
            end = order ? element2 : element1,
            range = document.createRange();
          range.setStart(start, 0), range.setEnd(end, 0);
          var element, nodeName, commonAncestorContainer = range.commonAncestorContainer;
          if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) return "BODY" === (nodeName = (element = commonAncestorContainer).nodeName) || "HTML" !== nodeName && getOffsetParent(element.firstElementChild) !== element ? getOffsetParent(commonAncestorContainer) : commonAncestorContainer;
          var element1root = getRoot(element1);
          return element1root.host ? findCommonOffsetParent(element1root.host, element2) : findCommonOffsetParent(element1, getRoot(element2).host)
        }

        function getScroll(element) {
          var upperSide = "top" === (1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "top") ? "scrollTop" : "scrollLeft",
            nodeName = element.nodeName;
          if ("BODY" === nodeName || "HTML" === nodeName) {
            var html = element.ownerDocument.documentElement;
            return (element.ownerDocument.scrollingElement || html)[upperSide]
          }
          return element[upperSide]
        }

        function getBordersSize(styles, axis) {
          var sideA = "x" === axis ? "Left" : "Top",
            sideB = "Left" === sideA ? "Right" : "Bottom";
          return parseFloat(styles["border" + sideA + "Width"], 10) + parseFloat(styles["border" + sideB + "Width"], 10)
        }

        function getSize(axis, body, html, computedStyle) {
          return Math.max(body["offset" + axis], body["scroll" + axis], html["client" + axis], html["offset" + axis], html["scroll" + axis], isIE(10) ? html["offset" + axis] + computedStyle["margin" + ("Height" === axis ? "Top" : "Left")] + computedStyle["margin" + ("Height" === axis ? "Bottom" : "Right")] : 0)
        }

        function getWindowSizes() {
          var body = document.body,
            html = document.documentElement,
            computedStyle = isIE(10) && getComputedStyle(html);
          return {
            height: getSize("Height", body, html, computedStyle),
            width: getSize("Width", body, html, computedStyle)
          }
        }
        var classCallCheck = function (instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
          },
          createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
              }
            }
            return function (Constructor, protoProps, staticProps) {
              return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
            }
          }(),
          defineProperty = function (obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
              value: value,
              enumerable: !0,
              configurable: !0,
              writable: !0
            }) : obj[key] = value, obj
          },
          _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key])
            }
            return target
          };

        function getClientRect(offsets) {
          return _extends({}, offsets, {
            right: offsets.left + offsets.width,
            bottom: offsets.top + offsets.height
          })
        }

        function getBoundingClientRect(element) {
          var rect = {};
          try {
            if (isIE(10)) {
              rect = element.getBoundingClientRect();
              var scrollTop = getScroll(element, "top"),
                scrollLeft = getScroll(element, "left");
              rect.top += scrollTop, rect.left += scrollLeft, rect.bottom += scrollTop, rect.right += scrollLeft
            } else rect = element.getBoundingClientRect()
          } catch (e) {}
          var result = {
              left: rect.left,
              top: rect.top,
              width: rect.right - rect.left,
              height: rect.bottom - rect.top
            },
            sizes = "HTML" === element.nodeName ? getWindowSizes() : {},
            width = sizes.width || element.clientWidth || result.right - result.left,
            height = sizes.height || element.clientHeight || result.bottom - result.top,
            horizScrollbar = element.offsetWidth - width,
            vertScrollbar = element.offsetHeight - height;
          if (horizScrollbar || vertScrollbar) {
            var styles = getStyleComputedProperty(element);
            horizScrollbar -= getBordersSize(styles, "x"), vertScrollbar -= getBordersSize(styles, "y"), result.width -= horizScrollbar, result.height -= vertScrollbar
          }
          return getClientRect(result)
        }

        function getOffsetRectRelativeToArbitraryNode(children, parent) {
          var fixedPosition = 2 < arguments.length && void 0 !== arguments[2] && arguments[2],
            isIE10 = isIE(10),
            isHTML = "HTML" === parent.nodeName,
            childrenRect = getBoundingClientRect(children),
            parentRect = getBoundingClientRect(parent),
            scrollParent = getScrollParent(children),
            styles = getStyleComputedProperty(parent),
            borderTopWidth = parseFloat(styles.borderTopWidth, 10),
            borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);
          fixedPosition && "HTML" === parent.nodeName && (parentRect.top = Math.max(parentRect.top, 0), parentRect.left = Math.max(parentRect.left, 0));
          var offsets = getClientRect({
            top: childrenRect.top - parentRect.top - borderTopWidth,
            left: childrenRect.left - parentRect.left - borderLeftWidth,
            width: childrenRect.width,
            height: childrenRect.height
          });
          if (offsets.marginTop = 0, offsets.marginLeft = 0, !isIE10 && isHTML) {
            var marginTop = parseFloat(styles.marginTop, 10),
              marginLeft = parseFloat(styles.marginLeft, 10);
            offsets.top -= borderTopWidth - marginTop, offsets.bottom -= borderTopWidth - marginTop, offsets.left -= borderLeftWidth - marginLeft, offsets.right -= borderLeftWidth - marginLeft, offsets.marginTop = marginTop, offsets.marginLeft = marginLeft
          }
          return (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && "BODY" !== scrollParent.nodeName) && (offsets = function (rect, element) {
            var subtract = 2 < arguments.length && void 0 !== arguments[2] && arguments[2],
              scrollTop = getScroll(element, "top"),
              scrollLeft = getScroll(element, "left"),
              modifier = subtract ? -1 : 1;
            return rect.top += scrollTop * modifier, rect.bottom += scrollTop * modifier, rect.left += scrollLeft * modifier, rect.right += scrollLeft * modifier, rect
          }(offsets, parent)), offsets
        }

        function getFixedPositionOffsetParent(element) {
          if (!element || !element.parentElement || isIE()) return document.documentElement;
          for (var el = element.parentElement; el && "none" === getStyleComputedProperty(el, "transform");) el = el.parentElement;
          return el || document.documentElement
        }

        function getBoundaries(popper, reference, padding, boundariesElement) {
          var fixedPosition = 4 < arguments.length && void 0 !== arguments[4] && arguments[4],
            boundaries = {
              top: 0,
              left: 0
            },
            offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
          if ("viewport" === boundariesElement) boundaries = function (element) {
            var excludeScroll = 1 < arguments.length && void 0 !== arguments[1] && arguments[1],
              html = element.ownerDocument.documentElement,
              relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html),
              width = Math.max(html.clientWidth, window.innerWidth || 0),
              height = Math.max(html.clientHeight, window.innerHeight || 0),
              scrollTop = excludeScroll ? 0 : getScroll(html),
              scrollLeft = excludeScroll ? 0 : getScroll(html, "left");
            return getClientRect({
              top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
              left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
              width: width,
              height: height
            })
          }(offsetParent, fixedPosition);
          else {
            var boundariesNode = void 0;
            "scrollParent" === boundariesElement ? "BODY" === (boundariesNode = getScrollParent(getParentNode(reference))).nodeName && (boundariesNode = popper.ownerDocument.documentElement) : boundariesNode = "window" === boundariesElement ? popper.ownerDocument.documentElement : boundariesElement;
            var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
            if ("HTML" !== boundariesNode.nodeName || function isFixed(element) {
                var nodeName = element.nodeName;
                return "BODY" !== nodeName && "HTML" !== nodeName && ("fixed" === getStyleComputedProperty(element, "position") || isFixed(getParentNode(element)))
              }(offsetParent)) boundaries = offsets;
            else {
              var _getWindowSizes = getWindowSizes(),
                height = _getWindowSizes.height,
                width = _getWindowSizes.width;
              boundaries.top += offsets.top - offsets.marginTop, boundaries.bottom = height + offsets.top, boundaries.left += offsets.left - offsets.marginLeft, boundaries.right = width + offsets.left
            }
          }
          return boundaries.left += padding, boundaries.top += padding, boundaries.right -= padding, boundaries.bottom -= padding, boundaries
        }

        function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
          var padding = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0;
          if (-1 === placement.indexOf("auto")) return placement;
          var boundaries = getBoundaries(popper, reference, padding, boundariesElement),
            rects = {
              top: {
                width: boundaries.width,
                height: refRect.top - boundaries.top
              },
              right: {
                width: boundaries.right - refRect.right,
                height: boundaries.height
              },
              bottom: {
                width: boundaries.width,
                height: boundaries.bottom - refRect.bottom
              },
              left: {
                width: refRect.left - boundaries.left,
                height: boundaries.height
              }
            },
            sortedAreas = Object.keys(rects).map(function (key) {
              return _extends({
                key: key
              }, rects[key], {
                area: (_ref = rects[key], _ref.width * _ref.height)
              });
              var _ref
            }).sort(function (a, b) {
              return b.area - a.area
            }),
            filteredAreas = sortedAreas.filter(function (_ref2) {
              var width = _ref2.width,
                height = _ref2.height;
              return width >= popper.clientWidth && height >= popper.clientHeight
            }),
            computedPlacement = 0 < filteredAreas.length ? filteredAreas[0].key : sortedAreas[0].key,
            variation = placement.split("-")[1];
          return computedPlacement + (variation ? "-" + variation : "")
        }

        function getReferenceOffsets(state, popper, reference) {
          var fixedPosition = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
          return getOffsetRectRelativeToArbitraryNode(reference, fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference), fixedPosition)
        }

        function getOuterSizes(element) {
          var styles = getComputedStyle(element),
            x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom),
            y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
          return {
            width: element.offsetWidth + y,
            height: element.offsetHeight + x
          }
        }

        function getOppositePlacement(placement) {
          var hash = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
          };
          return placement.replace(/left|right|bottom|top/g, function (matched) {
            return hash[matched]
          })
        }

        function getPopperOffsets(popper, referenceOffsets, placement) {
          placement = placement.split("-")[0];
          var popperRect = getOuterSizes(popper),
            popperOffsets = {
              width: popperRect.width,
              height: popperRect.height
            },
            isHoriz = -1 !== ["right", "left"].indexOf(placement),
            mainSide = isHoriz ? "top" : "left",
            secondarySide = isHoriz ? "left" : "top",
            measurement = isHoriz ? "height" : "width",
            secondaryMeasurement = isHoriz ? "width" : "height";
          return popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2, popperOffsets[secondarySide] = placement === secondarySide ? referenceOffsets[secondarySide] - popperRect[secondaryMeasurement] : referenceOffsets[getOppositePlacement(secondarySide)], popperOffsets
        }

        function find(arr, check) {
          return Array.prototype.find ? arr.find(check) : arr.filter(check)[0]
        }

        function runModifiers(modifiers, data, ends) {
          return (void 0 === ends ? modifiers : modifiers.slice(0, function (arr, prop, value) {
            if (Array.prototype.findIndex) return arr.findIndex(function (cur) {
              return cur[prop] === value
            });
            var match = find(arr, function (obj) {
              return obj[prop] === value
            });
            return arr.indexOf(match)
          }(modifiers, "name", ends))).forEach(function (modifier) {
            modifier.function && console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
            var fn = modifier.function || modifier.fn;
            modifier.enabled && isFunction(fn) && (data.offsets.popper = getClientRect(data.offsets.popper), data.offsets.reference = getClientRect(data.offsets.reference), data = fn(data, modifier))
          }), data
        }

        function getSupportedPropertyName(property) {
          for (var prefixes = [!1, "ms", "Webkit", "Moz", "O"], upperProp = property.charAt(0).toUpperCase() + property.slice(1), i = 0; i < prefixes.length; i++) {
            var prefix = prefixes[i],
              toCheck = prefix ? "" + prefix + upperProp : property;
            if (void 0 !== document.body.style[toCheck]) return toCheck
          }
          return null
        }

        function isModifierEnabled(modifiers, modifierName) {
          return modifiers.some(function (_ref) {
            var name = _ref.name;
            return _ref.enabled && name === modifierName
          })
        }

        function getWindow(element) {
          var ownerDocument = element.ownerDocument;
          return ownerDocument ? ownerDocument.defaultView : window
        }

        function setupEventListeners(reference, options, state, updateBound) {
          state.updateBound = updateBound, getWindow(reference).addEventListener("resize", state.updateBound, {
            passive: !0
          });
          var scrollElement = getScrollParent(reference);
          return function attachToScrollParents(scrollParent, event, callback, scrollParents) {
            var isBody = "BODY" === scrollParent.nodeName,
              target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
            target.addEventListener(event, callback, {
              passive: !0
            }), isBody || attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents), scrollParents.push(target)
          }(scrollElement, "scroll", state.updateBound, state.scrollParents), state.scrollElement = scrollElement, state.eventsEnabled = !0, state
        }

        function disableEventListeners() {
          var reference, state;
          this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = (reference = this.reference, state = this.state, getWindow(reference).removeEventListener("resize", state.updateBound), state.scrollParents.forEach(function (target) {
            target.removeEventListener("scroll", state.updateBound)
          }), state.updateBound = null, state.scrollParents = [], state.scrollElement = null, state.eventsEnabled = !1, state))
        }

        function isNumeric(n) {
          return "" !== n && !isNaN(parseFloat(n)) && isFinite(n)
        }

        function setStyles(element, styles) {
          Object.keys(styles).forEach(function (prop) {
            var unit = ""; - 1 !== ["width", "height", "top", "right", "bottom", "left"].indexOf(prop) && isNumeric(styles[prop]) && (unit = "px"), element.style[prop] = styles[prop] + unit
          })
        }

        function isModifierRequired(modifiers, requestingName, requestedName) {
          var requesting = find(modifiers, function (_ref) {
              return _ref.name === requestingName
            }),
            isRequired = !!requesting && modifiers.some(function (modifier) {
              return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order
            });
          if (!isRequired) {
            var _requesting = "`" + requestingName + "`",
              requested = "`" + requestedName + "`";
            console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!")
          }
          return isRequired
        }
        var placements = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"],
          validPlacements = placements.slice(3);

        function clockwise(placement) {
          var counter = 1 < arguments.length && void 0 !== arguments[1] && arguments[1],
            index = validPlacements.indexOf(placement),
            arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
          return counter ? arr.reverse() : arr
        }
        var BEHAVIORS = {
          FLIP: "flip",
          CLOCKWISE: "clockwise",
          COUNTERCLOCKWISE: "counterclockwise"
        };

        function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
          var offsets = [0, 0],
            useHeight = -1 !== ["right", "left"].indexOf(basePlacement),
            fragments = offset.split(/(\+|\-)/).map(function (frag) {
              return frag.trim()
            }),
            divider = fragments.indexOf(find(fragments, function (frag) {
              return -1 !== frag.search(/,|\s/)
            }));
          fragments[divider] && -1 === fragments[divider].indexOf(",") && console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
          var splitRegex = /\s*,\s*|\s+/,
            ops = -1 !== divider ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
          return (ops = ops.map(function (op, index) {
            var measurement = (1 === index ? !useHeight : useHeight) ? "height" : "width",
              mergeWithPrevious = !1;
            return op.reduce(function (a, b) {
              return "" === a[a.length - 1] && -1 !== ["+", "-"].indexOf(b) ? (a[a.length - 1] = b, mergeWithPrevious = !0, a) : mergeWithPrevious ? (a[a.length - 1] += b, mergeWithPrevious = !1, a) : a.concat(b)
            }, []).map(function (str) {
              return function (str, measurement, popperOffsets, referenceOffsets) {
                var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),
                  value = +split[1],
                  unit = split[2];
                if (!value) return str;
                if (0 === unit.indexOf("%")) {
                  var element = void 0;
                  switch (unit) {
                    case "%p":
                      element = popperOffsets;
                      break;
                    case "%":
                    case "%r":
                    default:
                      element = referenceOffsets
                  }
                  return getClientRect(element)[measurement] / 100 * value
                }
                if ("vh" === unit || "vw" === unit) return ("vh" === unit ? Math.max(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0)) / 100 * value;
                return value
              }(str, measurement, popperOffsets, referenceOffsets)
            })
          })).forEach(function (op, index) {
            op.forEach(function (frag, index2) {
              isNumeric(frag) && (offsets[index] += frag * ("-" === op[index2 - 1] ? -1 : 1))
            })
          }), offsets
        }
        var Defaults = {
            placement: "bottom",
            positionFixed: !1,
            eventsEnabled: !0,
            removeOnDestroy: !1,
            onCreate: function () {},
            onUpdate: function () {},
            modifiers: {
              shift: {
                order: 100,
                enabled: !0,
                fn: function (data) {
                  var placement = data.placement,
                    basePlacement = placement.split("-")[0],
                    shiftvariation = placement.split("-")[1];
                  if (shiftvariation) {
                    var _data$offsets = data.offsets,
                      reference = _data$offsets.reference,
                      popper = _data$offsets.popper,
                      isVertical = -1 !== ["bottom", "top"].indexOf(basePlacement),
                      side = isVertical ? "left" : "top",
                      measurement = isVertical ? "width" : "height",
                      shiftOffsets = {
                        start: defineProperty({}, side, reference[side]),
                        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
                      };
                    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation])
                  }
                  return data
                }
              },
              offset: {
                order: 200,
                enabled: !0,
                fn: function (data, _ref) {
                  var offset = _ref.offset,
                    placement = data.placement,
                    _data$offsets = data.offsets,
                    popper = _data$offsets.popper,
                    reference = _data$offsets.reference,
                    basePlacement = placement.split("-")[0],
                    offsets = void 0;
                  return offsets = isNumeric(+offset) ? [+offset, 0] : parseOffset(offset, popper, reference, basePlacement), "left" === basePlacement ? (popper.top += offsets[0], popper.left -= offsets[1]) : "right" === basePlacement ? (popper.top += offsets[0], popper.left += offsets[1]) : "top" === basePlacement ? (popper.left += offsets[0], popper.top -= offsets[1]) : "bottom" === basePlacement && (popper.left += offsets[0], popper.top += offsets[1]), data.popper = popper, data
                },
                offset: 0
              },
              preventOverflow: {
                order: 300,
                enabled: !0,
                fn: function (data, options) {
                  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
                  data.instance.reference === boundariesElement && (boundariesElement = getOffsetParent(boundariesElement));
                  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
                  options.boundaries = boundaries;
                  var order = options.priority,
                    popper = data.offsets.popper,
                    check = {
                      primary: function (placement) {
                        var value = popper[placement];
                        return popper[placement] < boundaries[placement] && !options.escapeWithReference && (value = Math.max(popper[placement], boundaries[placement])), defineProperty({}, placement, value)
                      },
                      secondary: function (placement) {
                        var mainSide = "right" === placement ? "left" : "top",
                          value = popper[mainSide];
                        return popper[placement] > boundaries[placement] && !options.escapeWithReference && (value = Math.min(popper[mainSide], boundaries[placement] - ("right" === placement ? popper.width : popper.height))), defineProperty({}, mainSide, value)
                      }
                    };
                  return order.forEach(function (placement) {
                    var side = -1 !== ["left", "top"].indexOf(placement) ? "primary" : "secondary";
                    popper = _extends({}, popper, check[side](placement))
                  }), data.offsets.popper = popper, data
                },
                priority: ["left", "right", "top", "bottom"],
                padding: 5,
                boundariesElement: "scrollParent"
              },
              keepTogether: {
                order: 400,
                enabled: !0,
                fn: function (data) {
                  var _data$offsets = data.offsets,
                    popper = _data$offsets.popper,
                    reference = _data$offsets.reference,
                    placement = data.placement.split("-")[0],
                    floor = Math.floor,
                    isVertical = -1 !== ["top", "bottom"].indexOf(placement),
                    side = isVertical ? "right" : "bottom",
                    opSide = isVertical ? "left" : "top",
                    measurement = isVertical ? "width" : "height";
                  return popper[side] < floor(reference[opSide]) && (data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement]), popper[opSide] > floor(reference[side]) && (data.offsets.popper[opSide] = floor(reference[side])), data
                }
              },
              arrow: {
                order: 500,
                enabled: !0,
                fn: function (data, options) {
                  var _data$offsets$arrow;
                  if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) return data;
                  var arrowElement = options.element;
                  if ("string" == typeof arrowElement) {
                    if (!(arrowElement = data.instance.popper.querySelector(arrowElement))) return data
                  } else if (!data.instance.popper.contains(arrowElement)) return console.warn("WARNING: `arrow.element` must be child of its popper element!"), data;
                  var placement = data.placement.split("-")[0],
                    _data$offsets = data.offsets,
                    popper = _data$offsets.popper,
                    reference = _data$offsets.reference,
                    isVertical = -1 !== ["left", "right"].indexOf(placement),
                    len = isVertical ? "height" : "width",
                    sideCapitalized = isVertical ? "Top" : "Left",
                    side = sideCapitalized.toLowerCase(),
                    altSide = isVertical ? "left" : "top",
                    opSide = isVertical ? "bottom" : "right",
                    arrowElementSize = getOuterSizes(arrowElement)[len];
                  reference[opSide] - arrowElementSize < popper[side] && (data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize)), reference[side] + arrowElementSize > popper[opSide] && (data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide]), data.offsets.popper = getClientRect(data.offsets.popper);
                  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2,
                    css = getStyleComputedProperty(data.instance.popper),
                    popperMarginSide = parseFloat(css["margin" + sideCapitalized], 10),
                    popperBorderSide = parseFloat(css["border" + sideCapitalized + "Width"], 10),
                    sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
                  return sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0), data.arrowElement = arrowElement, data.offsets.arrow = (defineProperty(_data$offsets$arrow = {}, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ""), _data$offsets$arrow), data
                },
                element: "[x-arrow]"
              },
              flip: {
                order: 600,
                enabled: !0,
                fn: function (data, options) {
                  if (isModifierEnabled(data.instance.modifiers, "inner")) return data;
                  if (data.flipped && data.placement === data.originalPlacement) return data;
                  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed),
                    placement = data.placement.split("-")[0],
                    placementOpposite = getOppositePlacement(placement),
                    variation = data.placement.split("-")[1] || "",
                    flipOrder = [];
                  switch (options.behavior) {
                    case BEHAVIORS.FLIP:
                      flipOrder = [placement, placementOpposite];
                      break;
                    case BEHAVIORS.CLOCKWISE:
                      flipOrder = clockwise(placement);
                      break;
                    case BEHAVIORS.COUNTERCLOCKWISE:
                      flipOrder = clockwise(placement, !0);
                      break;
                    default:
                      flipOrder = options.behavior
                  }
                  return flipOrder.forEach(function (step, index) {
                    if (placement !== step || flipOrder.length === index + 1) return data;
                    placement = data.placement.split("-")[0], placementOpposite = getOppositePlacement(placement);
                    var popperOffsets = data.offsets.popper,
                      refOffsets = data.offsets.reference,
                      floor = Math.floor,
                      overlapsRef = "left" === placement && floor(popperOffsets.right) > floor(refOffsets.left) || "right" === placement && floor(popperOffsets.left) < floor(refOffsets.right) || "top" === placement && floor(popperOffsets.bottom) > floor(refOffsets.top) || "bottom" === placement && floor(popperOffsets.top) < floor(refOffsets.bottom),
                      overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left),
                      overflowsRight = floor(popperOffsets.right) > floor(boundaries.right),
                      overflowsTop = floor(popperOffsets.top) < floor(boundaries.top),
                      overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom),
                      overflowsBoundaries = "left" === placement && overflowsLeft || "right" === placement && overflowsRight || "top" === placement && overflowsTop || "bottom" === placement && overflowsBottom,
                      isVertical = -1 !== ["top", "bottom"].indexOf(placement),
                      flippedVariation = !!options.flipVariations && (isVertical && "start" === variation && overflowsLeft || isVertical && "end" === variation && overflowsRight || !isVertical && "start" === variation && overflowsTop || !isVertical && "end" === variation && overflowsBottom);
                    (overlapsRef || overflowsBoundaries || flippedVariation) && (data.flipped = !0, (overlapsRef || overflowsBoundaries) && (placement = flipOrder[index + 1]), flippedVariation && (variation = function (variation) {
                      return "end" === variation ? "start" : "start" === variation ? "end" : variation
                    }(variation)), data.placement = placement + (variation ? "-" + variation : ""), data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement)), data = runModifiers(data.instance.modifiers, data, "flip"))
                  }), data
                },
                behavior: "flip",
                padding: 5,
                boundariesElement: "viewport"
              },
              inner: {
                order: 700,
                enabled: !1,
                fn: function (data) {
                  var placement = data.placement,
                    basePlacement = placement.split("-")[0],
                    _data$offsets = data.offsets,
                    popper = _data$offsets.popper,
                    reference = _data$offsets.reference,
                    isHoriz = -1 !== ["left", "right"].indexOf(basePlacement),
                    subtractLength = -1 === ["top", "left"].indexOf(basePlacement);
                  return popper[isHoriz ? "left" : "top"] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? "width" : "height"] : 0), data.placement = getOppositePlacement(placement), data.offsets.popper = getClientRect(popper), data
                }
              },
              hide: {
                order: 800,
                enabled: !0,
                fn: function (data) {
                  if (!isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")) return data;
                  var refRect = data.offsets.reference,
                    bound = find(data.instance.modifiers, function (modifier) {
                      return "preventOverflow" === modifier.name
                    }).boundaries;
                  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
                    if (!0 === data.hide) return data;
                    data.hide = !0, data.attributes["x-out-of-boundaries"] = ""
                  } else {
                    if (!1 === data.hide) return data;
                    data.hide = !1, data.attributes["x-out-of-boundaries"] = !1
                  }
                  return data
                }
              },
              computeStyle: {
                order: 850,
                enabled: !0,
                fn: function (data, options) {
                  var x = options.x,
                    y = options.y,
                    popper = data.offsets.popper,
                    legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
                      return "applyStyle" === modifier.name
                    }).gpuAcceleration;
                  void 0 !== legacyGpuAccelerationOption && console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
                  var gpuAcceleration = void 0 !== legacyGpuAccelerationOption ? legacyGpuAccelerationOption : options.gpuAcceleration,
                    offsetParentRect = getBoundingClientRect(getOffsetParent(data.instance.popper)),
                    styles = {
                      position: popper.position
                    },
                    offsets = {
                      left: Math.floor(popper.left),
                      top: Math.round(popper.top),
                      bottom: Math.round(popper.bottom),
                      right: Math.floor(popper.right)
                    },
                    sideA = "bottom" === x ? "top" : "bottom",
                    sideB = "right" === y ? "left" : "right",
                    prefixedProperty = getSupportedPropertyName("transform"),
                    left = void 0,
                    top = void 0;
                  if (top = "bottom" === sideA ? -offsetParentRect.height + offsets.bottom : offsets.top, left = "right" === sideB ? -offsetParentRect.width + offsets.right : offsets.left, gpuAcceleration && prefixedProperty) styles[prefixedProperty] = "translate3d(" + left + "px, " + top + "px, 0)", styles[sideA] = 0, styles[sideB] = 0, styles.willChange = "transform";
                  else {
                    var invertTop = "bottom" === sideA ? -1 : 1,
                      invertLeft = "right" === sideB ? -1 : 1;
                    styles[sideA] = top * invertTop, styles[sideB] = left * invertLeft, styles.willChange = sideA + ", " + sideB
                  }
                  var attributes = {
                    "x-placement": data.placement
                  };
                  return data.attributes = _extends({}, attributes, data.attributes), data.styles = _extends({}, styles, data.styles), data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles), data
                },
                gpuAcceleration: !0,
                x: "bottom",
                y: "right"
              },
              applyStyle: {
                order: 900,
                enabled: !0,
                fn: function (data) {
                  var element, attributes;
                  return setStyles(data.instance.popper, data.styles), element = data.instance.popper, attributes = data.attributes, Object.keys(attributes).forEach(function (prop) {
                    !1 !== attributes[prop] ? element.setAttribute(prop, attributes[prop]) : element.removeAttribute(prop)
                  }), data.arrowElement && Object.keys(data.arrowStyles).length && setStyles(data.arrowElement, data.arrowStyles), data
                },
                onLoad: function (reference, popper, options, modifierOptions, state) {
                  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed),
                    placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
                  return popper.setAttribute("x-placement", placement), setStyles(popper, {
                    position: options.positionFixed ? "fixed" : "absolute"
                  }), options
                },
                gpuAcceleration: void 0
              }
            }
          },
          Popper = function () {
            function Popper(reference, popper) {
              var _this = this,
                options = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
              classCallCheck(this, Popper), this.scheduleUpdate = function () {
                return requestAnimationFrame(_this.update)
              }, this.update = debounce(this.update.bind(this)), this.options = _extends({}, Popper.Defaults, options), this.state = {
                isDestroyed: !1,
                isCreated: !1,
                scrollParents: []
              }, this.reference = reference && reference.jquery ? reference[0] : reference, this.popper = popper && popper.jquery ? popper[0] : popper, this.options.modifiers = {}, Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
                _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {})
              }), this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
                return _extends({
                  name: name
                }, _this.options.modifiers[name])
              }).sort(function (a, b) {
                return a.order - b.order
              }), this.modifiers.forEach(function (modifierOptions) {
                modifierOptions.enabled && isFunction(modifierOptions.onLoad) && modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state)
              }), this.update();
              var eventsEnabled = this.options.eventsEnabled;
              eventsEnabled && this.enableEventListeners(), this.state.eventsEnabled = eventsEnabled
            }
            return createClass(Popper, [{
              key: "update",
              value: function () {
                return function () {
                  if (!this.state.isDestroyed) {
                    var data = {
                        instance: this,
                        styles: {},
                        arrowStyles: {},
                        attributes: {},
                        flipped: !1,
                        offsets: {}
                      },
                      popperStyles = this.popper.style;
                    popperStyles.top = "", popperStyles.left = "", popperStyles[getSupportedPropertyName("transform")] = "", data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed), data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), data.originalPlacement = data.placement, data.positionFixed = this.options.positionFixed, data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement), data.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute", data = runModifiers(this.modifiers, data), this.state.isCreated ? this.options.onUpdate(data) : (this.state.isCreated = !0, this.options.onCreate(data))
                  }
                }.call(this)
              }
            }, {
              key: "destroy",
              value: function () {
                return function () {
                  return this.state.isDestroyed = !0, isModifierEnabled(this.modifiers, "applyStyle") && (this.popper.removeAttribute("x-placement"), this.popper.style.position = "", this.popper.style.top = "", this.popper.style.left = "", this.popper.style.right = "", this.popper.style.bottom = "", this.popper.style.willChange = "", this.popper.style[getSupportedPropertyName("transform")] = ""), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this
                }.call(this)
              }
            }, {
              key: "enableEventListeners",
              value: function () {
                return function () {
                  this.state.eventsEnabled || (this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate))
                }.call(this)
              }
            }, {
              key: "disableEventListeners",
              value: function () {
                return disableEventListeners.call(this)
              }
            }]), Popper
          }();
        return Popper.Utils = ("undefined" != typeof window ? window : global).PopperUtils, Popper.placements = placements, Popper.Defaults = Defaults, Popper
      })
    }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
  }, {}],
  10: [function (require, module, exports) {
    var global, factory;
    global = this, factory = function () {
      "use strict";
      var doc = "undefined" == typeof document ? {
          body: {},
          addEventListener: function () {},
          removeEventListener: function () {},
          activeElement: {
            blur: function () {},
            nodeName: ""
          },
          querySelector: function () {
            return null
          },
          querySelectorAll: function () {
            return []
          },
          getElementById: function () {
            return null
          },
          createEvent: function () {
            return {
              initEvent: function () {}
            }
          },
          createElement: function () {
            return {
              children: [],
              childNodes: [],
              style: {},
              setAttribute: function () {},
              getElementsByTagName: function () {
                return []
              }
            }
          },
          location: {
            hash: ""
          }
        } : document,
        win = "undefined" == typeof window ? {
          document: doc,
          navigator: {
            userAgent: ""
          },
          location: {},
          history: {},
          CustomEvent: function () {
            return this
          },
          addEventListener: function () {},
          removeEventListener: function () {},
          getComputedStyle: function () {
            return {
              getPropertyValue: function () {
                return ""
              }
            }
          },
          Image: function () {},
          Date: function () {},
          screen: {},
          setTimeout: function () {},
          clearTimeout: function () {}
        } : window,
        Dom7 = function (arr) {
          for (var i = 0; i < arr.length; i += 1) this[i] = arr[i];
          return this.length = arr.length, this
        };

      function $(selector, context) {
        var arr = [],
          i = 0;
        if (selector && !context && selector instanceof Dom7) return selector;
        if (selector)
          if ("string" == typeof selector) {
            var els, tempParent, html = selector.trim();
            if (0 <= html.indexOf("<") && 0 <= html.indexOf(">")) {
              var toCreate = "div";
              for (0 === html.indexOf("<li") && (toCreate = "ul"), 0 === html.indexOf("<tr") && (toCreate = "tbody"), 0 !== html.indexOf("<td") && 0 !== html.indexOf("<th") || (toCreate = "tr"), 0 === html.indexOf("<tbody") && (toCreate = "table"), 0 === html.indexOf("<option") && (toCreate = "select"), (tempParent = doc.createElement(toCreate)).innerHTML = html, i = 0; i < tempParent.childNodes.length; i += 1) arr.push(tempParent.childNodes[i])
            } else
              for (els = context || "#" !== selector[0] || selector.match(/[ .<>:~]/) ? (context || doc).querySelectorAll(selector.trim()) : [doc.getElementById(selector.trim().split("#")[1])], i = 0; i < els.length; i += 1) els[i] && arr.push(els[i])
          } else if (selector.nodeType || selector === win || selector === doc) arr.push(selector);
        else if (0 < selector.length && selector[0].nodeType)
          for (i = 0; i < selector.length; i += 1) arr.push(selector[i]);
        return new Dom7(arr)
      }

      function unique(arr) {
        for (var uniqueArray = [], i = 0; i < arr.length; i += 1) - 1 === uniqueArray.indexOf(arr[i]) && uniqueArray.push(arr[i]);
        return uniqueArray
      }
      $.fn = Dom7.prototype, $.Class = Dom7, $.Dom7 = Dom7;
      var Methods = {
        addClass: function (className) {
          if (void 0 === className) return this;
          for (var classes = className.split(" "), i = 0; i < classes.length; i += 1)
            for (var j = 0; j < this.length; j += 1) void 0 !== this[j] && void 0 !== this[j].classList && this[j].classList.add(classes[i]);
          return this
        },
        removeClass: function (className) {
          for (var classes = className.split(" "), i = 0; i < classes.length; i += 1)
            for (var j = 0; j < this.length; j += 1) void 0 !== this[j] && void 0 !== this[j].classList && this[j].classList.remove(classes[i]);
          return this
        },
        hasClass: function (className) {
          return !!this[0] && this[0].classList.contains(className)
        },
        toggleClass: function (className) {
          for (var classes = className.split(" "), i = 0; i < classes.length; i += 1)
            for (var j = 0; j < this.length; j += 1) void 0 !== this[j] && void 0 !== this[j].classList && this[j].classList.toggle(classes[i]);
          return this
        },
        attr: function (attrs, value) {
          var arguments$1 = arguments;
          if (1 === arguments.length && "string" == typeof attrs) return this[0] ? this[0].getAttribute(attrs) : void 0;
          for (var i = 0; i < this.length; i += 1)
            if (2 === arguments$1.length) this[i].setAttribute(attrs, value);
            else
              for (var attrName in attrs) this[i][attrName] = attrs[attrName], this[i].setAttribute(attrName, attrs[attrName]);
          return this
        },
        removeAttr: function (attr) {
          for (var i = 0; i < this.length; i += 1) this[i].removeAttribute(attr);
          return this
        },
        data: function (key, value) {
          var el;
          if (void 0 !== value) {
            for (var i = 0; i < this.length; i += 1)(el = this[i]).dom7ElementDataStorage || (el.dom7ElementDataStorage = {}), el.dom7ElementDataStorage[key] = value;
            return this
          }
          if (el = this[0]) {
            if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) return el.dom7ElementDataStorage[key];
            var dataKey = el.getAttribute("data-" + key);
            return dataKey || void 0
          }
        },
        transform: function (transform) {
          for (var i = 0; i < this.length; i += 1) {
            var elStyle = this[i].style;
            elStyle.webkitTransform = transform, elStyle.transform = transform
          }
          return this
        },
        transition: function (duration) {
          "string" != typeof duration && (duration += "ms");
          for (var i = 0; i < this.length; i += 1) {
            var elStyle = this[i].style;
            elStyle.webkitTransitionDuration = duration, elStyle.transitionDuration = duration
          }
          return this
        },
        on: function () {
          for (var assign, args = [], len = arguments.length; len--;) args[len] = arguments[len];
          var eventType = args[0],
            targetSelector = args[1],
            listener = args[2],
            capture = args[3];

          function handleLiveEvent(e) {
            var target = e.target;
            if (target) {
              var eventData = e.target.dom7EventData || [];
              if (eventData.indexOf(e) < 0 && eventData.unshift(e), $(target).is(targetSelector)) listener.apply(target, eventData);
              else
                for (var parents = $(target).parents(), k = 0; k < parents.length; k += 1) $(parents[k]).is(targetSelector) && listener.apply(parents[k], eventData)
            }
          }

          function handleEvent(e) {
            var eventData = e && e.target && e.target.dom7EventData || [];
            eventData.indexOf(e) < 0 && eventData.unshift(e), listener.apply(this, eventData)
          }
          "function" == typeof args[1] && (eventType = (assign = args)[0], listener = assign[1], capture = assign[2], targetSelector = void 0), capture || (capture = !1);
          for (var j, events = eventType.split(" "), i = 0; i < this.length; i += 1) {
            var el = this[i];
            if (targetSelector)
              for (j = 0; j < events.length; j += 1) {
                var event$1 = events[j];
                el.dom7LiveListeners || (el.dom7LiveListeners = {}), el.dom7LiveListeners[event$1] || (el.dom7LiveListeners[event$1] = []), el.dom7LiveListeners[event$1].push({
                  listener: listener,
                  proxyListener: handleLiveEvent
                }), el.addEventListener(event$1, handleLiveEvent, capture)
              } else
                for (j = 0; j < events.length; j += 1) {
                  var event = events[j];
                  el.dom7Listeners || (el.dom7Listeners = {}), el.dom7Listeners[event] || (el.dom7Listeners[event] = []), el.dom7Listeners[event].push({
                    listener: listener,
                    proxyListener: handleEvent
                  }), el.addEventListener(event, handleEvent, capture)
                }
          }
          return this
        },
        off: function () {
          for (var assign, args = [], len = arguments.length; len--;) args[len] = arguments[len];
          var eventType = args[0],
            targetSelector = args[1],
            listener = args[2],
            capture = args[3];
          "function" == typeof args[1] && (eventType = (assign = args)[0], listener = assign[1], capture = assign[2], targetSelector = void 0), capture || (capture = !1);
          for (var events = eventType.split(" "), i = 0; i < events.length; i += 1)
            for (var event = events[i], j = 0; j < this.length; j += 1) {
              var el = this[j],
                handlers = void 0;
              if (!targetSelector && el.dom7Listeners ? handlers = el.dom7Listeners[event] : targetSelector && el.dom7LiveListeners && (handlers = el.dom7LiveListeners[event]), handlers && handlers.length)
                for (var k = handlers.length - 1; 0 <= k; k -= 1) {
                  var handler = handlers[k];
                  listener && handler.listener === listener ? (el.removeEventListener(event, handler.proxyListener, capture), handlers.splice(k, 1)) : listener || (el.removeEventListener(event, handler.proxyListener, capture), handlers.splice(k, 1))
                }
            }
          return this
        },
        trigger: function () {
          for (var args = [], len = arguments.length; len--;) args[len] = arguments[len];
          for (var events = args[0].split(" "), eventData = args[1], i = 0; i < events.length; i += 1)
            for (var event = events[i], j = 0; j < this.length; j += 1) {
              var el = this[j],
                evt = void 0;
              try {
                evt = new win.CustomEvent(event, {
                  detail: eventData,
                  bubbles: !0,
                  cancelable: !0
                })
              } catch (e) {
                (evt = doc.createEvent("Event")).initEvent(event, !0, !0), evt.detail = eventData
              }
              el.dom7EventData = args.filter(function (data, dataIndex) {
                return 0 < dataIndex
              }), el.dispatchEvent(evt), el.dom7EventData = [], delete el.dom7EventData
            }
          return this
        },
        transitionEnd: function (callback) {
          var i, events = ["webkitTransitionEnd", "transitionend"],
            dom = this;

          function fireCallBack(e) {
            if (e.target === this)
              for (callback.call(this, e), i = 0; i < events.length; i += 1) dom.off(events[i], fireCallBack)
          }
          if (callback)
            for (i = 0; i < events.length; i += 1) dom.on(events[i], fireCallBack);
          return this
        },
        outerWidth: function (includeMargins) {
          if (0 < this.length) {
            if (includeMargins) {
              var styles = this.styles();
              return this[0].offsetWidth + parseFloat(styles.getPropertyValue("margin-right")) + parseFloat(styles.getPropertyValue("margin-left"))
            }
            return this[0].offsetWidth
          }
          return null
        },
        outerHeight: function (includeMargins) {
          if (0 < this.length) {
            if (includeMargins) {
              var styles = this.styles();
              return this[0].offsetHeight + parseFloat(styles.getPropertyValue("margin-top")) + parseFloat(styles.getPropertyValue("margin-bottom"))
            }
            return this[0].offsetHeight
          }
          return null
        },
        offset: function () {
          if (0 < this.length) {
            var el = this[0],
              box = el.getBoundingClientRect(),
              body = doc.body,
              clientTop = el.clientTop || body.clientTop || 0,
              clientLeft = el.clientLeft || body.clientLeft || 0,
              scrollTop = el === win ? win.scrollY : el.scrollTop,
              scrollLeft = el === win ? win.scrollX : el.scrollLeft;
            return {
              top: box.top + scrollTop - clientTop,
              left: box.left + scrollLeft - clientLeft
            }
          }
          return null
        },
        css: function (props, value) {
          var i;
          if (1 === arguments.length) {
            if ("string" != typeof props) {
              for (i = 0; i < this.length; i += 1)
                for (var prop in props) this[i].style[prop] = props[prop];
              return this
            }
            if (this[0]) return win.getComputedStyle(this[0], null).getPropertyValue(props)
          }
          if (2 === arguments.length && "string" == typeof props) {
            for (i = 0; i < this.length; i += 1) this[i].style[props] = value;
            return this
          }
          return this
        },
        each: function (callback) {
          if (!callback) return this;
          for (var i = 0; i < this.length; i += 1)
            if (!1 === callback.call(this[i], i, this[i])) return this;
          return this
        },
        html: function (html) {
          if (void 0 === html) return this[0] ? this[0].innerHTML : void 0;
          for (var i = 0; i < this.length; i += 1) this[i].innerHTML = html;
          return this
        },
        text: function (text) {
          if (void 0 === text) return this[0] ? this[0].textContent.trim() : null;
          for (var i = 0; i < this.length; i += 1) this[i].textContent = text;
          return this
        },
        is: function (selector) {
          var compareWith, i, el = this[0];
          if (!el || void 0 === selector) return !1;
          if ("string" == typeof selector) {
            if (el.matches) return el.matches(selector);
            if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
            if (el.msMatchesSelector) return el.msMatchesSelector(selector);
            for (compareWith = $(selector), i = 0; i < compareWith.length; i += 1)
              if (compareWith[i] === el) return !0;
            return !1
          }
          if (selector === doc) return el === doc;
          if (selector === win) return el === win;
          if (selector.nodeType || selector instanceof Dom7) {
            for (compareWith = selector.nodeType ? [selector] : selector, i = 0; i < compareWith.length; i += 1)
              if (compareWith[i] === el) return !0;
            return !1
          }
          return !1
        },
        index: function () {
          var i, child = this[0];
          if (child) {
            for (i = 0; null !== (child = child.previousSibling);) 1 === child.nodeType && (i += 1);
            return i
          }
        },
        eq: function (index) {
          if (void 0 === index) return this;
          var returnIndex, length = this.length;
          return new Dom7(length - 1 < index ? [] : index < 0 ? (returnIndex = length + index) < 0 ? [] : [this[returnIndex]] : [this[index]])
        },
        append: function () {
          for (var newChild, args = [], len = arguments.length; len--;) args[len] = arguments[len];
          for (var k = 0; k < args.length; k += 1) {
            newChild = args[k];
            for (var i = 0; i < this.length; i += 1)
              if ("string" == typeof newChild) {
                var tempDiv = doc.createElement("div");
                for (tempDiv.innerHTML = newChild; tempDiv.firstChild;) this[i].appendChild(tempDiv.firstChild)
              } else if (newChild instanceof Dom7)
              for (var j = 0; j < newChild.length; j += 1) this[i].appendChild(newChild[j]);
            else this[i].appendChild(newChild)
          }
          return this
        },
        prepend: function (newChild) {
          var i, j;
          for (i = 0; i < this.length; i += 1)
            if ("string" == typeof newChild) {
              var tempDiv = doc.createElement("div");
              for (tempDiv.innerHTML = newChild, j = tempDiv.childNodes.length - 1; 0 <= j; j -= 1) this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0])
            } else if (newChild instanceof Dom7)
            for (j = 0; j < newChild.length; j += 1) this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          else this[i].insertBefore(newChild, this[i].childNodes[0]);
          return this
        },
        next: function (selector) {
          return 0 < this.length ? selector ? this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector) ? new Dom7([this[0].nextElementSibling]) : new Dom7([]) : this[0].nextElementSibling ? new Dom7([this[0].nextElementSibling]) : new Dom7([]) : new Dom7([])
        },
        nextAll: function (selector) {
          var nextEls = [],
            el = this[0];
          if (!el) return new Dom7([]);
          for (; el.nextElementSibling;) {
            var next = el.nextElementSibling;
            selector ? $(next).is(selector) && nextEls.push(next) : nextEls.push(next), el = next
          }
          return new Dom7(nextEls)
        },
        prev: function (selector) {
          if (0 < this.length) {
            var el = this[0];
            return selector ? el.previousElementSibling && $(el.previousElementSibling).is(selector) ? new Dom7([el.previousElementSibling]) : new Dom7([]) : el.previousElementSibling ? new Dom7([el.previousElementSibling]) : new Dom7([])
          }
          return new Dom7([])
        },
        prevAll: function (selector) {
          var prevEls = [],
            el = this[0];
          if (!el) return new Dom7([]);
          for (; el.previousElementSibling;) {
            var prev = el.previousElementSibling;
            selector ? $(prev).is(selector) && prevEls.push(prev) : prevEls.push(prev), el = prev
          }
          return new Dom7(prevEls)
        },
        parent: function (selector) {
          for (var parents = [], i = 0; i < this.length; i += 1) null !== this[i].parentNode && (selector ? $(this[i].parentNode).is(selector) && parents.push(this[i].parentNode) : parents.push(this[i].parentNode));
          return $(unique(parents))
        },
        parents: function (selector) {
          for (var parents = [], i = 0; i < this.length; i += 1)
            for (var parent = this[i].parentNode; parent;) selector ? $(parent).is(selector) && parents.push(parent) : parents.push(parent), parent = parent.parentNode;
          return $(unique(parents))
        },
        closest: function (selector) {
          var closest = this;
          return void 0 === selector ? new Dom7([]) : (closest.is(selector) || (closest = closest.parents(selector).eq(0)), closest)
        },
        find: function (selector) {
          for (var foundElements = [], i = 0; i < this.length; i += 1)
            for (var found = this[i].querySelectorAll(selector), j = 0; j < found.length; j += 1) foundElements.push(found[j]);
          return new Dom7(foundElements)
        },
        children: function (selector) {
          for (var children = [], i = 0; i < this.length; i += 1)
            for (var childNodes = this[i].childNodes, j = 0; j < childNodes.length; j += 1) selector ? 1 === childNodes[j].nodeType && $(childNodes[j]).is(selector) && children.push(childNodes[j]) : 1 === childNodes[j].nodeType && children.push(childNodes[j]);
          return new Dom7(unique(children))
        },
        remove: function () {
          for (var i = 0; i < this.length; i += 1) this[i].parentNode && this[i].parentNode.removeChild(this[i]);
          return this
        },
        add: function () {
          for (var args = [], len = arguments.length; len--;) args[len] = arguments[len];
          var i, j;
          for (i = 0; i < args.length; i += 1) {
            var toAdd = $(args[i]);
            for (j = 0; j < toAdd.length; j += 1) this[this.length] = toAdd[j], this.length += 1
          }
          return this
        },
        styles: function () {
          return this[0] ? win.getComputedStyle(this[0], null) : {}
        }
      };
      Object.keys(Methods).forEach(function (methodName) {
        $.fn[methodName] = Methods[methodName]
      });
      var style, testDiv, Utils = {
          deleteProps: function (obj) {
            var object = obj;
            Object.keys(object).forEach(function (key) {
              try {
                object[key] = null
              } catch (e) {}
              try {
                delete object[key]
              } catch (e) {}
            })
          },
          nextTick: function (callback, delay) {
            return void 0 === delay && (delay = 0), setTimeout(callback, delay)
          },
          now: function () {
            return Date.now()
          },
          getTranslate: function (el, axis) {
            var matrix, curTransform, transformMatrix;
            void 0 === axis && (axis = "x");
            var curStyle = win.getComputedStyle(el, null);
            return win.WebKitCSSMatrix ? (6 < (curTransform = curStyle.transform || curStyle.webkitTransform).split(",").length && (curTransform = curTransform.split(", ").map(function (a) {
              return a.replace(",", ".")
            }).join(", ")), transformMatrix = new win.WebKitCSSMatrix("none" === curTransform ? "" : curTransform)) : matrix = (transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,")).toString().split(","), "x" === axis && (curTransform = win.WebKitCSSMatrix ? transformMatrix.m41 : 16 === matrix.length ? parseFloat(matrix[12]) : parseFloat(matrix[4])), "y" === axis && (curTransform = win.WebKitCSSMatrix ? transformMatrix.m42 : 16 === matrix.length ? parseFloat(matrix[13]) : parseFloat(matrix[5])), curTransform || 0
          },
          parseUrlQuery: function (url) {
            var i, params, param, length, query = {},
              urlToParse = url || win.location.href;
            if ("string" == typeof urlToParse && urlToParse.length)
              for (length = (params = (urlToParse = -1 < urlToParse.indexOf("?") ? urlToParse.replace(/\S*\?/, "") : "").split("&").filter(function (paramsPart) {
                  return "" !== paramsPart
                })).length, i = 0; i < length; i += 1) param = params[i].replace(/#\S+/g, "").split("="), query[decodeURIComponent(param[0])] = void 0 === param[1] ? void 0 : decodeURIComponent(param[1]) || "";
            return query
          },
          isObject: function (o) {
            return "object" == typeof o && null !== o && o.constructor && o.constructor === Object
          },
          extend: function () {
            for (var args = [], len$1 = arguments.length; len$1--;) args[len$1] = arguments[len$1];
            for (var to = Object(args[0]), i = 1; i < args.length; i += 1) {
              var nextSource = args[i];
              if (null != nextSource)
                for (var keysArray = Object.keys(Object(nextSource)), nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                  var nextKey = keysArray[nextIndex],
                    desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                  void 0 !== desc && desc.enumerable && (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey]) ? Utils.extend(to[nextKey], nextSource[nextKey]) : !Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey]) ? (to[nextKey] = {}, Utils.extend(to[nextKey], nextSource[nextKey])) : to[nextKey] = nextSource[nextKey])
                }
            }
            return to
          }
        },
        Support = (testDiv = doc.createElement("div"), {
          touch: win.Modernizr && !0 === win.Modernizr.touch || !!("ontouchstart" in win || win.DocumentTouch && doc instanceof win.DocumentTouch),
          pointerEvents: !(!win.navigator.pointerEnabled && !win.PointerEvent),
          prefixedPointerEvents: !!win.navigator.msPointerEnabled,
          transition: (style = testDiv.style, "transition" in style || "webkitTransition" in style || "MozTransition" in style),
          transforms3d: win.Modernizr && !0 === win.Modernizr.csstransforms3d || function () {
            var style = testDiv.style;
            return "webkitPerspective" in style || "MozPerspective" in style || "OPerspective" in style || "MsPerspective" in style || "perspective" in style
          }(),
          flexbox: function () {
            for (var style = testDiv.style, styles = "alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient".split(" "), i = 0; i < styles.length; i += 1)
              if (styles[i] in style) return !0;
            return !1
          }(),
          observer: "MutationObserver" in win || "WebkitMutationObserver" in win,
          passiveListener: function () {
            var supportsPassive = !1;
            try {
              var opts = Object.defineProperty({}, "passive", {
                get: function () {
                  supportsPassive = !0
                }
              });
              win.addEventListener("testPassiveListener", null, opts)
            } catch (e) {}
            return supportsPassive
          }(),
          gestures: "ongesturestart" in win
        }),
        SwiperClass = function (params) {
          void 0 === params && (params = {});
          var self = this;
          self.params = params, self.eventsListeners = {}, self.params && self.params.on && Object.keys(self.params.on).forEach(function (eventName) {
            self.on(eventName, self.params.on[eventName])
          })
        },
        staticAccessors = {
          components: {
            configurable: !0
          }
        };
      SwiperClass.prototype.on = function (events, handler, priority) {
        var self = this;
        if ("function" != typeof handler) return self;
        var method = priority ? "unshift" : "push";
        return events.split(" ").forEach(function (event) {
          self.eventsListeners[event] || (self.eventsListeners[event] = []), self.eventsListeners[event][method](handler)
        }), self
      }, SwiperClass.prototype.once = function (events, handler, priority) {
        var self = this;
        if ("function" != typeof handler) return self;
        return self.on(events, function onceHandler() {
          for (var args = [], len = arguments.length; len--;) args[len] = arguments[len];
          handler.apply(self, args), self.off(events, onceHandler)
        }, priority)
      }, SwiperClass.prototype.off = function (events, handler) {
        var self = this;
        return self.eventsListeners && events.split(" ").forEach(function (event) {
          void 0 === handler ? self.eventsListeners[event] = [] : self.eventsListeners[event].forEach(function (eventHandler, index) {
            eventHandler === handler && self.eventsListeners[event].splice(index, 1)
          })
        }), self
      }, SwiperClass.prototype.emit = function () {
        for (var args = [], len = arguments.length; len--;) args[len] = arguments[len];
        var events, data, context, self = this;
        return self.eventsListeners && ("string" == typeof args[0] || Array.isArray(args[0]) ? (events = args[0], data = args.slice(1, args.length), context = self) : (events = args[0].events, data = args[0].data, context = args[0].context || self), (Array.isArray(events) ? events : events.split(" ")).forEach(function (event) {
          if (self.eventsListeners && self.eventsListeners[event]) {
            var handlers = [];
            self.eventsListeners[event].forEach(function (eventHandler) {
              handlers.push(eventHandler)
            }), handlers.forEach(function (eventHandler) {
              eventHandler.apply(context, data)
            })
          }
        })), self
      }, SwiperClass.prototype.useModulesParams = function (instanceParams) {
        var instance = this;
        instance.modules && Object.keys(instance.modules).forEach(function (moduleName) {
          var module = instance.modules[moduleName];
          module.params && Utils.extend(instanceParams, module.params)
        })
      }, SwiperClass.prototype.useModules = function (modulesParams) {
        void 0 === modulesParams && (modulesParams = {});
        var instance = this;
        instance.modules && Object.keys(instance.modules).forEach(function (moduleName) {
          var module = instance.modules[moduleName],
            moduleParams = modulesParams[moduleName] || {};
          module.instance && Object.keys(module.instance).forEach(function (modulePropName) {
            var moduleProp = module.instance[modulePropName];
            instance[modulePropName] = "function" == typeof moduleProp ? moduleProp.bind(instance) : moduleProp
          }), module.on && instance.on && Object.keys(module.on).forEach(function (moduleEventName) {
            instance.on(moduleEventName, module.on[moduleEventName])
          }), module.create && module.create.bind(instance)(moduleParams)
        })
      }, staticAccessors.components.set = function (components) {
        this.use && this.use(components)
      }, SwiperClass.installModule = function (module) {
        for (var params = [], len = arguments.length - 1; 0 < len--;) params[len] = arguments[len + 1];
        var Class = this;
        Class.prototype.modules || (Class.prototype.modules = {});
        var name = module.name || Object.keys(Class.prototype.modules).length + "_" + Utils.now();
        return (Class.prototype.modules[name] = module).proto && Object.keys(module.proto).forEach(function (key) {
          Class.prototype[key] = module.proto[key]
        }), module.static && Object.keys(module.static).forEach(function (key) {
          Class[key] = module.static[key]
        }), module.install && module.install.apply(Class, params), Class
      }, SwiperClass.use = function (module) {
        for (var params = [], len = arguments.length - 1; 0 < len--;) params[len] = arguments[len + 1];
        var Class = this;
        return Array.isArray(module) ? (module.forEach(function (m) {
          return Class.installModule(m)
        }), Class) : Class.installModule.apply(Class, [module].concat(params))
      }, Object.defineProperties(SwiperClass, staticAccessors);
      var update = {
        updateSize: function () {
          var width, height, $el = this.$el;
          width = void 0 !== this.params.width ? this.params.width : $el[0].clientWidth, height = void 0 !== this.params.height ? this.params.height : $el[0].clientHeight, 0 === width && this.isHorizontal() || 0 === height && this.isVertical() || (width = width - parseInt($el.css("padding-left"), 10) - parseInt($el.css("padding-right"), 10), height = height - parseInt($el.css("padding-top"), 10) - parseInt($el.css("padding-bottom"), 10), Utils.extend(this, {
            width: width,
            height: height,
            size: this.isHorizontal() ? width : height
          }))
        },
        updateSlides: function () {
          var params = this.params,
            $wrapperEl = this.$wrapperEl,
            swiperSize = this.size,
            rtl = this.rtlTranslate,
            wrongRTL = this.wrongRTL,
            isVirtual = this.virtual && params.virtual.enabled,
            previousSlidesLength = isVirtual ? this.virtual.slides.length : this.slides.length,
            slides = $wrapperEl.children("." + this.params.slideClass),
            slidesLength = isVirtual ? this.virtual.slides.length : slides.length,
            snapGrid = [],
            slidesGrid = [],
            slidesSizesGrid = [],
            offsetBefore = params.slidesOffsetBefore;
          "function" == typeof offsetBefore && (offsetBefore = params.slidesOffsetBefore.call(this));
          var offsetAfter = params.slidesOffsetAfter;
          "function" == typeof offsetAfter && (offsetAfter = params.slidesOffsetAfter.call(this));
          var previousSnapGridLength = this.snapGrid.length,
            previousSlidesGridLength = this.snapGrid.length,
            spaceBetween = params.spaceBetween,
            slidePosition = -offsetBefore,
            prevSlideSize = 0,
            index = 0;
          if (void 0 !== swiperSize) {
            var slidesNumberEvenToRows, slideSize;
            "string" == typeof spaceBetween && 0 <= spaceBetween.indexOf("%") && (spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize), this.virtualSize = -spaceBetween, rtl ? slides.css({
              marginLeft: "",
              marginTop: ""
            }) : slides.css({
              marginRight: "",
              marginBottom: ""
            }), 1 < params.slidesPerColumn && (slidesNumberEvenToRows = Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / this.params.slidesPerColumn ? slidesLength : Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn, "auto" !== params.slidesPerView && "row" === params.slidesPerColumnFill && (slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn)));
            for (var newSlidesGrid, slidesPerColumn = params.slidesPerColumn, slidesPerRow = slidesNumberEvenToRows / slidesPerColumn, numFullColumns = slidesPerRow - (params.slidesPerColumn * slidesPerRow - slidesLength), i = 0; i < slidesLength; i += 1) {
              slideSize = 0;
              var slide = slides.eq(i);
              if (1 < params.slidesPerColumn) {
                var newSlideOrderIndex = void 0,
                  column = void 0,
                  row = void 0;
                "column" === params.slidesPerColumnFill ? (row = i - (column = Math.floor(i / slidesPerColumn)) * slidesPerColumn, (numFullColumns < column || column === numFullColumns && row === slidesPerColumn - 1) && slidesPerColumn <= (row += 1) && (row = 0, column += 1), newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn, slide.css({
                  "-webkit-box-ordinal-group": newSlideOrderIndex,
                  "-moz-box-ordinal-group": newSlideOrderIndex,
                  "-ms-flex-order": newSlideOrderIndex,
                  "-webkit-order": newSlideOrderIndex,
                  order: newSlideOrderIndex
                })) : column = i - (row = Math.floor(i / slidesPerRow)) * slidesPerRow, slide.css("margin-" + (this.isHorizontal() ? "top" : "left"), 0 !== row && params.spaceBetween && params.spaceBetween + "px").attr("data-swiper-column", column).attr("data-swiper-row", row)
              }
              if ("none" !== slide.css("display")) {
                if ("auto" === params.slidesPerView) {
                  var slideStyles = win.getComputedStyle(slide[0], null),
                    currentTransform = slide[0].style.transform,
                    currentWebKitTransform = slide[0].style.webkitTransform;
                  currentTransform && (slide[0].style.transform = "none"), currentWebKitTransform && (slide[0].style.webkitTransform = "none"), slideSize = this.isHorizontal() ? slide[0].getBoundingClientRect().width + parseFloat(slideStyles.getPropertyValue("margin-left")) + parseFloat(slideStyles.getPropertyValue("margin-right")) : slide[0].getBoundingClientRect().height + parseFloat(slideStyles.getPropertyValue("margin-top")) + parseFloat(slideStyles.getPropertyValue("margin-bottom")), currentTransform && (slide[0].style.transform = currentTransform), currentWebKitTransform && (slide[0].style.webkitTransform = currentWebKitTransform), params.roundLengths && (slideSize = Math.floor(slideSize))
                } else slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView, params.roundLengths && (slideSize = Math.floor(slideSize)), slides[i] && (this.isHorizontal() ? slides[i].style.width = slideSize + "px" : slides[i].style.height = slideSize + "px");
                slides[i] && (slides[i].swiperSlideSize = slideSize), slidesSizesGrid.push(slideSize), params.centeredSlides ? (slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween, 0 === prevSlideSize && 0 !== i && (slidePosition = slidePosition - swiperSize / 2 - spaceBetween), 0 === i && (slidePosition = slidePosition - swiperSize / 2 - spaceBetween), Math.abs(slidePosition) < .001 && (slidePosition = 0), params.roundLengths && (slidePosition = Math.floor(slidePosition)), index % params.slidesPerGroup == 0 && snapGrid.push(slidePosition), slidesGrid.push(slidePosition)) : (params.roundLengths && (slidePosition = Math.floor(slidePosition)), index % params.slidesPerGroup == 0 && snapGrid.push(slidePosition), slidesGrid.push(slidePosition), slidePosition = slidePosition + slideSize + spaceBetween), this.virtualSize += slideSize + spaceBetween, prevSlideSize = slideSize, index += 1
              }
            }
            if (this.virtualSize = Math.max(this.virtualSize, swiperSize) + offsetAfter, rtl && wrongRTL && ("slide" === params.effect || "coverflow" === params.effect) && $wrapperEl.css({
                width: this.virtualSize + params.spaceBetween + "px"
              }), Support.flexbox && !params.setWrapperSize || (this.isHorizontal() ? $wrapperEl.css({
                width: this.virtualSize + params.spaceBetween + "px"
              }) : $wrapperEl.css({
                height: this.virtualSize + params.spaceBetween + "px"
              })), 1 < params.slidesPerColumn && (this.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows, this.virtualSize = Math.ceil(this.virtualSize / params.slidesPerColumn) - params.spaceBetween, this.isHorizontal() ? $wrapperEl.css({
                width: this.virtualSize + params.spaceBetween + "px"
              }) : $wrapperEl.css({
                height: this.virtualSize + params.spaceBetween + "px"
              }), params.centeredSlides)) {
              newSlidesGrid = [];
              for (var i$1 = 0; i$1 < snapGrid.length; i$1 += 1) {
                var slidesGridItem = snapGrid[i$1];
                params.roundLengths && (slidesGridItem = Math.floor(slidesGridItem)), snapGrid[i$1] < this.virtualSize + snapGrid[0] && newSlidesGrid.push(slidesGridItem)
              }
              snapGrid = newSlidesGrid
            }
            if (!params.centeredSlides) {
              newSlidesGrid = [];
              for (var i$2 = 0; i$2 < snapGrid.length; i$2 += 1) {
                var slidesGridItem$1 = snapGrid[i$2];
                params.roundLengths && (slidesGridItem$1 = Math.floor(slidesGridItem$1)), snapGrid[i$2] <= this.virtualSize - swiperSize && newSlidesGrid.push(slidesGridItem$1)
              }
              snapGrid = newSlidesGrid, 1 < Math.floor(this.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) && snapGrid.push(this.virtualSize - swiperSize)
            }
            0 === snapGrid.length && (snapGrid = [0]), 0 !== params.spaceBetween && (this.isHorizontal() ? rtl ? slides.css({
              marginLeft: spaceBetween + "px"
            }) : slides.css({
              marginRight: spaceBetween + "px"
            }) : slides.css({
              marginBottom: spaceBetween + "px"
            })), Utils.extend(this, {
              slides: slides,
              snapGrid: snapGrid,
              slidesGrid: slidesGrid,
              slidesSizesGrid: slidesSizesGrid
            }), slidesLength !== previousSlidesLength && this.emit("slidesLengthChange"), snapGrid.length !== previousSnapGridLength && (this.params.watchOverflow && this.checkOverflow(), this.emit("snapGridLengthChange")), slidesGrid.length !== previousSlidesGridLength && this.emit("slidesGridLengthChange"), (params.watchSlidesProgress || params.watchSlidesVisibility) && this.updateSlidesOffset()
          }
        },
        updateAutoHeight: function (speed) {
          var i, activeSlides = [],
            newHeight = 0;
          if ("number" == typeof speed ? this.setTransition(speed) : !0 === speed && this.setTransition(this.params.speed), "auto" !== this.params.slidesPerView && 1 < this.params.slidesPerView)
            for (i = 0; i < Math.ceil(this.params.slidesPerView); i += 1) {
              var index = this.activeIndex + i;
              if (index > this.slides.length) break;
              activeSlides.push(this.slides.eq(index)[0])
            } else activeSlides.push(this.slides.eq(this.activeIndex)[0]);
          for (i = 0; i < activeSlides.length; i += 1)
            if (void 0 !== activeSlides[i]) {
              var height = activeSlides[i].offsetHeight;
              newHeight = newHeight < height ? height : newHeight
            }
          newHeight && this.$wrapperEl.css("height", newHeight + "px")
        },
        updateSlidesOffset: function () {
          for (var slides = this.slides, i = 0; i < slides.length; i += 1) slides[i].swiperSlideOffset = this.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop
        },
        updateSlidesProgress: function (translate) {
          void 0 === translate && (translate = this && this.translate || 0);
          var params = this.params,
            slides = this.slides,
            rtl = this.rtlTranslate;
          if (0 !== slides.length) {
            void 0 === slides[0].swiperSlideOffset && this.updateSlidesOffset();
            var offsetCenter = -translate;
            rtl && (offsetCenter = translate), slides.removeClass(params.slideVisibleClass);
            for (var i = 0; i < slides.length; i += 1) {
              var slide = slides[i],
                slideProgress = (offsetCenter + (params.centeredSlides ? this.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);
              if (params.watchSlidesVisibility) {
                var slideBefore = -(offsetCenter - slide.swiperSlideOffset),
                  slideAfter = slideBefore + this.slidesSizesGrid[i];
                (0 <= slideBefore && slideBefore < this.size || 0 < slideAfter && slideAfter <= this.size || slideBefore <= 0 && slideAfter >= this.size) && slides.eq(i).addClass(params.slideVisibleClass)
              }
              slide.progress = rtl ? -slideProgress : slideProgress
            }
          }
        },
        updateProgress: function (translate) {
          void 0 === translate && (translate = this && this.translate || 0);
          var params = this.params,
            translatesDiff = this.maxTranslate() - this.minTranslate(),
            progress = this.progress,
            isBeginning = this.isBeginning,
            isEnd = this.isEnd,
            wasBeginning = isBeginning,
            wasEnd = isEnd;
          0 === translatesDiff ? isEnd = isBeginning = !(progress = 0) : (isBeginning = (progress = (translate - this.minTranslate()) / translatesDiff) <= 0, isEnd = 1 <= progress), Utils.extend(this, {
            progress: progress,
            isBeginning: isBeginning,
            isEnd: isEnd
          }), (params.watchSlidesProgress || params.watchSlidesVisibility) && this.updateSlidesProgress(translate), isBeginning && !wasBeginning && this.emit("reachBeginning toEdge"), isEnd && !wasEnd && this.emit("reachEnd toEdge"), (wasBeginning && !isBeginning || wasEnd && !isEnd) && this.emit("fromEdge"), this.emit("progress", progress)
        },
        updateSlidesClasses: function () {
          var activeSlide, slides = this.slides,
            params = this.params,
            $wrapperEl = this.$wrapperEl,
            activeIndex = this.activeIndex,
            realIndex = this.realIndex,
            isVirtual = this.virtual && params.virtual.enabled;
          slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass), (activeSlide = isVirtual ? this.$wrapperEl.find("." + params.slideClass + '[data-swiper-slide-index="' + activeIndex + '"]') : slides.eq(activeIndex)).addClass(params.slideActiveClass), params.loop && (activeSlide.hasClass(params.slideDuplicateClass) ? $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ')[data-swiper-slide-index="' + realIndex + '"]').addClass(params.slideDuplicateActiveClass) : $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + '[data-swiper-slide-index="' + realIndex + '"]').addClass(params.slideDuplicateActiveClass));
          var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);
          params.loop && 0 === nextSlide.length && (nextSlide = slides.eq(0)).addClass(params.slideNextClass);
          var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);
          params.loop && 0 === prevSlide.length && (prevSlide = slides.eq(-1)).addClass(params.slidePrevClass), params.loop && (nextSlide.hasClass(params.slideDuplicateClass) ? $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ')[data-swiper-slide-index="' + nextSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicateNextClass) : $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + '[data-swiper-slide-index="' + nextSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicateNextClass), prevSlide.hasClass(params.slideDuplicateClass) ? $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ')[data-swiper-slide-index="' + prevSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicatePrevClass) : $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + '[data-swiper-slide-index="' + prevSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicatePrevClass))
        },
        updateActiveIndex: function (newActiveIndex) {
          var snapIndex, translate = this.rtlTranslate ? this.translate : -this.translate,
            slidesGrid = this.slidesGrid,
            snapGrid = this.snapGrid,
            params = this.params,
            previousIndex = this.activeIndex,
            previousRealIndex = this.realIndex,
            previousSnapIndex = this.snapIndex,
            activeIndex = newActiveIndex;
          if (void 0 === activeIndex) {
            for (var i = 0; i < slidesGrid.length; i += 1) void 0 !== slidesGrid[i + 1] ? translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2 ? activeIndex = i : translate >= slidesGrid[i] && translate < slidesGrid[i + 1] && (activeIndex = i + 1) : translate >= slidesGrid[i] && (activeIndex = i);
            params.normalizeSlideIndex && (activeIndex < 0 || void 0 === activeIndex) && (activeIndex = 0)
          }
          if ((snapIndex = 0 <= snapGrid.indexOf(translate) ? snapGrid.indexOf(translate) : Math.floor(activeIndex / params.slidesPerGroup)) >= snapGrid.length && (snapIndex = snapGrid.length - 1), activeIndex !== previousIndex) {
            var realIndex = parseInt(this.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
            Utils.extend(this, {
              snapIndex: snapIndex,
              realIndex: realIndex,
              previousIndex: previousIndex,
              activeIndex: activeIndex
            }), this.emit("activeIndexChange"), this.emit("snapIndexChange"), previousRealIndex !== realIndex && this.emit("realIndexChange"), this.emit("slideChange")
          } else snapIndex !== previousSnapIndex && (this.snapIndex = snapIndex, this.emit("snapIndexChange"))
        },
        updateClickedSlide: function (e) {
          var params = this.params,
            slide = $(e.target).closest("." + params.slideClass)[0],
            slideFound = !1;
          if (slide)
            for (var i = 0; i < this.slides.length; i += 1) this.slides[i] === slide && (slideFound = !0);
          if (!slide || !slideFound) return this.clickedSlide = void 0, void(this.clickedIndex = void 0);
          this.clickedSlide = slide, this.virtual && this.params.virtual.enabled ? this.clickedIndex = parseInt($(slide).attr("data-swiper-slide-index"), 10) : this.clickedIndex = $(slide).index(), params.slideToClickedSlide && void 0 !== this.clickedIndex && this.clickedIndex !== this.activeIndex && this.slideToClickedSlide()
        }
      };
      var translate = {
        getTranslate: function (axis) {
          void 0 === axis && (axis = this.isHorizontal() ? "x" : "y");
          var params = this.params,
            rtl = this.rtlTranslate,
            translate = this.translate,
            $wrapperEl = this.$wrapperEl;
          if (params.virtualTranslate) return rtl ? -translate : translate;
          var currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
          return rtl && (currentTranslate = -currentTranslate), currentTranslate || 0
        },
        setTranslate: function (translate, byController) {
          var rtl = this.rtlTranslate,
            params = this.params,
            $wrapperEl = this.$wrapperEl,
            progress = this.progress,
            x = 0,
            y = 0;
          this.isHorizontal() ? x = rtl ? -translate : translate : y = translate, params.roundLengths && (x = Math.floor(x), y = Math.floor(y)), params.virtualTranslate || (Support.transforms3d ? $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, 0px)") : $wrapperEl.transform("translate(" + x + "px, " + y + "px)")), this.previousTranslate = this.translate, this.translate = this.isHorizontal() ? x : y;
          var translatesDiff = this.maxTranslate() - this.minTranslate();
          (0 === translatesDiff ? 0 : (translate - this.minTranslate()) / translatesDiff) !== progress && this.updateProgress(translate), this.emit("setTranslate", this.translate, byController)
        },
        minTranslate: function () {
          return -this.snapGrid[0]
        },
        maxTranslate: function () {
          return -this.snapGrid[this.snapGrid.length - 1]
        }
      };
      var transition$1 = {
        setTransition: function (duration, byController) {
          this.$wrapperEl.transition(duration), this.emit("setTransition", duration, byController)
        },
        transitionStart: function (runCallbacks, direction) {
          void 0 === runCallbacks && (runCallbacks = !0);
          var activeIndex = this.activeIndex,
            params = this.params,
            previousIndex = this.previousIndex;
          params.autoHeight && this.updateAutoHeight();
          var dir = direction;
          if (dir || (dir = previousIndex < activeIndex ? "next" : activeIndex < previousIndex ? "prev" : "reset"), this.emit("transitionStart"), runCallbacks && activeIndex !== previousIndex) {
            if ("reset" === dir) return void this.emit("slideResetTransitionStart");
            this.emit("slideChangeTransitionStart"), "next" === dir ? this.emit("slideNextTransitionStart") : this.emit("slidePrevTransitionStart")
          }
        },
        transitionEnd: function (runCallbacks, direction) {
          void 0 === runCallbacks && (runCallbacks = !0);
          var activeIndex = this.activeIndex,
            previousIndex = this.previousIndex;
          this.animating = !1, this.setTransition(0);
          var dir = direction;
          if (dir || (dir = previousIndex < activeIndex ? "next" : activeIndex < previousIndex ? "prev" : "reset"), this.emit("transitionEnd"), runCallbacks && activeIndex !== previousIndex) {
            if ("reset" === dir) return void this.emit("slideResetTransitionEnd");
            this.emit("slideChangeTransitionEnd"), "next" === dir ? this.emit("slideNextTransitionEnd") : this.emit("slidePrevTransitionEnd")
          }
        }
      };
      var slide = {
        slideTo: function (index, speed, runCallbacks, internal) {
          void 0 === index && (index = 0), void 0 === speed && (speed = this.params.speed), void 0 === runCallbacks && (runCallbacks = !0);
          var swiper = this,
            slideIndex = index;
          slideIndex < 0 && (slideIndex = 0);
          var params = swiper.params,
            snapGrid = swiper.snapGrid,
            slidesGrid = swiper.slidesGrid,
            previousIndex = swiper.previousIndex,
            activeIndex = swiper.activeIndex,
            rtl = swiper.rtlTranslate;
          if (swiper.animating && params.preventInteractionOnTransition) return !1;
          var snapIndex = Math.floor(slideIndex / params.slidesPerGroup);
          snapIndex >= snapGrid.length && (snapIndex = snapGrid.length - 1), (activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks && swiper.emit("beforeSlideChangeStart");
          var direction, translate = -snapGrid[snapIndex];
          if (swiper.updateProgress(translate), params.normalizeSlideIndex)
            for (var i = 0; i < slidesGrid.length; i += 1) - Math.floor(100 * translate) >= Math.floor(100 * slidesGrid[i]) && (slideIndex = i);
          if (swiper.initialized && slideIndex !== activeIndex) {
            if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) return !1;
            if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate() && (activeIndex || 0) !== slideIndex) return !1
          }
          return direction = activeIndex < slideIndex ? "next" : slideIndex < activeIndex ? "prev" : "reset", rtl && -translate === swiper.translate || !rtl && translate === swiper.translate ? (swiper.updateActiveIndex(slideIndex), params.autoHeight && swiper.updateAutoHeight(), swiper.updateSlidesClasses(), "slide" !== params.effect && swiper.setTranslate(translate), "reset" !== direction && (swiper.transitionStart(runCallbacks, direction), swiper.transitionEnd(runCallbacks, direction)), !1) : (0 !== speed && Support.transition ? (swiper.setTransition(speed), swiper.setTranslate(translate), swiper.updateActiveIndex(slideIndex), swiper.updateSlidesClasses(), swiper.emit("beforeTransitionStart", speed, internal), swiper.transitionStart(runCallbacks, direction), swiper.animating || (swiper.animating = !0, swiper.onSlideToWrapperTransitionEnd || (swiper.onSlideToWrapperTransitionEnd = function (e) {
            swiper && !swiper.destroyed && e.target === this && (swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd), swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd), swiper.onSlideToWrapperTransitionEnd = null, delete swiper.onSlideToWrapperTransitionEnd, swiper.transitionEnd(runCallbacks, direction))
          }), swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd), swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd))) : (swiper.setTransition(0), swiper.setTranslate(translate), swiper.updateActiveIndex(slideIndex), swiper.updateSlidesClasses(), swiper.emit("beforeTransitionStart", speed, internal), swiper.transitionStart(runCallbacks, direction), swiper.transitionEnd(runCallbacks, direction)), !0)
        },
        slideToLoop: function (index, speed, runCallbacks, internal) {
          void 0 === index && (index = 0), void 0 === speed && (speed = this.params.speed), void 0 === runCallbacks && (runCallbacks = !0);
          var newIndex = index;
          return this.params.loop && (newIndex += this.loopedSlides), this.slideTo(newIndex, speed, runCallbacks, internal)
        },
        slideNext: function (speed, runCallbacks, internal) {
          void 0 === speed && (speed = this.params.speed), void 0 === runCallbacks && (runCallbacks = !0);
          var params = this.params,
            animating = this.animating;
          return params.loop ? !animating && (this.loopFix(), this._clientLeft = this.$wrapperEl[0].clientLeft, this.slideTo(this.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal)) : this.slideTo(this.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal)
        },
        slidePrev: function (speed, runCallbacks, internal) {
          void 0 === speed && (speed = this.params.speed), void 0 === runCallbacks && (runCallbacks = !0);
          var params = this.params,
            animating = this.animating,
            snapGrid = this.snapGrid,
            slidesGrid = this.slidesGrid,
            rtlTranslate = this.rtlTranslate;
          if (params.loop) {
            if (animating) return !1;
            this.loopFix(), this._clientLeft = this.$wrapperEl[0].clientLeft
          }

          function normalize(val) {
            return val < 0 ? -Math.floor(Math.abs(val)) : Math.floor(val)
          }
          var prevIndex, normalizedTranslate = normalize(rtlTranslate ? this.translate : -this.translate),
            normalizedSnapGrid = snapGrid.map(function (val) {
              return normalize(val)
            }),
            prevSnap = (slidesGrid.map(function (val) {
              return normalize(val)
            }), snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)], snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1]);
          return void 0 !== prevSnap && (prevIndex = slidesGrid.indexOf(prevSnap)) < 0 && (prevIndex = this.activeIndex - 1), this.slideTo(prevIndex, speed, runCallbacks, internal)
        },
        slideReset: function (speed, runCallbacks, internal) {
          return void 0 === speed && (speed = this.params.speed), void 0 === runCallbacks && (runCallbacks = !0), this.slideTo(this.activeIndex, speed, runCallbacks, internal)
        },
        slideToClosest: function (speed, runCallbacks, internal) {
          void 0 === speed && (speed = this.params.speed), void 0 === runCallbacks && (runCallbacks = !0);
          var index = this.activeIndex,
            snapIndex = Math.floor(index / this.params.slidesPerGroup);
          if (snapIndex < this.snapGrid.length - 1) {
            var translate = this.rtlTranslate ? this.translate : -this.translate,
              currentSnap = this.snapGrid[snapIndex];
            (this.snapGrid[snapIndex + 1] - currentSnap) / 2 < translate - currentSnap && (index = this.params.slidesPerGroup)
          }
          return this.slideTo(index, speed, runCallbacks, internal)
        },
        slideToClickedSlide: function () {
          var realIndex, swiper = this,
            params = swiper.params,
            $wrapperEl = swiper.$wrapperEl,
            slidesPerView = "auto" === params.slidesPerView ? swiper.slidesPerViewDynamic() : params.slidesPerView,
            slideToIndex = swiper.clickedIndex;
          if (params.loop) {
            if (swiper.animating) return;
            realIndex = parseInt($(swiper.clickedSlide).attr("data-swiper-slide-index"), 10), params.centeredSlides ? slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2 ? (swiper.loopFix(), slideToIndex = $wrapperEl.children("." + params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + params.slideDuplicateClass + ")").eq(0).index(), Utils.nextTick(function () {
              swiper.slideTo(slideToIndex)
            })) : swiper.slideTo(slideToIndex) : slideToIndex > swiper.slides.length - slidesPerView ? (swiper.loopFix(), slideToIndex = $wrapperEl.children("." + params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + params.slideDuplicateClass + ")").eq(0).index(), Utils.nextTick(function () {
              swiper.slideTo(slideToIndex)
            })) : swiper.slideTo(slideToIndex)
          } else swiper.slideTo(slideToIndex)
        }
      };
      var loop = {
        loopCreate: function () {
          var swiper = this,
            params = swiper.params,
            $wrapperEl = swiper.$wrapperEl;
          $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
          var slides = $wrapperEl.children("." + params.slideClass);
          if (params.loopFillGroupWithBlank) {
            var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
            if (blankSlidesNum !== params.slidesPerGroup) {
              for (var i = 0; i < blankSlidesNum; i += 1) {
                var blankNode = $(doc.createElement("div")).addClass(params.slideClass + " " + params.slideBlankClass);
                $wrapperEl.append(blankNode)
              }
              slides = $wrapperEl.children("." + params.slideClass)
            }
          }
          "auto" !== params.slidesPerView || params.loopedSlides || (params.loopedSlides = slides.length), swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10), swiper.loopedSlides += params.loopAdditionalSlides, swiper.loopedSlides > slides.length && (swiper.loopedSlides = slides.length);
          var prependSlides = [],
            appendSlides = [];
          slides.each(function (index, el) {
            var slide = $(el);
            index < swiper.loopedSlides && appendSlides.push(el), index < slides.length && index >= slides.length - swiper.loopedSlides && prependSlides.push(el), slide.attr("data-swiper-slide-index", index)
          });
          for (var i$1 = 0; i$1 < appendSlides.length; i$1 += 1) $wrapperEl.append($(appendSlides[i$1].cloneNode(!0)).addClass(params.slideDuplicateClass));
          for (var i$2 = prependSlides.length - 1; 0 <= i$2; i$2 -= 1) $wrapperEl.prepend($(prependSlides[i$2].cloneNode(!0)).addClass(params.slideDuplicateClass))
        },
        loopFix: function () {
          var newIndex, params = this.params,
            activeIndex = this.activeIndex,
            slides = this.slides,
            loopedSlides = this.loopedSlides,
            allowSlidePrev = this.allowSlidePrev,
            allowSlideNext = this.allowSlideNext,
            snapGrid = this.snapGrid,
            rtl = this.rtlTranslate;
          this.allowSlidePrev = !0, this.allowSlideNext = !0;
          var diff = -snapGrid[activeIndex] - this.getTranslate();
          activeIndex < loopedSlides ? (newIndex = slides.length - 3 * loopedSlides + activeIndex, newIndex += loopedSlides, this.slideTo(newIndex, 0, !1, !0) && 0 !== diff && this.setTranslate((rtl ? -this.translate : this.translate) - diff)) : ("auto" === params.slidesPerView && 2 * loopedSlides <= activeIndex || activeIndex >= slides.length - loopedSlides) && (newIndex = -slides.length + activeIndex + loopedSlides, newIndex += loopedSlides, this.slideTo(newIndex, 0, !1, !0) && 0 !== diff && this.setTranslate((rtl ? -this.translate : this.translate) - diff));
          this.allowSlidePrev = allowSlidePrev, this.allowSlideNext = allowSlideNext
        },
        loopDestroy: function () {
          var $wrapperEl = this.$wrapperEl,
            params = this.params,
            slides = this.slides;
          $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove(), slides.removeAttr("data-swiper-slide-index")
        }
      };
      var grabCursor = {
        setGrabCursor: function (moving) {
          if (!(Support.touch || !this.params.simulateTouch || this.params.watchOverflow && this.isLocked)) {
            var el = this.el;
            el.style.cursor = "move", el.style.cursor = moving ? "-webkit-grabbing" : "-webkit-grab", el.style.cursor = moving ? "-moz-grabbin" : "-moz-grab", el.style.cursor = moving ? "grabbing" : "grab"
          }
        },
        unsetGrabCursor: function () {
          Support.touch || this.params.watchOverflow && this.isLocked || (this.el.style.cursor = "")
        }
      };
      var manipulation = {
          appendSlide: function (slides) {
            var $wrapperEl = this.$wrapperEl,
              params = this.params;
            if (params.loop && this.loopDestroy(), "object" == typeof slides && "length" in slides)
              for (var i = 0; i < slides.length; i += 1) slides[i] && $wrapperEl.append(slides[i]);
            else $wrapperEl.append(slides);
            params.loop && this.loopCreate(), params.observer && Support.observer || this.update()
          },
          prependSlide: function (slides) {
            var params = this.params,
              $wrapperEl = this.$wrapperEl,
              activeIndex = this.activeIndex;
            params.loop && this.loopDestroy();
            var newActiveIndex = activeIndex + 1;
            if ("object" == typeof slides && "length" in slides) {
              for (var i = 0; i < slides.length; i += 1) slides[i] && $wrapperEl.prepend(slides[i]);
              newActiveIndex = activeIndex + slides.length
            } else $wrapperEl.prepend(slides);
            params.loop && this.loopCreate(), params.observer && Support.observer || this.update(), this.slideTo(newActiveIndex, 0, !1)
          },
          addSlide: function (index, slides) {
            var $wrapperEl = this.$wrapperEl,
              params = this.params,
              activeIndexBuffer = this.activeIndex;
            params.loop && (activeIndexBuffer -= this.loopedSlides, this.loopDestroy(), this.slides = $wrapperEl.children("." + params.slideClass));
            var baseLength = this.slides.length;
            if (index <= 0) this.prependSlide(slides);
            else if (baseLength <= index) this.appendSlide(slides);
            else {
              for (var newActiveIndex = index < activeIndexBuffer ? activeIndexBuffer + 1 : activeIndexBuffer, slidesBuffer = [], i = baseLength - 1; index <= i; i -= 1) {
                var currentSlide = this.slides.eq(i);
                currentSlide.remove(), slidesBuffer.unshift(currentSlide)
              }
              if ("object" == typeof slides && "length" in slides) {
                for (var i$1 = 0; i$1 < slides.length; i$1 += 1) slides[i$1] && $wrapperEl.append(slides[i$1]);
                newActiveIndex = index < activeIndexBuffer ? activeIndexBuffer + slides.length : activeIndexBuffer
              } else $wrapperEl.append(slides);
              for (var i$2 = 0; i$2 < slidesBuffer.length; i$2 += 1) $wrapperEl.append(slidesBuffer[i$2]);
              params.loop && this.loopCreate(), params.observer && Support.observer || this.update(), params.loop ? this.slideTo(newActiveIndex + this.loopedSlides, 0, !1) : this.slideTo(newActiveIndex, 0, !1)
            }
          },
          removeSlide: function (slidesIndexes) {
            var params = this.params,
              $wrapperEl = this.$wrapperEl,
              activeIndexBuffer = this.activeIndex;
            params.loop && (activeIndexBuffer -= this.loopedSlides, this.loopDestroy(), this.slides = $wrapperEl.children("." + params.slideClass));
            var indexToRemove, newActiveIndex = activeIndexBuffer;
            if ("object" == typeof slidesIndexes && "length" in slidesIndexes) {
              for (var i = 0; i < slidesIndexes.length; i += 1) indexToRemove = slidesIndexes[i], this.slides[indexToRemove] && this.slides.eq(indexToRemove).remove(), indexToRemove < newActiveIndex && (newActiveIndex -= 1);
              newActiveIndex = Math.max(newActiveIndex, 0)
            } else indexToRemove = slidesIndexes, this.slides[indexToRemove] && this.slides.eq(indexToRemove).remove(), indexToRemove < newActiveIndex && (newActiveIndex -= 1), newActiveIndex = Math.max(newActiveIndex, 0);
            params.loop && this.loopCreate(), params.observer && Support.observer || this.update(), params.loop ? this.slideTo(newActiveIndex + this.loopedSlides, 0, !1) : this.slideTo(newActiveIndex, 0, !1)
          },
          removeAllSlides: function () {
            for (var slidesIndexes = [], i = 0; i < this.slides.length; i += 1) slidesIndexes.push(i);
            this.removeSlide(slidesIndexes)
          }
        },
        Device = function () {
          var ua = win.navigator.userAgent,
            device = {
              ios: !1,
              android: !1,
              androidChrome: !1,
              desktop: !1,
              windows: !1,
              iphone: !1,
              ipod: !1,
              ipad: !1,
              cordova: win.cordova || win.phonegap,
              phonegap: win.cordova || win.phonegap
            },
            windows = ua.match(/(Windows Phone);?[\s\/]+([\d.]+)?/),
            android = ua.match(/(Android);?[\s\/]+([\d.]+)?/),
            ipad = ua.match(/(iPad).*OS\s([\d_]+)/),
            ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/),
            iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
          if (windows && (device.os = "windows", device.osVersion = windows[2], device.windows = !0), android && !windows && (device.os = "android", device.osVersion = android[2], device.android = !0, device.androidChrome = 0 <= ua.toLowerCase().indexOf("chrome")), (ipad || iphone || ipod) && (device.os = "ios", device.ios = !0), iphone && !ipod && (device.osVersion = iphone[2].replace(/_/g, "."), device.iphone = !0), ipad && (device.osVersion = ipad[2].replace(/_/g, "."), device.ipad = !0), ipod && (device.osVersion = ipod[3] ? ipod[3].replace(/_/g, ".") : null, device.iphone = !0), device.ios && device.osVersion && 0 <= ua.indexOf("Version/") && "10" === device.osVersion.split(".")[0] && (device.osVersion = ua.toLowerCase().split("version/")[1].split(" ")[0]), device.desktop = !(device.os || device.android || device.webView), device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i), device.os && "ios" === device.os) {
            var osVersionArr = device.osVersion.split("."),
              metaViewport = doc.querySelector('meta[name="viewport"]');
            device.minimalUi = !device.webView && (ipod || iphone) && (1 * osVersionArr[0] == 7 ? 1 <= 1 * osVersionArr[1] : 7 < 1 * osVersionArr[0]) && metaViewport && 0 <= metaViewport.getAttribute("content").indexOf("minimal-ui")
          }
          return device.pixelRatio = win.devicePixelRatio || 1, device
        }();

      function onResize() {
        var params = this.params,
          el = this.el;
        if (!el || 0 !== el.offsetWidth) {
          params.breakpoints && this.setBreakpoint();
          var allowSlideNext = this.allowSlideNext,
            allowSlidePrev = this.allowSlidePrev,
            snapGrid = this.snapGrid;
          if (this.allowSlideNext = !0, this.allowSlidePrev = !0, this.updateSize(), this.updateSlides(), params.freeMode) {
            var newTranslate = Math.min(Math.max(this.translate, this.maxTranslate()), this.minTranslate());
            this.setTranslate(newTranslate), this.updateActiveIndex(), this.updateSlidesClasses(), params.autoHeight && this.updateAutoHeight()
          } else this.updateSlidesClasses(), ("auto" === params.slidesPerView || 1 < params.slidesPerView) && this.isEnd && !this.params.centeredSlides ? this.slideTo(this.slides.length - 1, 0, !1, !0) : this.slideTo(this.activeIndex, 0, !1, !0);
          this.allowSlidePrev = allowSlidePrev, this.allowSlideNext = allowSlideNext, this.params.watchOverflow && snapGrid !== this.snapGrid && this.checkOverflow()
        }
      }
      var events = {
        attachEvents: function () {
          var params = this.params,
            touchEvents = this.touchEvents,
            el = this.el,
            wrapperEl = this.wrapperEl;
          this.onTouchStart = function (event) {
            var data = this.touchEventsData,
              params = this.params,
              touches = this.touches;
            if (!this.animating || !params.preventInteractionOnTransition) {
              var e = event;
              if (e.originalEvent && (e = e.originalEvent), data.isTouchEvent = "touchstart" === e.type, (data.isTouchEvent || !("which" in e) || 3 !== e.which) && (!data.isTouched || !data.isMoved))
                if (params.noSwiping && $(e.target).closest(params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass)[0]) this.allowClick = !0;
                else if (!params.swipeHandler || $(e).closest(params.swipeHandler)[0]) {
                touches.currentX = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX, touches.currentY = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY;
                var startX = touches.currentX,
                  startY = touches.currentY,
                  edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection,
                  edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
                if (!edgeSwipeDetection || !(startX <= edgeSwipeThreshold || startX >= win.screen.width - edgeSwipeThreshold)) {
                  if (Utils.extend(data, {
                      isTouched: !0,
                      isMoved: !1,
                      allowTouchCallbacks: !0,
                      isScrolling: void 0,
                      startMoving: void 0
                    }), touches.startX = startX, touches.startY = startY, data.touchStartTime = Utils.now(), this.allowClick = !0, this.updateSize(), this.swipeDirection = void 0, 0 < params.threshold && (data.allowThresholdMove = !1), "touchstart" !== e.type) {
                    var preventDefault = !0;
                    $(e.target).is(data.formElements) && (preventDefault = !1), doc.activeElement && $(doc.activeElement).is(data.formElements) && doc.activeElement !== e.target && doc.activeElement.blur(), preventDefault && this.allowTouchMove && e.preventDefault()
                  }
                  this.emit("touchStart", e)
                }
              }
            }
          }.bind(this), this.onTouchMove = function (event) {
            var data = this.touchEventsData,
              params = this.params,
              touches = this.touches,
              rtl = this.rtlTranslate,
              e = event;
            if (e.originalEvent && (e = e.originalEvent), data.isTouched) {
              if (!data.isTouchEvent || "mousemove" !== e.type) {
                var pageX = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX,
                  pageY = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY;
                if (e.preventedByNestedSwiper) return touches.startX = pageX, void(touches.startY = pageY);
                if (!this.allowTouchMove) return this.allowClick = !1, void(data.isTouched && (Utils.extend(touches, {
                  startX: pageX,
                  startY: pageY,
                  currentX: pageX,
                  currentY: pageY
                }), data.touchStartTime = Utils.now()));
                if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop)
                  if (this.isVertical()) {
                    if (pageY < touches.startY && this.translate <= this.maxTranslate() || pageY > touches.startY && this.translate >= this.minTranslate()) return data.isTouched = !1, void(data.isMoved = !1)
                  } else if (pageX < touches.startX && this.translate <= this.maxTranslate() || pageX > touches.startX && this.translate >= this.minTranslate()) return;
                if (data.isTouchEvent && doc.activeElement && e.target === doc.activeElement && $(e.target).is(data.formElements)) return data.isMoved = !0, void(this.allowClick = !1);
                if (data.allowTouchCallbacks && this.emit("touchMove", e), !(e.targetTouches && 1 < e.targetTouches.length)) {
                  touches.currentX = pageX, touches.currentY = pageY;
                  var touchAngle, diffX = touches.currentX - touches.startX,
                    diffY = touches.currentY - touches.startY;
                  if (!(this.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < this.params.threshold))
                    if (void 0 === data.isScrolling && (this.isHorizontal() && touches.currentY === touches.startY || this.isVertical() && touches.currentX === touches.startX ? data.isScrolling = !1 : 25 <= diffX * diffX + diffY * diffY && (touchAngle = 180 * Math.atan2(Math.abs(diffY), Math.abs(diffX)) / Math.PI, data.isScrolling = this.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle)), data.isScrolling && this.emit("touchMoveOpposite", e), void 0 === data.startMoving && (touches.currentX === touches.startX && touches.currentY === touches.startY || (data.startMoving = !0)), data.isScrolling) data.isTouched = !1;
                    else if (data.startMoving) {
                    this.allowClick = !1, e.preventDefault(), params.touchMoveStopPropagation && !params.nested && e.stopPropagation(), data.isMoved || (params.loop && this.loopFix(), data.startTranslate = this.getTranslate(), this.setTransition(0), this.animating && this.$wrapperEl.trigger("webkitTransitionEnd transitionend"), data.allowMomentumBounce = !1, !params.grabCursor || !0 !== this.allowSlideNext && !0 !== this.allowSlidePrev || this.setGrabCursor(!0), this.emit("sliderFirstMove", e)), this.emit("sliderMove", e), data.isMoved = !0;
                    var diff = this.isHorizontal() ? diffX : diffY;
                    touches.diff = diff, diff *= params.touchRatio, rtl && (diff = -diff), this.swipeDirection = 0 < diff ? "prev" : "next", data.currentTranslate = diff + data.startTranslate;
                    var disableParentSwiper = !0,
                      resistanceRatio = params.resistanceRatio;
                    if (params.touchReleaseOnEdges && (resistanceRatio = 0), 0 < diff && data.currentTranslate > this.minTranslate() ? (disableParentSwiper = !1, params.resistance && (data.currentTranslate = this.minTranslate() - 1 + Math.pow(-this.minTranslate() + data.startTranslate + diff, resistanceRatio))) : diff < 0 && data.currentTranslate < this.maxTranslate() && (disableParentSwiper = !1, params.resistance && (data.currentTranslate = this.maxTranslate() + 1 - Math.pow(this.maxTranslate() - data.startTranslate - diff, resistanceRatio))), disableParentSwiper && (e.preventedByNestedSwiper = !0), !this.allowSlideNext && "next" === this.swipeDirection && data.currentTranslate < data.startTranslate && (data.currentTranslate = data.startTranslate), !this.allowSlidePrev && "prev" === this.swipeDirection && data.currentTranslate > data.startTranslate && (data.currentTranslate = data.startTranslate), 0 < params.threshold) {
                      if (!(Math.abs(diff) > params.threshold || data.allowThresholdMove)) return void(data.currentTranslate = data.startTranslate);
                      if (!data.allowThresholdMove) return data.allowThresholdMove = !0, touches.startX = touches.currentX, touches.startY = touches.currentY, data.currentTranslate = data.startTranslate, void(touches.diff = this.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY)
                    }
                    params.followFinger && ((params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) && (this.updateActiveIndex(), this.updateSlidesClasses()), params.freeMode && (0 === data.velocities.length && data.velocities.push({
                      position: touches[this.isHorizontal() ? "startX" : "startY"],
                      time: data.touchStartTime
                    }), data.velocities.push({
                      position: touches[this.isHorizontal() ? "currentX" : "currentY"],
                      time: Utils.now()
                    })), this.updateProgress(data.currentTranslate), this.setTranslate(data.currentTranslate))
                  }
                }
              }
            } else data.startMoving && data.isScrolling && this.emit("touchMoveOpposite", e)
          }.bind(this), this.onTouchEnd = function (event) {
            var swiper = this,
              data = swiper.touchEventsData,
              params = swiper.params,
              touches = swiper.touches,
              rtl = swiper.rtlTranslate,
              $wrapperEl = swiper.$wrapperEl,
              slidesGrid = swiper.slidesGrid,
              snapGrid = swiper.snapGrid,
              e = event;
            if (e.originalEvent && (e = e.originalEvent), data.allowTouchCallbacks && swiper.emit("touchEnd", e), data.allowTouchCallbacks = !1, !data.isTouched) return data.isMoved && params.grabCursor && swiper.setGrabCursor(!1), data.isMoved = !1, void(data.startMoving = !1);
            params.grabCursor && data.isMoved && data.isTouched && (!0 === swiper.allowSlideNext || !0 === swiper.allowSlidePrev) && swiper.setGrabCursor(!1);
            var currentPos, touchEndTime = Utils.now(),
              timeDiff = touchEndTime - data.touchStartTime;
            if (swiper.allowClick && (swiper.updateClickedSlide(e), swiper.emit("tap", e), timeDiff < 300 && 300 < touchEndTime - data.lastClickTime && (data.clickTimeout && clearTimeout(data.clickTimeout), data.clickTimeout = Utils.nextTick(function () {
                swiper && !swiper.destroyed && swiper.emit("click", e)
              }, 300)), timeDiff < 300 && touchEndTime - data.lastClickTime < 300 && (data.clickTimeout && clearTimeout(data.clickTimeout), swiper.emit("doubleTap", e))), data.lastClickTime = Utils.now(), Utils.nextTick(function () {
                swiper.destroyed || (swiper.allowClick = !0)
              }), !data.isTouched || !data.isMoved || !swiper.swipeDirection || 0 === touches.diff || data.currentTranslate === data.startTranslate) return data.isTouched = !1, data.isMoved = !1, void(data.startMoving = !1);
            if (data.isTouched = !1, data.isMoved = !1, data.startMoving = !1, currentPos = params.followFinger ? rtl ? swiper.translate : -swiper.translate : -data.currentTranslate, params.freeMode) {
              if (currentPos < -swiper.minTranslate()) return void swiper.slideTo(swiper.activeIndex);
              if (currentPos > -swiper.maxTranslate()) return void(swiper.slides.length < snapGrid.length ? swiper.slideTo(snapGrid.length - 1) : swiper.slideTo(swiper.slides.length - 1));
              if (params.freeModeMomentum) {
                if (1 < data.velocities.length) {
                  var lastMoveEvent = data.velocities.pop(),
                    velocityEvent = data.velocities.pop(),
                    distance = lastMoveEvent.position - velocityEvent.position,
                    time = lastMoveEvent.time - velocityEvent.time;
                  swiper.velocity = distance / time, swiper.velocity /= 2, Math.abs(swiper.velocity) < params.freeModeMinimumVelocity && (swiper.velocity = 0), (150 < time || 300 < Utils.now() - lastMoveEvent.time) && (swiper.velocity = 0)
                } else swiper.velocity = 0;
                swiper.velocity *= params.freeModeMomentumVelocityRatio, data.velocities.length = 0;
                var momentumDuration = 1e3 * params.freeModeMomentumRatio,
                  momentumDistance = swiper.velocity * momentumDuration,
                  newPosition = swiper.translate + momentumDistance;
                rtl && (newPosition = -newPosition);
                var afterBouncePosition, needsLoopFix, doBounce = !1,
                  bounceAmount = 20 * Math.abs(swiper.velocity) * params.freeModeMomentumBounceRatio;
                if (newPosition < swiper.maxTranslate()) params.freeModeMomentumBounce ? (newPosition + swiper.maxTranslate() < -bounceAmount && (newPosition = swiper.maxTranslate() - bounceAmount), afterBouncePosition = swiper.maxTranslate(), doBounce = !0, data.allowMomentumBounce = !0) : newPosition = swiper.maxTranslate(), params.loop && params.centeredSlides && (needsLoopFix = !0);
                else if (newPosition > swiper.minTranslate()) params.freeModeMomentumBounce ? (newPosition - swiper.minTranslate() > bounceAmount && (newPosition = swiper.minTranslate() + bounceAmount), afterBouncePosition = swiper.minTranslate(), doBounce = !0, data.allowMomentumBounce = !0) : newPosition = swiper.minTranslate(), params.loop && params.centeredSlides && (needsLoopFix = !0);
                else if (params.freeModeSticky) {
                  for (var nextSlide, j = 0; j < snapGrid.length; j += 1)
                    if (snapGrid[j] > -newPosition) {
                      nextSlide = j;
                      break
                    }
                  newPosition = -(newPosition = Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || "next" === swiper.swipeDirection ? snapGrid[nextSlide] : snapGrid[nextSlide - 1])
                }
                if (needsLoopFix && swiper.once("transitionEnd", function () {
                    swiper.loopFix()
                  }), 0 !== swiper.velocity) momentumDuration = rtl ? Math.abs((-newPosition - swiper.translate) / swiper.velocity) : Math.abs((newPosition - swiper.translate) / swiper.velocity);
                else if (params.freeModeSticky) return void swiper.slideToClosest();
                params.freeModeMomentumBounce && doBounce ? (swiper.updateProgress(afterBouncePosition), swiper.setTransition(momentumDuration), swiper.setTranslate(newPosition), swiper.transitionStart(!0, swiper.swipeDirection), swiper.animating = !0, $wrapperEl.transitionEnd(function () {
                  swiper && !swiper.destroyed && data.allowMomentumBounce && (swiper.emit("momentumBounce"), swiper.setTransition(params.speed), swiper.setTranslate(afterBouncePosition), $wrapperEl.transitionEnd(function () {
                    swiper && !swiper.destroyed && swiper.transitionEnd()
                  }))
                })) : swiper.velocity ? (swiper.updateProgress(newPosition), swiper.setTransition(momentumDuration), swiper.setTranslate(newPosition), swiper.transitionStart(!0, swiper.swipeDirection), swiper.animating || (swiper.animating = !0, $wrapperEl.transitionEnd(function () {
                  swiper && !swiper.destroyed && swiper.transitionEnd()
                }))) : swiper.updateProgress(newPosition), swiper.updateActiveIndex(), swiper.updateSlidesClasses()
              } else if (params.freeModeSticky) return void swiper.slideToClosest();
              (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) && (swiper.updateProgress(), swiper.updateActiveIndex(), swiper.updateSlidesClasses())
            } else {
              for (var stopIndex = 0, groupSize = swiper.slidesSizesGrid[0], i = 0; i < slidesGrid.length; i += params.slidesPerGroup) void 0 !== slidesGrid[i + params.slidesPerGroup] ? currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup] && (groupSize = slidesGrid[(stopIndex = i) + params.slidesPerGroup] - slidesGrid[i]) : currentPos >= slidesGrid[i] && (stopIndex = i, groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2]);
              var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
              if (timeDiff > params.longSwipesMs) {
                if (!params.longSwipes) return void swiper.slideTo(swiper.activeIndex);
                "next" === swiper.swipeDirection && (ratio >= params.longSwipesRatio ? swiper.slideTo(stopIndex + params.slidesPerGroup) : swiper.slideTo(stopIndex)), "prev" === swiper.swipeDirection && (ratio > 1 - params.longSwipesRatio ? swiper.slideTo(stopIndex + params.slidesPerGroup) : swiper.slideTo(stopIndex))
              } else {
                if (!params.shortSwipes) return void swiper.slideTo(swiper.activeIndex);
                "next" === swiper.swipeDirection && swiper.slideTo(stopIndex + params.slidesPerGroup), "prev" === swiper.swipeDirection && swiper.slideTo(stopIndex)
              }
            }
          }.bind(this), this.onClick = function (e) {
            this.allowClick || (this.params.preventClicks && e.preventDefault(), this.params.preventClicksPropagation && this.animating && (e.stopPropagation(), e.stopImmediatePropagation()))
          }.bind(this);
          var target = "container" === params.touchEventsTarget ? el : wrapperEl,
            capture = !!params.nested;
          if (Support.touch || !Support.pointerEvents && !Support.prefixedPointerEvents) {
            if (Support.touch) {
              var passiveListener = !("touchstart" !== touchEvents.start || !Support.passiveListener || !params.passiveListeners) && {
                passive: !0,
                capture: !1
              };
              target.addEventListener(touchEvents.start, this.onTouchStart, passiveListener), target.addEventListener(touchEvents.move, this.onTouchMove, Support.passiveListener ? {
                passive: !1,
                capture: capture
              } : capture), target.addEventListener(touchEvents.end, this.onTouchEnd, passiveListener)
            }(params.simulateTouch && !Device.ios && !Device.android || params.simulateTouch && !Support.touch && Device.ios) && (target.addEventListener("mousedown", this.onTouchStart, !1), doc.addEventListener("mousemove", this.onTouchMove, capture), doc.addEventListener("mouseup", this.onTouchEnd, !1))
          } else target.addEventListener(touchEvents.start, this.onTouchStart, !1), doc.addEventListener(touchEvents.move, this.onTouchMove, capture), doc.addEventListener(touchEvents.end, this.onTouchEnd, !1);
          (params.preventClicks || params.preventClicksPropagation) && target.addEventListener("click", this.onClick, !0), this.on(Device.ios || Device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, !0)
        },
        detachEvents: function () {
          var params = this.params,
            touchEvents = this.touchEvents,
            el = this.el,
            wrapperEl = this.wrapperEl,
            target = "container" === params.touchEventsTarget ? el : wrapperEl,
            capture = !!params.nested;
          if (Support.touch || !Support.pointerEvents && !Support.prefixedPointerEvents) {
            if (Support.touch) {
              var passiveListener = !("onTouchStart" !== touchEvents.start || !Support.passiveListener || !params.passiveListeners) && {
                passive: !0,
                capture: !1
              };
              target.removeEventListener(touchEvents.start, this.onTouchStart, passiveListener), target.removeEventListener(touchEvents.move, this.onTouchMove, capture), target.removeEventListener(touchEvents.end, this.onTouchEnd, passiveListener)
            }(params.simulateTouch && !Device.ios && !Device.android || params.simulateTouch && !Support.touch && Device.ios) && (target.removeEventListener("mousedown", this.onTouchStart, !1), doc.removeEventListener("mousemove", this.onTouchMove, capture), doc.removeEventListener("mouseup", this.onTouchEnd, !1))
          } else target.removeEventListener(touchEvents.start, this.onTouchStart, !1), doc.removeEventListener(touchEvents.move, this.onTouchMove, capture), doc.removeEventListener(touchEvents.end, this.onTouchEnd, !1);
          (params.preventClicks || params.preventClicksPropagation) && target.removeEventListener("click", this.onClick, !0), this.off(Device.ios || Device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize)
        }
      };
      var ua, breakpoints = {
          setBreakpoint: function () {
            var activeIndex = this.activeIndex,
              initialized = this.initialized,
              loopedSlides = this.loopedSlides;
            void 0 === loopedSlides && (loopedSlides = 0);
            var params = this.params,
              breakpoints = params.breakpoints;
            if (breakpoints && (!breakpoints || 0 !== Object.keys(breakpoints).length)) {
              var breakpoint = this.getBreakpoint(breakpoints);
              if (breakpoint && this.currentBreakpoint !== breakpoint) {
                var breakPointsParams = breakpoint in breakpoints ? breakpoints[breakpoint] : this.originalParams,
                  needsReLoop = params.loop && breakPointsParams.slidesPerView !== params.slidesPerView;
                Utils.extend(this.params, breakPointsParams), Utils.extend(this, {
                  allowTouchMove: this.params.allowTouchMove,
                  allowSlideNext: this.params.allowSlideNext,
                  allowSlidePrev: this.params.allowSlidePrev
                }), this.currentBreakpoint = breakpoint, needsReLoop && initialized && (this.loopDestroy(), this.loopCreate(), this.updateSlides(), this.slideTo(activeIndex - loopedSlides + this.loopedSlides, 0, !1)), this.emit("breakpoint", breakPointsParams)
              }
            }
          },
          getBreakpoint: function (breakpoints) {
            if (breakpoints) {
              var breakpoint = !1,
                points = [];
              Object.keys(breakpoints).forEach(function (point) {
                points.push(point)
              }), points.sort(function (a, b) {
                return parseInt(a, 10) - parseInt(b, 10)
              });
              for (var i = 0; i < points.length; i += 1) {
                var point = points[i];
                point >= win.innerWidth && !breakpoint && (breakpoint = point)
              }
              return breakpoint || "max"
            }
          }
        },
        Browser = {
          isIE: !!win.navigator.userAgent.match(/Trident/g) || !!win.navigator.userAgent.match(/MSIE/g),
          isSafari: (ua = win.navigator.userAgent.toLowerCase(), 0 <= ua.indexOf("safari") && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0),
          isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent)
        };
      var defaults = {
          init: !0,
          direction: "horizontal",
          touchEventsTarget: "container",
          initialSlide: 0,
          speed: 300,
          preventInteractionOnTransition: !1,
          edgeSwipeDetection: !1,
          edgeSwipeThreshold: 20,
          freeMode: !1,
          freeModeMomentum: !0,
          freeModeMomentumRatio: 1,
          freeModeMomentumBounce: !0,
          freeModeMomentumBounceRatio: 1,
          freeModeMomentumVelocityRatio: 1,
          freeModeSticky: !1,
          freeModeMinimumVelocity: .02,
          autoHeight: !1,
          setWrapperSize: !1,
          virtualTranslate: !1,
          effect: "slide",
          breakpoints: void 0,
          spaceBetween: 0,
          slidesPerView: 1,
          slidesPerColumn: 1,
          slidesPerColumnFill: "column",
          slidesPerGroup: 1,
          centeredSlides: !1,
          slidesOffsetBefore: 0,
          slidesOffsetAfter: 0,
          normalizeSlideIndex: !0,
          watchOverflow: !1,
          roundLengths: !1,
          touchRatio: 1,
          touchAngle: 45,
          simulateTouch: !0,
          shortSwipes: !0,
          longSwipes: !0,
          longSwipesRatio: .5,
          longSwipesMs: 300,
          followFinger: !0,
          allowTouchMove: !0,
          threshold: 0,
          touchMoveStopPropagation: !0,
          touchReleaseOnEdges: !1,
          uniqueNavElements: !0,
          resistance: !0,
          resistanceRatio: .85,
          watchSlidesProgress: !1,
          watchSlidesVisibility: !1,
          grabCursor: !1,
          preventClicks: !0,
          preventClicksPropagation: !0,
          slideToClickedSlide: !1,
          preloadImages: !0,
          updateOnImagesReady: !0,
          loop: !1,
          loopAdditionalSlides: 0,
          loopedSlides: null,
          loopFillGroupWithBlank: !1,
          allowSlidePrev: !0,
          allowSlideNext: !0,
          swipeHandler: null,
          noSwiping: !0,
          noSwipingClass: "swiper-no-swiping",
          noSwipingSelector: null,
          passiveListeners: !0,
          containerModifierClass: "swiper-container-",
          slideClass: "swiper-slide",
          slideBlankClass: "swiper-slide-invisible-blank",
          slideActiveClass: "swiper-slide-active",
          slideDuplicateActiveClass: "swiper-slide-duplicate-active",
          slideVisibleClass: "swiper-slide-visible",
          slideDuplicateClass: "swiper-slide-duplicate",
          slideNextClass: "swiper-slide-next",
          slideDuplicateNextClass: "swiper-slide-duplicate-next",
          slidePrevClass: "swiper-slide-prev",
          slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
          wrapperClass: "swiper-wrapper",
          runCallbacksOnInit: !0
        },
        prototypes = {
          update: update,
          translate: translate,
          transition: transition$1,
          slide: slide,
          loop: loop,
          grabCursor: grabCursor,
          manipulation: manipulation,
          events: events,
          breakpoints: breakpoints,
          checkOverflow: {
            checkOverflow: function () {
              var wasLocked = this.isLocked;
              this.isLocked = 1 === this.snapGrid.length, this.allowSlideNext = !this.isLocked, this.allowSlidePrev = !this.isLocked, wasLocked !== this.isLocked && this.emit(this.isLocked ? "lock" : "unlock"), wasLocked && wasLocked !== this.isLocked && (this.isEnd = !1, this.navigation.update())
            }
          },
          classes: {
            addClasses: function () {
              var classNames = this.classNames,
                params = this.params,
                rtl = this.rtl,
                $el = this.$el,
                suffixes = [];
              suffixes.push(params.direction), params.freeMode && suffixes.push("free-mode"), Support.flexbox || suffixes.push("no-flexbox"), params.autoHeight && suffixes.push("autoheight"), rtl && suffixes.push("rtl"), 1 < params.slidesPerColumn && suffixes.push("multirow"), Device.android && suffixes.push("android"), Device.ios && suffixes.push("ios"), Browser.isIE && (Support.pointerEvents || Support.prefixedPointerEvents) && suffixes.push("wp8-" + params.direction), suffixes.forEach(function (suffix) {
                classNames.push(params.containerModifierClass + suffix)
              }), $el.addClass(classNames.join(" "))
            },
            removeClasses: function () {
              var $el = this.$el,
                classNames = this.classNames;
              $el.removeClass(classNames.join(" "))
            }
          },
          images: {
            loadImage: function (imageEl, src, srcset, sizes, checkForComplete, callback) {
              var image;

              function onReady() {
                callback && callback()
              }
              imageEl.complete && checkForComplete ? onReady() : src ? ((image = new win.Image).onload = onReady, image.onerror = onReady, sizes && (image.sizes = sizes), srcset && (image.srcset = srcset), src && (image.src = src)) : onReady()
            },
            preloadImages: function () {
              var swiper = this;

              function onReady() {
                null != swiper && swiper && !swiper.destroyed && (void 0 !== swiper.imagesLoaded && (swiper.imagesLoaded += 1), swiper.imagesLoaded === swiper.imagesToLoad.length && (swiper.params.updateOnImagesReady && swiper.update(), swiper.emit("imagesReady")))
              }
              swiper.imagesToLoad = swiper.$el.find("img");
              for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
                var imageEl = swiper.imagesToLoad[i];
                swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), !0, onReady)
              }
            }
          }
        },
        extendedDefaults = {},
        Swiper = function (SwiperClass$$1) {
          function Swiper() {
            for (var assign, el, params, args = [], len = arguments.length; len--;) args[len] = arguments[len];
            1 === args.length && args[0].constructor && args[0].constructor === Object ? params = args[0] : (el = (assign = args)[0], params = assign[1]), params || (params = {}), params = Utils.extend({}, params), el && !params.el && (params.el = el), SwiperClass$$1.call(this, params), Object.keys(prototypes).forEach(function (prototypeGroup) {
              Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
                Swiper.prototype[protoMethod] || (Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod])
              })
            });
            var swiper = this;
            void 0 === swiper.modules && (swiper.modules = {}), Object.keys(swiper.modules).forEach(function (moduleName) {
              var module = swiper.modules[moduleName];
              if (module.params) {
                var moduleParamName = Object.keys(module.params)[0],
                  moduleParams = module.params[moduleParamName];
                if ("object" != typeof moduleParams) return;
                if (!(moduleParamName in params && "enabled" in moduleParams)) return;
                !0 === params[moduleParamName] && (params[moduleParamName] = {
                  enabled: !0
                }), "object" != typeof params[moduleParamName] || "enabled" in params[moduleParamName] || (params[moduleParamName].enabled = !0), params[moduleParamName] || (params[moduleParamName] = {
                  enabled: !1
                })
              }
            });
            var swiperParams = Utils.extend({}, defaults);
            swiper.useModulesParams(swiperParams), swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params), swiper.originalParams = Utils.extend({}, swiper.params), swiper.passedParams = Utils.extend({}, params);
            var $el = (swiper.$ = $)(swiper.params.el);
            if (el = $el[0]) {
              if (1 < $el.length) {
                var swipers = [];
                return $el.each(function (index, containerEl) {
                  var newParams = Utils.extend({}, params, {
                    el: containerEl
                  });
                  swipers.push(new Swiper(newParams))
                }), swipers
              }
              el.swiper = swiper, $el.data("swiper", swiper);
              var touch, desktop, $wrapperEl = $el.children("." + swiper.params.wrapperClass);
              return Utils.extend(swiper, {
                $el: $el,
                el: el,
                $wrapperEl: $wrapperEl,
                wrapperEl: $wrapperEl[0],
                classNames: [],
                slides: $(),
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal: function () {
                  return "horizontal" === swiper.params.direction
                },
                isVertical: function () {
                  return "vertical" === swiper.params.direction
                },
                rtl: "rtl" === el.dir.toLowerCase() || "rtl" === $el.css("direction"),
                rtlTranslate: "horizontal" === swiper.params.direction && ("rtl" === el.dir.toLowerCase() || "rtl" === $el.css("direction")),
                wrongRTL: "-webkit-box" === $wrapperEl.css("display"),
                activeIndex: 0,
                realIndex: 0,
                isBeginning: !0,
                isEnd: !1,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: !1,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev,
                touchEvents: (touch = ["touchstart", "touchmove", "touchend"], desktop = ["mousedown", "mousemove", "mouseup"], Support.pointerEvents ? desktop = ["pointerdown", "pointermove", "pointerup"] : Support.prefixedPointerEvents && (desktop = ["MSPointerDown", "MSPointerMove", "MSPointerUp"]), swiper.touchEventsTouch = {
                  start: touch[0],
                  move: touch[1],
                  end: touch[2]
                }, swiper.touchEventsDesktop = {
                  start: desktop[0],
                  move: desktop[1],
                  end: desktop[2]
                }, Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop),
                touchEventsData: {
                  isTouched: void 0,
                  isMoved: void 0,
                  allowTouchCallbacks: void 0,
                  touchStartTime: void 0,
                  isScrolling: void 0,
                  currentTranslate: void 0,
                  startTranslate: void 0,
                  allowThresholdMove: void 0,
                  formElements: "input, select, option, textarea, button, video",
                  lastClickTime: Utils.now(),
                  clickTimeout: void 0,
                  velocities: [],
                  allowMomentumBounce: void 0,
                  isTouchEvent: void 0,
                  startMoving: void 0
                },
                allowClick: !0,
                allowTouchMove: swiper.params.allowTouchMove,
                touches: {
                  startX: 0,
                  startY: 0,
                  currentX: 0,
                  currentY: 0,
                  diff: 0
                },
                imagesToLoad: [],
                imagesLoaded: 0
              }), swiper.useModules(), swiper.params.init && swiper.init(), swiper
            }
          }
          SwiperClass$$1 && (Swiper.__proto__ = SwiperClass$$1);
          var staticAccessors = {
            extendedDefaults: {
              configurable: !0
            },
            defaults: {
              configurable: !0
            },
            Class: {
              configurable: !0
            },
            $: {
              configurable: !0
            }
          };
          return ((Swiper.prototype = Object.create(SwiperClass$$1 && SwiperClass$$1.prototype)).constructor = Swiper).prototype.slidesPerViewDynamic = function () {
            var params = this.params,
              slides = this.slides,
              slidesGrid = this.slidesGrid,
              swiperSize = this.size,
              activeIndex = this.activeIndex,
              spv = 1;
            if (params.centeredSlides) {
              for (var breakLoop, slideSize = slides[activeIndex].swiperSlideSize, i = activeIndex + 1; i < slides.length; i += 1) slides[i] && !breakLoop && (spv += 1, swiperSize < (slideSize += slides[i].swiperSlideSize) && (breakLoop = !0));
              for (var i$1 = activeIndex - 1; 0 <= i$1; i$1 -= 1) slides[i$1] && !breakLoop && (spv += 1, swiperSize < (slideSize += slides[i$1].swiperSlideSize) && (breakLoop = !0))
            } else
              for (var i$2 = activeIndex + 1; i$2 < slides.length; i$2 += 1) slidesGrid[i$2] - slidesGrid[activeIndex] < swiperSize && (spv += 1);
            return spv
          }, Swiper.prototype.update = function () {
            var swiper = this;
            if (swiper && !swiper.destroyed) {
              var snapGrid = swiper.snapGrid,
                params = swiper.params;
              params.breakpoints && swiper.setBreakpoint(), swiper.updateSize(), swiper.updateSlides(), swiper.updateProgress(), swiper.updateSlidesClasses(), swiper.params.freeMode ? (setTranslate(), swiper.params.autoHeight && swiper.updateAutoHeight()) : (("auto" === swiper.params.slidesPerView || 1 < swiper.params.slidesPerView) && swiper.isEnd && !swiper.params.centeredSlides ? swiper.slideTo(swiper.slides.length - 1, 0, !1, !0) : swiper.slideTo(swiper.activeIndex, 0, !1, !0)) || setTranslate(), params.watchOverflow && snapGrid !== swiper.snapGrid && swiper.checkOverflow(), swiper.emit("update")
            }

            function setTranslate() {
              var translateValue = swiper.rtlTranslate ? -1 * swiper.translate : swiper.translate,
                newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
              swiper.setTranslate(newTranslate), swiper.updateActiveIndex(), swiper.updateSlidesClasses()
            }
          }, Swiper.prototype.init = function () {
            this.initialized || (this.emit("beforeInit"), this.params.breakpoints && this.setBreakpoint(), this.addClasses(), this.params.loop && this.loopCreate(), this.updateSize(), this.updateSlides(), this.params.watchOverflow && this.checkOverflow(), this.params.grabCursor && this.setGrabCursor(), this.params.preloadImages && this.preloadImages(), this.params.loop ? this.slideTo(this.params.initialSlide + this.loopedSlides, 0, this.params.runCallbacksOnInit) : this.slideTo(this.params.initialSlide, 0, this.params.runCallbacksOnInit), this.attachEvents(), this.initialized = !0, this.emit("init"))
          }, Swiper.prototype.destroy = function (deleteInstance, cleanStyles) {
            void 0 === deleteInstance && (deleteInstance = !0), void 0 === cleanStyles && (cleanStyles = !0);
            var swiper = this,
              params = swiper.params,
              $el = swiper.$el,
              $wrapperEl = swiper.$wrapperEl,
              slides = swiper.slides;
            return void 0 === swiper.params || swiper.destroyed || (swiper.emit("beforeDestroy"), swiper.initialized = !1, swiper.detachEvents(), params.loop && swiper.loopDestroy(), cleanStyles && (swiper.removeClasses(), $el.removeAttr("style"), $wrapperEl.removeAttr("style"), slides && slides.length && slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index").removeAttr("data-swiper-column").removeAttr("data-swiper-row")), swiper.emit("destroy"), Object.keys(swiper.eventsListeners).forEach(function (eventName) {
              swiper.off(eventName)
            }), !1 !== deleteInstance && (swiper.$el[0].swiper = null, swiper.$el.data("swiper", null), Utils.deleteProps(swiper)), swiper.destroyed = !0), null
          }, Swiper.extendDefaults = function (newDefaults) {
            Utils.extend(extendedDefaults, newDefaults)
          }, staticAccessors.extendedDefaults.get = function () {
            return extendedDefaults
          }, staticAccessors.defaults.get = function () {
            return defaults
          }, staticAccessors.Class.get = function () {
            return SwiperClass$$1
          }, staticAccessors.$.get = function () {
            return $
          }, Object.defineProperties(Swiper, staticAccessors), Swiper
        }(SwiperClass),
        Device$1 = {
          name: "device",
          proto: {
            device: Device
          },
          static: {
            device: Device
          }
        },
        Support$1 = {
          name: "support",
          proto: {
            support: Support
          },
          static: {
            support: Support
          }
        },
        Browser$1 = {
          name: "browser",
          proto: {
            browser: Browser
          },
          static: {
            browser: Browser
          }
        },
        Resize = {
          name: "resize",
          create: function () {
            var swiper = this;
            Utils.extend(swiper, {
              resize: {
                resizeHandler: function () {
                  swiper && !swiper.destroyed && swiper.initialized && (swiper.emit("beforeResize"), swiper.emit("resize"))
                },
                orientationChangeHandler: function () {
                  swiper && !swiper.destroyed && swiper.initialized && swiper.emit("orientationchange")
                }
              }
            })
          },
          on: {
            init: function () {
              win.addEventListener("resize", this.resize.resizeHandler), win.addEventListener("orientationchange", this.resize.orientationChangeHandler)
            },
            destroy: function () {
              win.removeEventListener("resize", this.resize.resizeHandler), win.removeEventListener("orientationchange", this.resize.orientationChangeHandler)
            }
          }
        },
        Observer = {
          func: win.MutationObserver || win.WebkitMutationObserver,
          attach: function (target, options) {
            void 0 === options && (options = {});
            var swiper = this,
              observer = new(0, Observer.func)(function (mutations) {
                if (1 !== mutations.length) {
                  var observerUpdate = function () {
                    swiper.emit("observerUpdate", mutations[0])
                  };
                  win.requestAnimationFrame ? win.requestAnimationFrame(observerUpdate) : win.setTimeout(observerUpdate, 0)
                } else swiper.emit("observerUpdate", mutations[0])
              });
            observer.observe(target, {
              attributes: void 0 === options.attributes || options.attributes,
              childList: void 0 === options.childList || options.childList,
              characterData: void 0 === options.characterData || options.characterData
            }), swiper.observer.observers.push(observer)
          },
          init: function () {
            if (Support.observer && this.params.observer) {
              if (this.params.observeParents)
                for (var containerParents = this.$el.parents(), i = 0; i < containerParents.length; i += 1) this.observer.attach(containerParents[i]);
              this.observer.attach(this.$el[0], {
                childList: !1
              }), this.observer.attach(this.$wrapperEl[0], {
                attributes: !1
              })
            }
          },
          destroy: function () {
            this.observer.observers.forEach(function (observer) {
              observer.disconnect()
            }), this.observer.observers = []
          }
        },
        Observer$1 = {
          name: "observer",
          params: {
            observer: !1,
            observeParents: !1
          },
          create: function () {
            Utils.extend(this, {
              observer: {
                init: Observer.init.bind(this),
                attach: Observer.attach.bind(this),
                destroy: Observer.destroy.bind(this),
                observers: []
              }
            })
          },
          on: {
            init: function () {
              this.observer.init()
            },
            destroy: function () {
              this.observer.destroy()
            }
          }
        },
        Virtual = {
          update: function (force) {
            var swiper = this,
              ref = swiper.params,
              slidesPerView = ref.slidesPerView,
              slidesPerGroup = ref.slidesPerGroup,
              centeredSlides = ref.centeredSlides,
              ref$1 = swiper.virtual,
              previousFrom = ref$1.from,
              previousTo = ref$1.to,
              slides = ref$1.slides,
              previousSlidesGrid = ref$1.slidesGrid,
              renderSlide = ref$1.renderSlide,
              previousOffset = ref$1.offset;
            swiper.updateActiveIndex();
            var offsetProp, slidesAfter, slidesBefore, activeIndex = swiper.activeIndex || 0;
            offsetProp = swiper.rtlTranslate ? "right" : swiper.isHorizontal() ? "left" : "top", centeredSlides ? (slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup, slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup) : (slidesAfter = slidesPerView + (slidesPerGroup - 1), slidesBefore = slidesPerGroup);
            var from = Math.max((activeIndex || 0) - slidesBefore, 0),
              to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1),
              offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);

            function onRendered() {
              swiper.updateSlides(), swiper.updateProgress(), swiper.updateSlidesClasses(), swiper.lazy && swiper.params.lazy.enabled && swiper.lazy.load()
            }
            if (Utils.extend(swiper.virtual, {
                from: from,
                to: to,
                offset: offset,
                slidesGrid: swiper.slidesGrid
              }), previousFrom === from && previousTo === to && !force) return swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset && swiper.slides.css(offsetProp, offset + "px"), void swiper.updateProgress();
            if (swiper.params.virtual.renderExternal) return swiper.params.virtual.renderExternal.call(swiper, {
              offset: offset,
              from: from,
              to: to,
              slides: function () {
                for (var slidesToRender = [], i = from; i <= to; i += 1) slidesToRender.push(slides[i]);
                return slidesToRender
              }()
            }), void onRendered();
            var prependIndexes = [],
              appendIndexes = [];
            if (force) swiper.$wrapperEl.find("." + swiper.params.slideClass).remove();
            else
              for (var i = previousFrom; i <= previousTo; i += 1)(i < from || to < i) && swiper.$wrapperEl.find("." + swiper.params.slideClass + '[data-swiper-slide-index="' + i + '"]').remove();
            for (var i$1 = 0; i$1 < slides.length; i$1 += 1) from <= i$1 && i$1 <= to && (void 0 === previousTo || force ? appendIndexes.push(i$1) : (previousTo < i$1 && appendIndexes.push(i$1), i$1 < previousFrom && prependIndexes.push(i$1)));
            appendIndexes.forEach(function (index) {
              swiper.$wrapperEl.append(renderSlide(slides[index], index))
            }), prependIndexes.sort(function (a, b) {
              return a < b
            }).forEach(function (index) {
              swiper.$wrapperEl.prepend(renderSlide(slides[index], index))
            }), swiper.$wrapperEl.children(".swiper-slide").css(offsetProp, offset + "px"), onRendered()
          },
          renderSlide: function (slide, index) {
            var params = this.params.virtual;
            if (params.cache && this.virtual.cache[index]) return this.virtual.cache[index];
            var $slideEl = params.renderSlide ? $(params.renderSlide.call(this, slide, index)) : $('<div class="' + this.params.slideClass + '" data-swiper-slide-index="' + index + '">' + slide + "</div>");
            return $slideEl.attr("data-swiper-slide-index") || $slideEl.attr("data-swiper-slide-index", index), params.cache && (this.virtual.cache[index] = $slideEl), $slideEl
          },
          appendSlide: function (slide) {
            this.virtual.slides.push(slide), this.virtual.update(!0)
          },
          prependSlide: function (slide) {
            if (this.virtual.slides.unshift(slide), this.params.virtual.cache) {
              var cache = this.virtual.cache,
                newCache = {};
              Object.keys(cache).forEach(function (cachedIndex) {
                newCache[cachedIndex + 1] = cache[cachedIndex]
              }), this.virtual.cache = newCache
            }
            this.virtual.update(!0), this.slideNext(0)
          }
        },
        Virtual$1 = {
          name: "virtual",
          params: {
            virtual: {
              enabled: !1,
              slides: [],
              cache: !0,
              renderSlide: null,
              renderExternal: null
            }
          },
          create: function () {
            Utils.extend(this, {
              virtual: {
                update: Virtual.update.bind(this),
                appendSlide: Virtual.appendSlide.bind(this),
                prependSlide: Virtual.prependSlide.bind(this),
                renderSlide: Virtual.renderSlide.bind(this),
                slides: this.params.virtual.slides,
                cache: {}
              }
            })
          },
          on: {
            beforeInit: function () {
              if (this.params.virtual.enabled) {
                this.classNames.push(this.params.containerModifierClass + "virtual");
                var overwriteParams = {
                  watchSlidesProgress: !0
                };
                Utils.extend(this.params, overwriteParams), Utils.extend(this.originalParams, overwriteParams), this.virtual.update()
              }
            },
            setTranslate: function () {
              this.params.virtual.enabled && this.virtual.update()
            }
          }
        },
        Keyboard = {
          handle: function (event) {
            var rtl = this.rtlTranslate,
              e = event;
            e.originalEvent && (e = e.originalEvent);
            var kc = e.keyCode || e.charCode;
            if (!this.allowSlideNext && (this.isHorizontal() && 39 === kc || this.isVertical() && 40 === kc)) return !1;
            if (!this.allowSlidePrev && (this.isHorizontal() && 37 === kc || this.isVertical() && 38 === kc)) return !1;
            if (!(e.shiftKey || e.altKey || e.ctrlKey || e.metaKey || doc.activeElement && doc.activeElement.nodeName && ("input" === doc.activeElement.nodeName.toLowerCase() || "textarea" === doc.activeElement.nodeName.toLowerCase()))) {
              if (this.params.keyboard.onlyInViewport && (37 === kc || 39 === kc || 38 === kc || 40 === kc)) {
                var inView = !1;
                if (0 < this.$el.parents("." + this.params.slideClass).length && 0 === this.$el.parents("." + this.params.slideActiveClass).length) return;
                var windowWidth = win.innerWidth,
                  windowHeight = win.innerHeight,
                  swiperOffset = this.$el.offset();
                rtl && (swiperOffset.left -= this.$el[0].scrollLeft);
                for (var swiperCoord = [
                    [swiperOffset.left, swiperOffset.top],
                    [swiperOffset.left + this.width, swiperOffset.top],
                    [swiperOffset.left, swiperOffset.top + this.height],
                    [swiperOffset.left + this.width, swiperOffset.top + this.height]
                  ], i = 0; i < swiperCoord.length; i += 1) {
                  var point = swiperCoord[i];
                  0 <= point[0] && point[0] <= windowWidth && 0 <= point[1] && point[1] <= windowHeight && (inView = !0)
                }
                if (!inView) return
              }
              this.isHorizontal() ? (37 !== kc && 39 !== kc || (e.preventDefault ? e.preventDefault() : e.returnValue = !1), (39 === kc && !rtl || 37 === kc && rtl) && this.slideNext(), (37 === kc && !rtl || 39 === kc && rtl) && this.slidePrev()) : (38 !== kc && 40 !== kc || (e.preventDefault ? e.preventDefault() : e.returnValue = !1), 40 === kc && this.slideNext(), 38 === kc && this.slidePrev()), this.emit("keyPress", kc)
            }
          },
          enable: function () {
            this.keyboard.enabled || ($(doc).on("keydown", this.keyboard.handle), this.keyboard.enabled = !0)
          },
          disable: function () {
            this.keyboard.enabled && ($(doc).off("keydown", this.keyboard.handle), this.keyboard.enabled = !1)
          }
        },
        Keyboard$1 = {
          name: "keyboard",
          params: {
            keyboard: {
              enabled: !1,
              onlyInViewport: !0
            }
          },
          create: function () {
            Utils.extend(this, {
              keyboard: {
                enabled: !1,
                enable: Keyboard.enable.bind(this),
                disable: Keyboard.disable.bind(this),
                handle: Keyboard.handle.bind(this)
              }
            })
          },
          on: {
            init: function () {
              this.params.keyboard.enabled && this.keyboard.enable()
            },
            destroy: function () {
              this.keyboard.enabled && this.keyboard.disable()
            }
          }
        };
      var Mousewheel = {
          lastScrollTime: Utils.now(),
          event: -1 < win.navigator.userAgent.indexOf("firefox") ? "DOMMouseScroll" : function () {
            var isSupported = "onwheel" in doc;
            if (!isSupported) {
              var element = doc.createElement("div");
              element.setAttribute("onwheel", "return;"), isSupported = "function" == typeof element.onwheel
            }
            return !isSupported && doc.implementation && doc.implementation.hasFeature && !0 !== doc.implementation.hasFeature("", "") && (isSupported = doc.implementation.hasFeature("Events.wheel", "3.0")), isSupported
          }() ? "wheel" : "mousewheel",
          normalize: function (e) {
            var sX = 0,
              sY = 0,
              pX = 0,
              pY = 0;
            return "detail" in e && (sY = e.detail), "wheelDelta" in e && (sY = -e.wheelDelta / 120), "wheelDeltaY" in e && (sY = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (sX = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (sX = sY, sY = 0), pX = 10 * sX, pY = 10 * sY, "deltaY" in e && (pY = e.deltaY), "deltaX" in e && (pX = e.deltaX), (pX || pY) && e.deltaMode && (1 === e.deltaMode ? (pX *= 40, pY *= 40) : (pX *= 800, pY *= 800)), pX && !sX && (sX = pX < 1 ? -1 : 1), pY && !sY && (sY = pY < 1 ? -1 : 1), {
              spinX: sX,
              spinY: sY,
              pixelX: pX,
              pixelY: pY
            }
          },
          handleMouseEnter: function () {
            this.mouseEntered = !0
          },
          handleMouseLeave: function () {
            this.mouseEntered = !1
          },
          handle: function (event) {
            var e = event,
              swiper = this,
              params = swiper.params.mousewheel;
            if (!swiper.mouseEntered && !params.releaseOnEdges) return !0;
            e.originalEvent && (e = e.originalEvent);
            var delta = 0,
              rtlFactor = swiper.rtlTranslate ? -1 : 1,
              data = Mousewheel.normalize(e);
            if (params.forceToAxis)
              if (swiper.isHorizontal()) {
                if (!(Math.abs(data.pixelX) > Math.abs(data.pixelY))) return !0;
                delta = data.pixelX * rtlFactor
              } else {
                if (!(Math.abs(data.pixelY) > Math.abs(data.pixelX))) return !0;
                delta = data.pixelY
              }
            else delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
            if (0 === delta) return !0;
            if (params.invert && (delta = -delta), swiper.params.freeMode) {
              swiper.params.loop && swiper.loopFix();
              var position = swiper.getTranslate() + delta * params.sensitivity,
                wasBeginning = swiper.isBeginning,
                wasEnd = swiper.isEnd;
              if (position >= swiper.minTranslate() && (position = swiper.minTranslate()), position <= swiper.maxTranslate() && (position = swiper.maxTranslate()), swiper.setTransition(0), swiper.setTranslate(position), swiper.updateProgress(), swiper.updateActiveIndex(), swiper.updateSlidesClasses(), (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) && swiper.updateSlidesClasses(), swiper.params.freeModeSticky && (clearTimeout(swiper.mousewheel.timeout), swiper.mousewheel.timeout = Utils.nextTick(function () {
                  swiper.slideToClosest()
                }, 300)), swiper.emit("scroll", e), swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction && swiper.autoplay.stop(), position === swiper.minTranslate() || position === swiper.maxTranslate()) return !0
            } else {
              if (60 < Utils.now() - swiper.mousewheel.lastScrollTime)
                if (delta < 0)
                  if (swiper.isEnd && !swiper.params.loop || swiper.animating) {
                    if (params.releaseOnEdges) return !0
                  } else swiper.slideNext(), swiper.emit("scroll", e);
              else if (swiper.isBeginning && !swiper.params.loop || swiper.animating) {
                if (params.releaseOnEdges) return !0
              } else swiper.slidePrev(), swiper.emit("scroll", e);
              swiper.mousewheel.lastScrollTime = (new win.Date).getTime()
            }
            return e.preventDefault ? e.preventDefault() : e.returnValue = !1, !1
          },
          enable: function () {
            if (!Mousewheel.event) return !1;
            if (this.mousewheel.enabled) return !1;
            var target = this.$el;
            return "container" !== this.params.mousewheel.eventsTarged && (target = $(this.params.mousewheel.eventsTarged)), target.on("mouseenter", this.mousewheel.handleMouseEnter), target.on("mouseleave", this.mousewheel.handleMouseLeave), target.on(Mousewheel.event, this.mousewheel.handle), this.mousewheel.enabled = !0
          },
          disable: function () {
            if (!Mousewheel.event) return !1;
            if (!this.mousewheel.enabled) return !1;
            var target = this.$el;
            return "container" !== this.params.mousewheel.eventsTarged && (target = $(this.params.mousewheel.eventsTarged)), target.off(Mousewheel.event, this.mousewheel.handle), !(this.mousewheel.enabled = !1)
          }
        },
        Navigation = {
          update: function () {
            var params = this.params.navigation;
            if (!this.params.loop) {
              var ref = this.navigation,
                $nextEl = ref.$nextEl,
                $prevEl = ref.$prevEl;
              $prevEl && 0 < $prevEl.length && (this.isBeginning ? $prevEl.addClass(params.disabledClass) : $prevEl.removeClass(params.disabledClass), $prevEl[this.params.watchOverflow && this.isLocked ? "addClass" : "removeClass"](params.lockClass)), $nextEl && 0 < $nextEl.length && (this.isEnd ? $nextEl.addClass(params.disabledClass) : $nextEl.removeClass(params.disabledClass), $nextEl[this.params.watchOverflow && this.isLocked ? "addClass" : "removeClass"](params.lockClass))
            }
          },
          init: function () {
            var $nextEl, $prevEl, swiper = this,
              params = swiper.params.navigation;
            (params.nextEl || params.prevEl) && (params.nextEl && ($nextEl = $(params.nextEl), swiper.params.uniqueNavElements && "string" == typeof params.nextEl && 1 < $nextEl.length && 1 === swiper.$el.find(params.nextEl).length && ($nextEl = swiper.$el.find(params.nextEl))), params.prevEl && ($prevEl = $(params.prevEl), swiper.params.uniqueNavElements && "string" == typeof params.prevEl && 1 < $prevEl.length && 1 === swiper.$el.find(params.prevEl).length && ($prevEl = swiper.$el.find(params.prevEl))), $nextEl && 0 < $nextEl.length && $nextEl.on("click", function (e) {
              e.preventDefault(), swiper.isEnd && !swiper.params.loop || swiper.slideNext()
            }), $prevEl && 0 < $prevEl.length && $prevEl.on("click", function (e) {
              e.preventDefault(), swiper.isBeginning && !swiper.params.loop || swiper.slidePrev()
            }), Utils.extend(swiper.navigation, {
              $nextEl: $nextEl,
              nextEl: $nextEl && $nextEl[0],
              $prevEl: $prevEl,
              prevEl: $prevEl && $prevEl[0]
            }))
          },
          destroy: function () {
            var ref = this.navigation,
              $nextEl = ref.$nextEl,
              $prevEl = ref.$prevEl;
            $nextEl && $nextEl.length && ($nextEl.off("click"), $nextEl.removeClass(this.params.navigation.disabledClass)), $prevEl && $prevEl.length && ($prevEl.off("click"), $prevEl.removeClass(this.params.navigation.disabledClass))
          }
        },
        Pagination = {
          update: function () {
            var rtl = this.rtl,
              params = this.params.pagination;
            if (params.el && this.pagination.el && this.pagination.$el && 0 !== this.pagination.$el.length) {
              var current, slidesLength = this.virtual && this.params.virtual.enabled ? this.virtual.slides.length : this.slides.length,
                $el = this.pagination.$el,
                total = this.params.loop ? Math.ceil((slidesLength - 2 * this.loopedSlides) / this.params.slidesPerGroup) : this.snapGrid.length;
              if (this.params.loop ? ((current = Math.ceil((this.activeIndex - this.loopedSlides) / this.params.slidesPerGroup)) > slidesLength - 1 - 2 * this.loopedSlides && (current -= slidesLength - 2 * this.loopedSlides), total - 1 < current && (current -= total), current < 0 && "bullets" !== this.params.paginationType && (current = total + current)) : current = void 0 !== this.snapIndex ? this.snapIndex : this.activeIndex || 0, "bullets" === params.type && this.pagination.bullets && 0 < this.pagination.bullets.length) {
                var firstIndex, lastIndex, midIndex, bullets = this.pagination.bullets;
                if (params.dynamicBullets && (this.pagination.bulletSize = bullets.eq(0)[this.isHorizontal() ? "outerWidth" : "outerHeight"](!0), $el.css(this.isHorizontal() ? "width" : "height", this.pagination.bulletSize * (params.dynamicMainBullets + 4) + "px"), 1 < params.dynamicMainBullets && void 0 !== this.previousIndex && (this.pagination.dynamicBulletIndex += current - this.previousIndex, this.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1 ? this.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1 : this.pagination.dynamicBulletIndex < 0 && (this.pagination.dynamicBulletIndex = 0)), firstIndex = current - this.pagination.dynamicBulletIndex, midIndex = ((lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1)) + firstIndex) / 2), bullets.removeClass(params.bulletActiveClass + " " + params.bulletActiveClass + "-next " + params.bulletActiveClass + "-next-next " + params.bulletActiveClass + "-prev " + params.bulletActiveClass + "-prev-prev " + params.bulletActiveClass + "-main"), 1 < $el.length) bullets.each(function (index, bullet) {
                  var $bullet = $(bullet),
                    bulletIndex = $bullet.index();
                  bulletIndex === current && $bullet.addClass(params.bulletActiveClass), params.dynamicBullets && (firstIndex <= bulletIndex && bulletIndex <= lastIndex && $bullet.addClass(params.bulletActiveClass + "-main"), bulletIndex === firstIndex && $bullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev"), bulletIndex === lastIndex && $bullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next"))
                });
                else if (bullets.eq(current).addClass(params.bulletActiveClass), params.dynamicBullets) {
                  for (var $firstDisplayedBullet = bullets.eq(firstIndex), $lastDisplayedBullet = bullets.eq(lastIndex), i = firstIndex; i <= lastIndex; i += 1) bullets.eq(i).addClass(params.bulletActiveClass + "-main");
                  $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev"), $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next")
                }
                if (params.dynamicBullets) {
                  var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4),
                    bulletsOffset = (this.pagination.bulletSize * dynamicBulletsLength - this.pagination.bulletSize) / 2 - midIndex * this.pagination.bulletSize,
                    offsetProp = rtl ? "right" : "left";
                  bullets.css(this.isHorizontal() ? offsetProp : "top", bulletsOffset + "px")
                }
              }
              if ("fraction" === params.type && ($el.find("." + params.currentClass).text(params.formatFractionCurrent(current + 1)), $el.find("." + params.totalClass).text(params.formatFractionTotal(total))), "progressbar" === params.type) {
                var progressbarDirection;
                progressbarDirection = params.progressbarOpposite ? this.isHorizontal() ? "vertical" : "horizontal" : this.isHorizontal() ? "horizontal" : "vertical";
                var scale = (current + 1) / total,
                  scaleX = 1,
                  scaleY = 1;
                "horizontal" === progressbarDirection ? scaleX = scale : scaleY = scale, $el.find("." + params.progressbarFillClass).transform("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")").transition(this.params.speed)
              }
              "custom" === params.type && params.renderCustom ? ($el.html(params.renderCustom(this, current + 1, total)), this.emit("paginationRender", this, $el[0])) : this.emit("paginationUpdate", this, $el[0]), $el[this.params.watchOverflow && this.isLocked ? "addClass" : "removeClass"](params.lockClass)
            }
          },
          render: function () {
            var params = this.params.pagination;
            if (params.el && this.pagination.el && this.pagination.$el && 0 !== this.pagination.$el.length) {
              var slidesLength = this.virtual && this.params.virtual.enabled ? this.virtual.slides.length : this.slides.length,
                $el = this.pagination.$el,
                paginationHTML = "";
              if ("bullets" === params.type) {
                for (var numberOfBullets = this.params.loop ? Math.ceil((slidesLength - 2 * this.loopedSlides) / this.params.slidesPerGroup) : this.snapGrid.length, i = 0; i < numberOfBullets; i += 1) params.renderBullet ? paginationHTML += params.renderBullet.call(this, i, params.bulletClass) : paginationHTML += "<" + params.bulletElement + ' class="' + params.bulletClass + '"></' + params.bulletElement + ">";
                $el.html(paginationHTML), this.pagination.bullets = $el.find("." + params.bulletClass)
              }
              "fraction" === params.type && (paginationHTML = params.renderFraction ? params.renderFraction.call(this, params.currentClass, params.totalClass) : '<span class="' + params.currentClass + '"></span> / <span class="' + params.totalClass + '"></span>', $el.html(paginationHTML)), "progressbar" === params.type && (paginationHTML = params.renderProgressbar ? params.renderProgressbar.call(this, params.progressbarFillClass) : '<span class="' + params.progressbarFillClass + '"></span>', $el.html(paginationHTML)), "custom" !== params.type && this.emit("paginationRender", this.pagination.$el[0])
            }
          },
          init: function () {
            var swiper = this,
              params = swiper.params.pagination;
            if (params.el) {
              var $el = $(params.el);
              0 !== $el.length && (swiper.params.uniqueNavElements && "string" == typeof params.el && 1 < $el.length && 1 === swiper.$el.find(params.el).length && ($el = swiper.$el.find(params.el)), "bullets" === params.type && params.clickable && $el.addClass(params.clickableClass), $el.addClass(params.modifierClass + params.type), "bullets" === params.type && params.dynamicBullets && ($el.addClass("" + params.modifierClass + params.type + "-dynamic"), swiper.pagination.dynamicBulletIndex = 0, params.dynamicMainBullets < 1 && (params.dynamicMainBullets = 1)), "progressbar" === params.type && params.progressbarOpposite && $el.addClass(params.progressbarOppositeClass), params.clickable && $el.on("click", "." + params.bulletClass, function (e) {
                e.preventDefault();
                var index = $(this).index() * swiper.params.slidesPerGroup;
                swiper.params.loop && (index += swiper.loopedSlides), swiper.slideTo(index)
              }), Utils.extend(swiper.pagination, {
                $el: $el,
                el: $el[0]
              }))
            }
          },
          destroy: function () {
            var params = this.params.pagination;
            if (params.el && this.pagination.el && this.pagination.$el && 0 !== this.pagination.$el.length) {
              var $el = this.pagination.$el;
              $el.removeClass(params.hiddenClass), $el.removeClass(params.modifierClass + params.type), this.pagination.bullets && this.pagination.bullets.removeClass(params.bulletActiveClass), params.clickable && $el.off("click", "." + params.bulletClass)
            }
          }
        },
        Scrollbar = {
          setTranslate: function () {
            if (this.params.scrollbar.el && this.scrollbar.el) {
              var scrollbar = this.scrollbar,
                rtl = this.rtlTranslate,
                progress = this.progress,
                dragSize = scrollbar.dragSize,
                trackSize = scrollbar.trackSize,
                $dragEl = scrollbar.$dragEl,
                $el = scrollbar.$el,
                params = this.params.scrollbar,
                newSize = dragSize,
                newPos = (trackSize - dragSize) * progress;
              rtl ? 0 < (newPos = -newPos) ? (newSize = dragSize - newPos, newPos = 0) : trackSize < -newPos + dragSize && (newSize = trackSize + newPos) : newPos < 0 ? (newSize = dragSize + newPos, newPos = 0) : trackSize < newPos + dragSize && (newSize = trackSize - newPos), this.isHorizontal() ? (Support.transforms3d ? $dragEl.transform("translate3d(" + newPos + "px, 0, 0)") : $dragEl.transform("translateX(" + newPos + "px)"), $dragEl[0].style.width = newSize + "px") : (Support.transforms3d ? $dragEl.transform("translate3d(0px, " + newPos + "px, 0)") : $dragEl.transform("translateY(" + newPos + "px)"), $dragEl[0].style.height = newSize + "px"), params.hide && (clearTimeout(this.scrollbar.timeout), $el[0].style.opacity = 1, this.scrollbar.timeout = setTimeout(function () {
                $el[0].style.opacity = 0, $el.transition(400)
              }, 1e3))
            }
          },
          setTransition: function (duration) {
            this.params.scrollbar.el && this.scrollbar.el && this.scrollbar.$dragEl.transition(duration)
          },
          updateSize: function () {
            if (this.params.scrollbar.el && this.scrollbar.el) {
              var scrollbar = this.scrollbar,
                $dragEl = scrollbar.$dragEl,
                $el = scrollbar.$el;
              $dragEl[0].style.width = "", $dragEl[0].style.height = "";
              var dragSize, trackSize = this.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight,
                divider = this.size / this.virtualSize,
                moveDivider = divider * (trackSize / this.size);
              dragSize = "auto" === this.params.scrollbar.dragSize ? trackSize * divider : parseInt(this.params.scrollbar.dragSize, 10), this.isHorizontal() ? $dragEl[0].style.width = dragSize + "px" : $dragEl[0].style.height = dragSize + "px", $el[0].style.display = 1 <= divider ? "none" : "", this.params.scrollbarHide && ($el[0].style.opacity = 0), Utils.extend(scrollbar, {
                trackSize: trackSize,
                divider: divider,
                moveDivider: moveDivider,
                dragSize: dragSize
              }), scrollbar.$el[this.params.watchOverflow && this.isLocked ? "addClass" : "removeClass"](this.params.scrollbar.lockClass)
            }
          },
          setDragPosition: function (e) {
            var positionRatio, scrollbar = this.scrollbar,
              rtl = this.rtlTranslate,
              $el = scrollbar.$el,
              dragSize = scrollbar.dragSize,
              trackSize = scrollbar.trackSize;
            positionRatio = ((this.isHorizontal() ? "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX || e.clientX : "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY || e.clientY) - $el.offset()[this.isHorizontal() ? "left" : "top"] - dragSize / 2) / (trackSize - dragSize), positionRatio = Math.max(Math.min(positionRatio, 1), 0), rtl && (positionRatio = 1 - positionRatio);
            var position = this.minTranslate() + (this.maxTranslate() - this.minTranslate()) * positionRatio;
            this.updateProgress(position), this.setTranslate(position), this.updateActiveIndex(), this.updateSlidesClasses()
          },
          onDragStart: function (e) {
            var params = this.params.scrollbar,
              scrollbar = this.scrollbar,
              $wrapperEl = this.$wrapperEl,
              $el = scrollbar.$el,
              $dragEl = scrollbar.$dragEl;
            this.scrollbar.isTouched = !0, e.preventDefault(), e.stopPropagation(), $wrapperEl.transition(100), $dragEl.transition(100), scrollbar.setDragPosition(e), clearTimeout(this.scrollbar.dragTimeout), $el.transition(0), params.hide && $el.css("opacity", 1), this.emit("scrollbarDragStart", e)
          },
          onDragMove: function (e) {
            var scrollbar = this.scrollbar,
              $wrapperEl = this.$wrapperEl,
              $el = scrollbar.$el,
              $dragEl = scrollbar.$dragEl;
            this.scrollbar.isTouched && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, scrollbar.setDragPosition(e), $wrapperEl.transition(0), $el.transition(0), $dragEl.transition(0), this.emit("scrollbarDragMove", e))
          },
          onDragEnd: function (e) {
            var params = this.params.scrollbar,
              $el = this.scrollbar.$el;
            this.scrollbar.isTouched && (this.scrollbar.isTouched = !1, params.hide && (clearTimeout(this.scrollbar.dragTimeout), this.scrollbar.dragTimeout = Utils.nextTick(function () {
              $el.css("opacity", 0), $el.transition(400)
            }, 1e3)), this.emit("scrollbarDragEnd", e), params.snapOnRelease && this.slideToClosest())
          },
          enableDraggable: function () {
            if (this.params.scrollbar.el) {
              var scrollbar = this.scrollbar,
                touchEvents = this.touchEvents,
                touchEventsDesktop = this.touchEventsDesktop,
                params = this.params,
                target = scrollbar.$el[0],
                activeListener = !(!Support.passiveListener || !params.passiveListeners) && {
                  passive: !1,
                  capture: !1
                },
                passiveListener = !(!Support.passiveListener || !params.passiveListeners) && {
                  passive: !0,
                  capture: !1
                };
              Support.touch || !Support.pointerEvents && !Support.prefixedPointerEvents ? (Support.touch && (target.addEventListener(touchEvents.start, this.scrollbar.onDragStart, activeListener), target.addEventListener(touchEvents.move, this.scrollbar.onDragMove, activeListener), target.addEventListener(touchEvents.end, this.scrollbar.onDragEnd, passiveListener)), (params.simulateTouch && !Device.ios && !Device.android || params.simulateTouch && !Support.touch && Device.ios) && (target.addEventListener("mousedown", this.scrollbar.onDragStart, activeListener), doc.addEventListener("mousemove", this.scrollbar.onDragMove, activeListener), doc.addEventListener("mouseup", this.scrollbar.onDragEnd, passiveListener))) : (target.addEventListener(touchEventsDesktop.start, this.scrollbar.onDragStart, activeListener), doc.addEventListener(touchEventsDesktop.move, this.scrollbar.onDragMove, activeListener), doc.addEventListener(touchEventsDesktop.end, this.scrollbar.onDragEnd, passiveListener))
            }
          },
          disableDraggable: function () {
            if (this.params.scrollbar.el) {
              var scrollbar = this.scrollbar,
                touchEvents = this.touchEvents,
                touchEventsDesktop = this.touchEventsDesktop,
                params = this.params,
                target = scrollbar.$el[0],
                activeListener = !(!Support.passiveListener || !params.passiveListeners) && {
                  passive: !1,
                  capture: !1
                },
                passiveListener = !(!Support.passiveListener || !params.passiveListeners) && {
                  passive: !0,
                  capture: !1
                };
              Support.touch || !Support.pointerEvents && !Support.prefixedPointerEvents ? (Support.touch && (target.removeEventListener(touchEvents.start, this.scrollbar.onDragStart, activeListener), target.removeEventListener(touchEvents.move, this.scrollbar.onDragMove, activeListener), target.removeEventListener(touchEvents.end, this.scrollbar.onDragEnd, passiveListener)), (params.simulateTouch && !Device.ios && !Device.android || params.simulateTouch && !Support.touch && Device.ios) && (target.removeEventListener("mousedown", this.scrollbar.onDragStart, activeListener), doc.removeEventListener("mousemove", this.scrollbar.onDragMove, activeListener), doc.removeEventListener("mouseup", this.scrollbar.onDragEnd, passiveListener))) : (target.removeEventListener(touchEventsDesktop.start, this.scrollbar.onDragStart, activeListener), doc.removeEventListener(touchEventsDesktop.move, this.scrollbar.onDragMove, activeListener), doc.removeEventListener(touchEventsDesktop.end, this.scrollbar.onDragEnd, passiveListener))
            }
          },
          init: function () {
            if (this.params.scrollbar.el) {
              var scrollbar = this.scrollbar,
                $swiperEl = this.$el,
                params = this.params.scrollbar,
                $el = $(params.el);
              this.params.uniqueNavElements && "string" == typeof params.el && 1 < $el.length && 1 === $swiperEl.find(params.el).length && ($el = $swiperEl.find(params.el));
              var $dragEl = $el.find("." + this.params.scrollbar.dragClass);
              0 === $dragEl.length && ($dragEl = $('<div class="' + this.params.scrollbar.dragClass + '"></div>'), $el.append($dragEl)), Utils.extend(scrollbar, {
                $el: $el,
                el: $el[0],
                $dragEl: $dragEl,
                dragEl: $dragEl[0]
              }), params.draggable && scrollbar.enableDraggable()
            }
          },
          destroy: function () {
            this.scrollbar.disableDraggable()
          }
        },
        Parallax = {
          setTransform: function (el, progress) {
            var rtl = this.rtl,
              $el = $(el),
              rtlFactor = rtl ? -1 : 1,
              p = $el.attr("data-swiper-parallax") || "0",
              x = $el.attr("data-swiper-parallax-x"),
              y = $el.attr("data-swiper-parallax-y"),
              scale = $el.attr("data-swiper-parallax-scale"),
              opacity = $el.attr("data-swiper-parallax-opacity");
            if (x || y ? (x = x || "0", y = y || "0") : this.isHorizontal() ? (x = p, y = "0") : (y = p, x = "0"), x = 0 <= x.indexOf("%") ? parseInt(x, 10) * progress * rtlFactor + "%" : x * progress * rtlFactor + "px", y = 0 <= y.indexOf("%") ? parseInt(y, 10) * progress + "%" : y * progress + "px", null != opacity) {
              var currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
              $el[0].style.opacity = currentOpacity
            }
            if (null == scale) $el.transform("translate3d(" + x + ", " + y + ", 0px)");
            else {
              var currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
              $el.transform("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")")
            }
          },
          setTranslate: function () {
            var swiper = this,
              $el = swiper.$el,
              slides = swiper.slides,
              progress = swiper.progress,
              snapGrid = swiper.snapGrid;
            $el.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function (index, el) {
              swiper.parallax.setTransform(el, progress)
            }), slides.each(function (slideIndex, slideEl) {
              var slideProgress = slideEl.progress;
              1 < swiper.params.slidesPerGroup && "auto" !== swiper.params.slidesPerView && (slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1)), slideProgress = Math.min(Math.max(slideProgress, -1), 1), $(slideEl).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function (index, el) {
                swiper.parallax.setTransform(el, slideProgress)
              })
            })
          },
          setTransition: function (duration) {
            void 0 === duration && (duration = this.params.speed);
            this.$el.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function (index, parallaxEl) {
              var $parallaxEl = $(parallaxEl),
                parallaxDuration = parseInt($parallaxEl.attr("data-swiper-parallax-duration"), 10) || duration;
              0 === duration && (parallaxDuration = 0), $parallaxEl.transition(parallaxDuration)
            })
          }
        },
        Zoom = {
          getDistanceBetweenTouches: function (e) {
            if (e.targetTouches.length < 2) return 1;
            var x1 = e.targetTouches[0].pageX,
              y1 = e.targetTouches[0].pageY,
              x2 = e.targetTouches[1].pageX,
              y2 = e.targetTouches[1].pageY;
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2))
          },
          onGestureStart: function (e) {
            var params = this.params.zoom,
              zoom = this.zoom,
              gesture = zoom.gesture;
            if (zoom.fakeGestureTouched = !1, zoom.fakeGestureMoved = !1, !Support.gestures) {
              if ("touchstart" !== e.type || "touchstart" === e.type && e.targetTouches.length < 2) return;
              zoom.fakeGestureTouched = !0, gesture.scaleStart = Zoom.getDistanceBetweenTouches(e)
            }
            gesture.$slideEl && gesture.$slideEl.length || (gesture.$slideEl = $(e.target).closest(".swiper-slide"), 0 === gesture.$slideEl.length && (gesture.$slideEl = this.slides.eq(this.activeIndex)), gesture.$imageEl = gesture.$slideEl.find("img, svg, canvas"), gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass), gesture.maxRatio = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio, 0 !== gesture.$imageWrapEl.length) ? (gesture.$imageEl.transition(0), this.zoom.isScaling = !0) : gesture.$imageEl = void 0
          },
          onGestureChange: function (e) {
            var params = this.params.zoom,
              zoom = this.zoom,
              gesture = zoom.gesture;
            if (!Support.gestures) {
              if ("touchmove" !== e.type || "touchmove" === e.type && e.targetTouches.length < 2) return;
              zoom.fakeGestureMoved = !0, gesture.scaleMove = Zoom.getDistanceBetweenTouches(e)
            }
            gesture.$imageEl && 0 !== gesture.$imageEl.length && (Support.gestures ? this.zoom.scale = e.scale * zoom.currentScale : zoom.scale = gesture.scaleMove / gesture.scaleStart * zoom.currentScale, zoom.scale > gesture.maxRatio && (zoom.scale = gesture.maxRatio - 1 + Math.pow(zoom.scale - gesture.maxRatio + 1, .5)), zoom.scale < params.minRatio && (zoom.scale = params.minRatio + 1 - Math.pow(params.minRatio - zoom.scale + 1, .5)), gesture.$imageEl.transform("translate3d(0,0,0) scale(" + zoom.scale + ")"))
          },
          onGestureEnd: function (e) {
            var params = this.params.zoom,
              zoom = this.zoom,
              gesture = zoom.gesture;
            if (!Support.gestures) {
              if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) return;
              if ("touchend" !== e.type || "touchend" === e.type && e.changedTouches.length < 2 && !Device.android) return;
              zoom.fakeGestureTouched = !1, zoom.fakeGestureMoved = !1
            }
            gesture.$imageEl && 0 !== gesture.$imageEl.length && (zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio), gesture.$imageEl.transition(this.params.speed).transform("translate3d(0,0,0) scale(" + zoom.scale + ")"), zoom.currentScale = zoom.scale, zoom.isScaling = !1, 1 === zoom.scale && (gesture.$slideEl = void 0))
          },
          onTouchStart: function (e) {
            var zoom = this.zoom,
              gesture = zoom.gesture,
              image = zoom.image;
            gesture.$imageEl && 0 !== gesture.$imageEl.length && (image.isTouched || (Device.android && e.preventDefault(), image.isTouched = !0, image.touchesStart.x = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX, image.touchesStart.y = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY))
          },
          onTouchMove: function (e) {
            var zoom = this.zoom,
              gesture = zoom.gesture,
              image = zoom.image,
              velocity = zoom.velocity;
            if (gesture.$imageEl && 0 !== gesture.$imageEl.length && (this.allowClick = !1, image.isTouched && gesture.$slideEl)) {
              image.isMoved || (image.width = gesture.$imageEl[0].offsetWidth, image.height = gesture.$imageEl[0].offsetHeight, image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], "x") || 0, image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], "y") || 0, gesture.slideWidth = gesture.$slideEl[0].offsetWidth, gesture.slideHeight = gesture.$slideEl[0].offsetHeight, gesture.$imageWrapEl.transition(0), this.rtl && (image.startX = -image.startX, image.startY = -image.startY));
              var scaledWidth = image.width * zoom.scale,
                scaledHeight = image.height * zoom.scale;
              if (!(scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight)) {
                if (image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0), image.maxX = -image.minX, image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0), image.maxY = -image.minY, image.touchesCurrent.x = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX, image.touchesCurrent.y = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY, !image.isMoved && !zoom.isScaling) {
                  if (this.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) return void(image.isTouched = !1);
                  if (!this.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) return void(image.isTouched = !1)
                }
                e.preventDefault(), e.stopPropagation(), image.isMoved = !0, image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX, image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY, image.currentX < image.minX && (image.currentX = image.minX + 1 - Math.pow(image.minX - image.currentX + 1, .8)), image.currentX > image.maxX && (image.currentX = image.maxX - 1 + Math.pow(image.currentX - image.maxX + 1, .8)), image.currentY < image.minY && (image.currentY = image.minY + 1 - Math.pow(image.minY - image.currentY + 1, .8)), image.currentY > image.maxY && (image.currentY = image.maxY - 1 + Math.pow(image.currentY - image.maxY + 1, .8)), velocity.prevPositionX || (velocity.prevPositionX = image.touchesCurrent.x), velocity.prevPositionY || (velocity.prevPositionY = image.touchesCurrent.y), velocity.prevTime || (velocity.prevTime = Date.now()), velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2, velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2, Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2 && (velocity.x = 0), Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2 && (velocity.y = 0), velocity.prevPositionX = image.touchesCurrent.x, velocity.prevPositionY = image.touchesCurrent.y, velocity.prevTime = Date.now(), gesture.$imageWrapEl.transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)")
              }
            }
          },
          onTouchEnd: function () {
            var zoom = this.zoom,
              gesture = zoom.gesture,
              image = zoom.image,
              velocity = zoom.velocity;
            if (gesture.$imageEl && 0 !== gesture.$imageEl.length) {
              if (!image.isTouched || !image.isMoved) return image.isTouched = !1, void(image.isMoved = !1);
              image.isTouched = !1, image.isMoved = !1;
              var momentumDurationX = 300,
                momentumDurationY = 300,
                momentumDistanceX = velocity.x * momentumDurationX,
                newPositionX = image.currentX + momentumDistanceX,
                momentumDistanceY = velocity.y * momentumDurationY,
                newPositionY = image.currentY + momentumDistanceY;
              0 !== velocity.x && (momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x)), 0 !== velocity.y && (momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y));
              var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
              image.currentX = newPositionX, image.currentY = newPositionY;
              var scaledWidth = image.width * zoom.scale,
                scaledHeight = image.height * zoom.scale;
              image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0), image.maxX = -image.minX, image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0), image.maxY = -image.minY, image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX), image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY), gesture.$imageWrapEl.transition(momentumDuration).transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)")
            }
          },
          onTransitionEnd: function () {
            var zoom = this.zoom,
              gesture = zoom.gesture;
            gesture.$slideEl && this.previousIndex !== this.activeIndex && (gesture.$imageEl.transform("translate3d(0,0,0) scale(1)"), gesture.$imageWrapEl.transform("translate3d(0,0,0)"), gesture.$slideEl = void 0, gesture.$imageEl = void 0, gesture.$imageWrapEl = void 0, zoom.scale = 1, zoom.currentScale = 1)
          },
          toggle: function (e) {
            var zoom = this.zoom;
            zoom.scale && 1 !== zoom.scale ? zoom.out() : zoom.in(e)
          },
          in: function (e) {
            var touchX, touchY, diffX, diffY, translateX, translateY, imageWidth, imageHeight, scaledWidth, scaledHeight, translateMinX, translateMinY, translateMaxX, translateMaxY, slideWidth, slideHeight, zoom = this.zoom,
              params = this.params.zoom,
              gesture = zoom.gesture,
              image = zoom.image;
            (gesture.$slideEl || (gesture.$slideEl = this.clickedSlide ? $(this.clickedSlide) : this.slides.eq(this.activeIndex), gesture.$imageEl = gesture.$slideEl.find("img, svg, canvas"), gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass)), gesture.$imageEl && 0 !== gesture.$imageEl.length) && (gesture.$slideEl.addClass("" + params.zoomedSlideClass), void 0 === image.touchesStart.x && e ? (touchX = "touchend" === e.type ? e.changedTouches[0].pageX : e.pageX, touchY = "touchend" === e.type ? e.changedTouches[0].pageY : e.pageY) : (touchX = image.touchesStart.x, touchY = image.touchesStart.y), zoom.scale = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio, zoom.currentScale = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio, e ? (slideWidth = gesture.$slideEl[0].offsetWidth, slideHeight = gesture.$slideEl[0].offsetHeight, diffX = gesture.$slideEl.offset().left + slideWidth / 2 - touchX, diffY = gesture.$slideEl.offset().top + slideHeight / 2 - touchY, imageWidth = gesture.$imageEl[0].offsetWidth, imageHeight = gesture.$imageEl[0].offsetHeight, scaledWidth = imageWidth * zoom.scale, scaledHeight = imageHeight * zoom.scale, translateMaxX = -(translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0)), translateMaxY = -(translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0)), (translateX = diffX * zoom.scale) < translateMinX && (translateX = translateMinX), translateMaxX < translateX && (translateX = translateMaxX), (translateY = diffY * zoom.scale) < translateMinY && (translateY = translateMinY), translateMaxY < translateY && (translateY = translateMaxY)) : translateY = translateX = 0, gesture.$imageWrapEl.transition(300).transform("translate3d(" + translateX + "px, " + translateY + "px,0)"), gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(" + zoom.scale + ")"))
          },
          out: function () {
            var zoom = this.zoom,
              params = this.params.zoom,
              gesture = zoom.gesture;
            gesture.$slideEl || (gesture.$slideEl = this.clickedSlide ? $(this.clickedSlide) : this.slides.eq(this.activeIndex), gesture.$imageEl = gesture.$slideEl.find("img, svg, canvas"), gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass)), gesture.$imageEl && 0 !== gesture.$imageEl.length && (zoom.scale = 1, zoom.currentScale = 1, gesture.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), gesture.$slideEl.removeClass("" + params.zoomedSlideClass), gesture.$slideEl = void 0)
          },
          enable: function () {
            var zoom = this.zoom;
            if (!zoom.enabled) {
              zoom.enabled = !0;
              var passiveListener = !("touchstart" !== this.touchEvents.start || !Support.passiveListener || !this.params.passiveListeners) && {
                passive: !0,
                capture: !1
              };
              Support.gestures ? (this.$wrapperEl.on("gesturestart", ".swiper-slide", zoom.onGestureStart, passiveListener), this.$wrapperEl.on("gesturechange", ".swiper-slide", zoom.onGestureChange, passiveListener), this.$wrapperEl.on("gestureend", ".swiper-slide", zoom.onGestureEnd, passiveListener)) : "touchstart" === this.touchEvents.start && (this.$wrapperEl.on(this.touchEvents.start, ".swiper-slide", zoom.onGestureStart, passiveListener), this.$wrapperEl.on(this.touchEvents.move, ".swiper-slide", zoom.onGestureChange, passiveListener), this.$wrapperEl.on(this.touchEvents.end, ".swiper-slide", zoom.onGestureEnd, passiveListener)), this.$wrapperEl.on(this.touchEvents.move, "." + this.params.zoom.containerClass, zoom.onTouchMove)
            }
          },
          disable: function () {
            var zoom = this.zoom;
            if (zoom.enabled) {
              this.zoom.enabled = !1;
              var passiveListener = !("touchstart" !== this.touchEvents.start || !Support.passiveListener || !this.params.passiveListeners) && {
                passive: !0,
                capture: !1
              };
              Support.gestures ? (this.$wrapperEl.off("gesturestart", ".swiper-slide", zoom.onGestureStart, passiveListener), this.$wrapperEl.off("gesturechange", ".swiper-slide", zoom.onGestureChange, passiveListener), this.$wrapperEl.off("gestureend", ".swiper-slide", zoom.onGestureEnd, passiveListener)) : "touchstart" === this.touchEvents.start && (this.$wrapperEl.off(this.touchEvents.start, ".swiper-slide", zoom.onGestureStart, passiveListener), this.$wrapperEl.off(this.touchEvents.move, ".swiper-slide", zoom.onGestureChange, passiveListener), this.$wrapperEl.off(this.touchEvents.end, ".swiper-slide", zoom.onGestureEnd, passiveListener)), this.$wrapperEl.off(this.touchEvents.move, "." + this.params.zoom.containerClass, zoom.onTouchMove)
            }
          }
        },
        Lazy = {
          loadInSlide: function (index, loadInDuplicate) {
            void 0 === loadInDuplicate && (loadInDuplicate = !0);
            var swiper = this,
              params = swiper.params.lazy;
            if (void 0 !== index && 0 !== swiper.slides.length) {
              var $slideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.$wrapperEl.children("." + swiper.params.slideClass + '[data-swiper-slide-index="' + index + '"]') : swiper.slides.eq(index),
                $images = $slideEl.find("." + params.elementClass + ":not(." + params.loadedClass + "):not(." + params.loadingClass + ")");
              !$slideEl.hasClass(params.elementClass) || $slideEl.hasClass(params.loadedClass) || $slideEl.hasClass(params.loadingClass) || ($images = $images.add($slideEl[0])), 0 !== $images.length && $images.each(function (imageIndex, imageEl) {
                var $imageEl = $(imageEl);
                $imageEl.addClass(params.loadingClass);
                var background = $imageEl.attr("data-background"),
                  src = $imageEl.attr("data-src"),
                  srcset = $imageEl.attr("data-srcset"),
                  sizes = $imageEl.attr("data-sizes");
                swiper.loadImage($imageEl[0], src || background, srcset, sizes, !1, function () {
                  if (null != swiper && swiper && (!swiper || swiper.params) && !swiper.destroyed) {
                    if (background ? ($imageEl.css("background-image", 'url("' + background + '")'), $imageEl.removeAttr("data-background")) : (srcset && ($imageEl.attr("srcset", srcset), $imageEl.removeAttr("data-srcset")), sizes && ($imageEl.attr("sizes", sizes), $imageEl.removeAttr("data-sizes")), src && ($imageEl.attr("src", src), $imageEl.removeAttr("data-src"))), $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass), $slideEl.find("." + params.preloaderClass).remove(), swiper.params.loop && loadInDuplicate) {
                      var slideOriginalIndex = $slideEl.attr("data-swiper-slide-index");
                      if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                        var originalSlide = swiper.$wrapperEl.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + swiper.params.slideDuplicateClass + ")");
                        swiper.lazy.loadInSlide(originalSlide.index(), !1)
                      } else {
                        var duplicatedSlide = swiper.$wrapperEl.children("." + swiper.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');
                        swiper.lazy.loadInSlide(duplicatedSlide.index(), !1)
                      }
                    }
                    swiper.emit("lazyImageReady", $slideEl[0], $imageEl[0])
                  }
                }), swiper.emit("lazyImageLoad", $slideEl[0], $imageEl[0])
              })
            }
          },
          load: function () {
            var swiper = this,
              $wrapperEl = swiper.$wrapperEl,
              swiperParams = swiper.params,
              slides = swiper.slides,
              activeIndex = swiper.activeIndex,
              isVirtual = swiper.virtual && swiperParams.virtual.enabled,
              params = swiperParams.lazy,
              slidesPerView = swiperParams.slidesPerView;

            function slideExist(index) {
              if (isVirtual) {
                if ($wrapperEl.children("." + swiperParams.slideClass + '[data-swiper-slide-index="' + index + '"]').length) return !0
              } else if (slides[index]) return !0;
              return !1
            }

            function slideIndex(slideEl) {
              return isVirtual ? $(slideEl).attr("data-swiper-slide-index") : $(slideEl).index()
            }
            if ("auto" === slidesPerView && (slidesPerView = 0), swiper.lazy.initialImageLoaded || (swiper.lazy.initialImageLoaded = !0), swiper.params.watchSlidesVisibility) $wrapperEl.children("." + swiperParams.slideVisibleClass).each(function (elIndex, slideEl) {
              var index = isVirtual ? $(slideEl).attr("data-swiper-slide-index") : $(slideEl).index();
              swiper.lazy.loadInSlide(index)
            });
            else if (1 < slidesPerView)
              for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) slideExist(i) && swiper.lazy.loadInSlide(i);
            else swiper.lazy.loadInSlide(activeIndex);
            if (params.loadPrevNext)
              if (1 < slidesPerView || params.loadPrevNextAmount && 1 < params.loadPrevNextAmount) {
                for (var amount = params.loadPrevNextAmount, spv = slidesPerView, maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length), minIndex = Math.max(activeIndex - Math.max(spv, amount), 0), i$1 = activeIndex + slidesPerView; i$1 < maxIndex; i$1 += 1) slideExist(i$1) && swiper.lazy.loadInSlide(i$1);
                for (var i$2 = minIndex; i$2 < activeIndex; i$2 += 1) slideExist(i$2) && swiper.lazy.loadInSlide(i$2)
              } else {
                var nextSlide = $wrapperEl.children("." + swiperParams.slideNextClass);
                0 < nextSlide.length && swiper.lazy.loadInSlide(slideIndex(nextSlide));
                var prevSlide = $wrapperEl.children("." + swiperParams.slidePrevClass);
                0 < prevSlide.length && swiper.lazy.loadInSlide(slideIndex(prevSlide))
              }
          }
        },
        Controller = {
          LinearSpline: function (x, y) {
            var maxIndex, minIndex, guess, i1, i3, binarySearch = function (array, val) {
              for (minIndex = -1, maxIndex = array.length; 1 < maxIndex - minIndex;) array[guess = maxIndex + minIndex >> 1] <= val ? minIndex = guess : maxIndex = guess;
              return maxIndex
            };
            return this.x = x, this.y = y, this.lastIndex = x.length - 1, this.interpolate = function (x2) {
              return x2 ? (i3 = binarySearch(this.x, x2), i1 = i3 - 1, (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1]) : 0
            }, this
          },
          getInterpolateFunction: function (c) {
            this.controller.spline || (this.controller.spline = this.params.loop ? new Controller.LinearSpline(this.slidesGrid, c.slidesGrid) : new Controller.LinearSpline(this.snapGrid, c.snapGrid))
          },
          setTranslate: function (setTranslate$1, byController) {
            var multiplier, controlledTranslate, swiper = this,
              controlled = swiper.controller.control;

            function setControlledTranslate(c) {
              var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
              "slide" === swiper.params.controller.by && (swiper.controller.getInterpolateFunction(c), controlledTranslate = -swiper.controller.spline.interpolate(-translate)), controlledTranslate && "container" !== swiper.params.controller.by || (multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate()), controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate()), swiper.params.controller.inverse && (controlledTranslate = c.maxTranslate() - controlledTranslate), c.updateProgress(controlledTranslate), c.setTranslate(controlledTranslate, swiper), c.updateActiveIndex(), c.updateSlidesClasses()
            }
            if (Array.isArray(controlled))
              for (var i = 0; i < controlled.length; i += 1) controlled[i] !== byController && controlled[i] instanceof Swiper && setControlledTranslate(controlled[i]);
            else controlled instanceof Swiper && byController !== controlled && setControlledTranslate(controlled)
          },
          setTransition: function (duration, byController) {
            var i, swiper = this,
              controlled = swiper.controller.control;

            function setControlledTransition(c) {
              c.setTransition(duration, swiper), 0 !== duration && (c.transitionStart(), c.params.autoHeight && Utils.nextTick(function () {
                c.updateAutoHeight()
              }), c.$wrapperEl.transitionEnd(function () {
                controlled && (c.params.loop && "slide" === swiper.params.controller.by && c.loopFix(), c.transitionEnd())
              }))
            }
            if (Array.isArray(controlled))
              for (i = 0; i < controlled.length; i += 1) controlled[i] !== byController && controlled[i] instanceof Swiper && setControlledTransition(controlled[i]);
            else controlled instanceof Swiper && byController !== controlled && setControlledTransition(controlled)
          }
        },
        a11y = {
          makeElFocusable: function ($el) {
            return $el.attr("tabIndex", "0"), $el
          },
          addElRole: function ($el, role) {
            return $el.attr("role", role), $el
          },
          addElLabel: function ($el, label) {
            return $el.attr("aria-label", label), $el
          },
          disableEl: function ($el) {
            return $el.attr("aria-disabled", !0), $el
          },
          enableEl: function ($el) {
            return $el.attr("aria-disabled", !1), $el
          },
          onEnterKey: function (e) {
            var params = this.params.a11y;
            if (13 === e.keyCode) {
              var $targetEl = $(e.target);
              this.navigation && this.navigation.$nextEl && $targetEl.is(this.navigation.$nextEl) && (this.isEnd && !this.params.loop || this.slideNext(), this.isEnd ? this.a11y.notify(params.lastSlideMessage) : this.a11y.notify(params.nextSlideMessage)), this.navigation && this.navigation.$prevEl && $targetEl.is(this.navigation.$prevEl) && (this.isBeginning && !this.params.loop || this.slidePrev(), this.isBeginning ? this.a11y.notify(params.firstSlideMessage) : this.a11y.notify(params.prevSlideMessage)), this.pagination && $targetEl.is("." + this.params.pagination.bulletClass) && $targetEl[0].click()
            }
          },
          notify: function (message) {
            var notification = this.a11y.liveRegion;
            0 !== notification.length && (notification.html(""), notification.html(message))
          },
          updateNavigation: function () {
            if (!this.params.loop) {
              var ref = this.navigation,
                $nextEl = ref.$nextEl,
                $prevEl = ref.$prevEl;
              $prevEl && 0 < $prevEl.length && (this.isBeginning ? this.a11y.disableEl($prevEl) : this.a11y.enableEl($prevEl)), $nextEl && 0 < $nextEl.length && (this.isEnd ? this.a11y.disableEl($nextEl) : this.a11y.enableEl($nextEl))
            }
          },
          updatePagination: function () {
            var swiper = this,
              params = swiper.params.a11y;
            swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length && swiper.pagination.bullets.each(function (bulletIndex, bulletEl) {
              var $bulletEl = $(bulletEl);
              swiper.a11y.makeElFocusable($bulletEl), swiper.a11y.addElRole($bulletEl, "button"), swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1))
            })
          },
          init: function () {
            this.$el.append(this.a11y.liveRegion);
            var $nextEl, $prevEl, params = this.params.a11y;
            this.navigation && this.navigation.$nextEl && ($nextEl = this.navigation.$nextEl), this.navigation && this.navigation.$prevEl && ($prevEl = this.navigation.$prevEl), $nextEl && (this.a11y.makeElFocusable($nextEl), this.a11y.addElRole($nextEl, "button"), this.a11y.addElLabel($nextEl, params.nextSlideMessage), $nextEl.on("keydown", this.a11y.onEnterKey)), $prevEl && (this.a11y.makeElFocusable($prevEl), this.a11y.addElRole($prevEl, "button"), this.a11y.addElLabel($prevEl, params.prevSlideMessage), $prevEl.on("keydown", this.a11y.onEnterKey)), this.pagination && this.params.pagination.clickable && this.pagination.bullets && this.pagination.bullets.length && this.pagination.$el.on("keydown", "." + this.params.pagination.bulletClass, this.a11y.onEnterKey)
          },
          destroy: function () {
            var $nextEl, $prevEl;
            this.a11y.liveRegion && 0 < this.a11y.liveRegion.length && this.a11y.liveRegion.remove(), this.navigation && this.navigation.$nextEl && ($nextEl = this.navigation.$nextEl), this.navigation && this.navigation.$prevEl && ($prevEl = this.navigation.$prevEl), $nextEl && $nextEl.off("keydown", this.a11y.onEnterKey), $prevEl && $prevEl.off("keydown", this.a11y.onEnterKey), this.pagination && this.params.pagination.clickable && this.pagination.bullets && this.pagination.bullets.length && this.pagination.$el.off("keydown", "." + this.params.pagination.bulletClass, this.a11y.onEnterKey)
          }
        },
        History = {
          init: function () {
            if (this.params.history) {
              if (!win.history || !win.history.pushState) return this.params.history.enabled = !1, void(this.params.hashNavigation.enabled = !0);
              var history = this.history;
              history.initialized = !0, history.paths = History.getPathValues(), (history.paths.key || history.paths.value) && (history.scrollToSlide(0, history.paths.value, this.params.runCallbacksOnInit), this.params.history.replaceState || win.addEventListener("popstate", this.history.setHistoryPopState))
            }
          },
          destroy: function () {
            this.params.history.replaceState || win.removeEventListener("popstate", this.history.setHistoryPopState)
          },
          setHistoryPopState: function () {
            this.history.paths = History.getPathValues(), this.history.scrollToSlide(this.params.speed, this.history.paths.value, !1)
          },
          getPathValues: function () {
            var pathArray = win.location.pathname.slice(1).split("/").filter(function (part) {
                return "" !== part
              }),
              total = pathArray.length;
            return {
              key: pathArray[total - 2],
              value: pathArray[total - 1]
            }
          },
          setHistory: function (key, index) {
            if (this.history.initialized && this.params.history.enabled) {
              var slide = this.slides.eq(index),
                value = History.slugify(slide.attr("data-history"));
              win.location.pathname.includes(key) || (value = key + "/" + value);
              var currentState = win.history.state;
              currentState && currentState.value === value || (this.params.history.replaceState ? win.history.replaceState({
                value: value
              }, null, value) : win.history.pushState({
                value: value
              }, null, value))
            }
          },
          slugify: function (text) {
            return text.toString().toLowerCase().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "")
          },
          scrollToSlide: function (speed, value, runCallbacks) {
            if (value)
              for (var i = 0, length = this.slides.length; i < length; i += 1) {
                var slide = this.slides.eq(i);
                if (History.slugify(slide.attr("data-history")) === value && !slide.hasClass(this.params.slideDuplicateClass)) {
                  var index = slide.index();
                  this.slideTo(index, speed, runCallbacks)
                }
              } else this.slideTo(0, speed, runCallbacks)
          }
        },
        HashNavigation = {
          onHashCange: function () {
            var newHash = doc.location.hash.replace("#", "");
            newHash !== this.slides.eq(this.activeIndex).attr("data-hash") && this.slideTo(this.$wrapperEl.children("." + this.params.slideClass + '[data-hash="' + newHash + '"]').index())
          },
          setHash: function () {
            if (this.hashNavigation.initialized && this.params.hashNavigation.enabled)
              if (this.params.hashNavigation.replaceState && win.history && win.history.replaceState) win.history.replaceState(null, null, "#" + this.slides.eq(this.activeIndex).attr("data-hash") || "");
              else {
                var slide = this.slides.eq(this.activeIndex),
                  hash = slide.attr("data-hash") || slide.attr("data-history");
                doc.location.hash = hash || ""
              }
          },
          init: function () {
            if (!(!this.params.hashNavigation.enabled || this.params.history && this.params.history.enabled)) {
              this.hashNavigation.initialized = !0;
              var hash = doc.location.hash.replace("#", "");
              if (hash)
                for (var i = 0, length = this.slides.length; i < length; i += 1) {
                  var slide = this.slides.eq(i);
                  if ((slide.attr("data-hash") || slide.attr("data-history")) === hash && !slide.hasClass(this.params.slideDuplicateClass)) {
                    var index = slide.index();
                    this.slideTo(index, 0, this.params.runCallbacksOnInit, !0)
                  }
                }
              this.params.hashNavigation.watchState && $(win).on("hashchange", this.hashNavigation.onHashCange)
            }
          },
          destroy: function () {
            this.params.hashNavigation.watchState && $(win).off("hashchange", this.hashNavigation.onHashCange)
          }
        },
        Autoplay = {
          run: function () {
            var swiper = this,
              $activeSlideEl = swiper.slides.eq(swiper.activeIndex),
              delay = swiper.params.autoplay.delay;
            $activeSlideEl.attr("data-swiper-autoplay") && (delay = $activeSlideEl.attr("data-swiper-autoplay") || swiper.params.autoplay.delay), swiper.autoplay.timeout = Utils.nextTick(function () {
              swiper.params.autoplay.reverseDirection ? swiper.params.loop ? (swiper.loopFix(), swiper.slidePrev(swiper.params.speed, !0, !0), swiper.emit("autoplay")) : swiper.isBeginning ? swiper.params.autoplay.stopOnLastSlide ? swiper.autoplay.stop() : (swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, !0, !0), swiper.emit("autoplay")) : (swiper.slidePrev(swiper.params.speed, !0, !0), swiper.emit("autoplay")) : swiper.params.loop ? (swiper.loopFix(), swiper.slideNext(swiper.params.speed, !0, !0), swiper.emit("autoplay")) : swiper.isEnd ? swiper.params.autoplay.stopOnLastSlide ? swiper.autoplay.stop() : (swiper.slideTo(0, swiper.params.speed, !0, !0), swiper.emit("autoplay")) : (swiper.slideNext(swiper.params.speed, !0, !0), swiper.emit("autoplay"))
            }, delay)
          },
          start: function () {
            return void 0 === this.autoplay.timeout && (!this.autoplay.running && (this.autoplay.running = !0, this.emit("autoplayStart"), this.autoplay.run(), !0))
          },
          stop: function () {
            return !!this.autoplay.running && (void 0 !== this.autoplay.timeout && (this.autoplay.timeout && (clearTimeout(this.autoplay.timeout), this.autoplay.timeout = void 0), this.autoplay.running = !1, this.emit("autoplayStop"), !0))
          },
          pause: function (speed) {
            this.autoplay.running && (this.autoplay.paused || (this.autoplay.timeout && clearTimeout(this.autoplay.timeout), this.autoplay.paused = !0, 0 !== speed && this.params.autoplay.waitForTransition ? (this.$wrapperEl[0].addEventListener("transitionend", this.autoplay.onTransitionEnd), this.$wrapperEl[0].addEventListener("webkitTransitionEnd", this.autoplay.onTransitionEnd)) : (this.autoplay.paused = !1, this.autoplay.run())))
          }
        },
        Fade = {
          setTranslate: function () {
            for (var slides = this.slides, i = 0; i < slides.length; i += 1) {
              var $slideEl = this.slides.eq(i),
                tx = -$slideEl[0].swiperSlideOffset;
              this.params.virtualTranslate || (tx -= this.translate);
              var ty = 0;
              this.isHorizontal() || (ty = tx, tx = 0);
              var slideOpacity = this.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
              $slideEl.css({
                opacity: slideOpacity
              }).transform("translate3d(" + tx + "px, " + ty + "px, 0px)")
            }
          },
          setTransition: function (duration) {
            var swiper = this,
              slides = swiper.slides,
              $wrapperEl = swiper.$wrapperEl;
            if (slides.transition(duration), swiper.params.virtualTranslate && 0 !== duration) {
              var eventTriggered = !1;
              slides.transitionEnd(function () {
                if (!eventTriggered && swiper && !swiper.destroyed) {
                  eventTriggered = !0, swiper.animating = !1;
                  for (var triggerEvents = ["webkitTransitionEnd", "transitionend"], i = 0; i < triggerEvents.length; i += 1) $wrapperEl.trigger(triggerEvents[i])
                }
              })
            }
          }
        },
        Cube = {
          setTranslate: function () {
            var $cubeShadowEl, $el = this.$el,
              $wrapperEl = this.$wrapperEl,
              slides = this.slides,
              swiperWidth = this.width,
              swiperHeight = this.height,
              rtl = this.rtlTranslate,
              swiperSize = this.size,
              params = this.params.cubeEffect,
              isHorizontal = this.isHorizontal(),
              isVirtual = this.virtual && this.params.virtual.enabled,
              wrapperRotate = 0;
            params.shadow && (isHorizontal ? (0 === ($cubeShadowEl = $wrapperEl.find(".swiper-cube-shadow")).length && ($cubeShadowEl = $('<div class="swiper-cube-shadow"></div>'), $wrapperEl.append($cubeShadowEl)), $cubeShadowEl.css({
              height: swiperWidth + "px"
            })) : 0 === ($cubeShadowEl = $el.find(".swiper-cube-shadow")).length && ($cubeShadowEl = $('<div class="swiper-cube-shadow"></div>'), $el.append($cubeShadowEl)));
            for (var i = 0; i < slides.length; i += 1) {
              var $slideEl = slides.eq(i),
                slideIndex = i;
              isVirtual && (slideIndex = parseInt($slideEl.attr("data-swiper-slide-index"), 10));
              var slideAngle = 90 * slideIndex,
                round = Math.floor(slideAngle / 360);
              rtl && (slideAngle = -slideAngle, round = Math.floor(-slideAngle / 360));
              var progress = Math.max(Math.min($slideEl[0].progress, 1), -1),
                tx = 0,
                ty = 0,
                tz = 0;
              slideIndex % 4 == 0 ? (tx = 4 * -round * swiperSize, tz = 0) : (slideIndex - 1) % 4 == 0 ? (tx = 0, tz = 4 * -round * swiperSize) : (slideIndex - 2) % 4 == 0 ? (tx = swiperSize + 4 * round * swiperSize, tz = swiperSize) : (slideIndex - 3) % 4 == 0 && (tx = -swiperSize, tz = 3 * swiperSize + 4 * swiperSize * round), rtl && (tx = -tx), isHorizontal || (ty = tx, tx = 0);
              var transform = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";
              if (progress <= 1 && -1 < progress && (wrapperRotate = 90 * slideIndex + 90 * progress, rtl && (wrapperRotate = 90 * -slideIndex - 90 * progress)), $slideEl.transform(transform), params.slideShadows) {
                var shadowBefore = isHorizontal ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top"),
                  shadowAfter = isHorizontal ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
                0 === shadowBefore.length && (shadowBefore = $('<div class="swiper-slide-shadow-' + (isHorizontal ? "left" : "top") + '"></div>'), $slideEl.append(shadowBefore)), 0 === shadowAfter.length && (shadowAfter = $('<div class="swiper-slide-shadow-' + (isHorizontal ? "right" : "bottom") + '"></div>'), $slideEl.append(shadowAfter)), shadowBefore.length && (shadowBefore[0].style.opacity = Math.max(-progress, 0)), shadowAfter.length && (shadowAfter[0].style.opacity = Math.max(progress, 0))
              }
            }
            if ($wrapperEl.css({
                "-webkit-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
                "-moz-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
                "-ms-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
                "transform-origin": "50% 50% -" + swiperSize / 2 + "px"
              }), params.shadow)
              if (isHorizontal) $cubeShadowEl.transform("translate3d(0px, " + (swiperWidth / 2 + params.shadowOffset) + "px, " + -swiperWidth / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + params.shadowScale + ")");
              else {
                var shadowAngle = Math.abs(wrapperRotate) - 90 * Math.floor(Math.abs(wrapperRotate) / 90),
                  multiplier = 1.5 - (Math.sin(2 * shadowAngle * Math.PI / 360) / 2 + Math.cos(2 * shadowAngle * Math.PI / 360) / 2),
                  scale1 = params.shadowScale,
                  scale2 = params.shadowScale / multiplier,
                  offset = params.shadowOffset;
                $cubeShadowEl.transform("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + (swiperHeight / 2 + offset) + "px, " + -swiperHeight / 2 / scale2 + "px) rotateX(-90deg)")
              }
            var zFactor = Browser.isSafari || Browser.isUiWebView ? -swiperSize / 2 : 0;
            $wrapperEl.transform("translate3d(0px,0," + zFactor + "px) rotateX(" + (this.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (this.isHorizontal() ? -wrapperRotate : 0) + "deg)")
          },
          setTransition: function (duration) {
            var $el = this.$el;
            this.slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration), this.params.cubeEffect.shadow && !this.isHorizontal() && $el.find(".swiper-cube-shadow").transition(duration)
          }
        },
        Flip = {
          setTranslate: function () {
            for (var slides = this.slides, rtl = this.rtlTranslate, i = 0; i < slides.length; i += 1) {
              var $slideEl = slides.eq(i),
                progress = $slideEl[0].progress;
              this.params.flipEffect.limitRotation && (progress = Math.max(Math.min($slideEl[0].progress, 1), -1));
              var rotateY = -180 * progress,
                rotateX = 0,
                tx = -$slideEl[0].swiperSlideOffset,
                ty = 0;
              if (this.isHorizontal() ? rtl && (rotateY = -rotateY) : (ty = tx, rotateX = -rotateY, rotateY = tx = 0), $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length, this.params.flipEffect.slideShadows) {
                var shadowBefore = this.isHorizontal() ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top"),
                  shadowAfter = this.isHorizontal() ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
                0 === shadowBefore.length && (shadowBefore = $('<div class="swiper-slide-shadow-' + (this.isHorizontal() ? "left" : "top") + '"></div>'), $slideEl.append(shadowBefore)), 0 === shadowAfter.length && (shadowAfter = $('<div class="swiper-slide-shadow-' + (this.isHorizontal() ? "right" : "bottom") + '"></div>'), $slideEl.append(shadowAfter)), shadowBefore.length && (shadowBefore[0].style.opacity = Math.max(-progress, 0)), shadowAfter.length && (shadowAfter[0].style.opacity = Math.max(progress, 0))
              }
              $slideEl.transform("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)")
            }
          },
          setTransition: function (duration) {
            var swiper = this,
              slides = swiper.slides,
              activeIndex = swiper.activeIndex,
              $wrapperEl = swiper.$wrapperEl;
            if (slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration), swiper.params.virtualTranslate && 0 !== duration) {
              var eventTriggered = !1;
              slides.eq(activeIndex).transitionEnd(function () {
                if (!eventTriggered && swiper && !swiper.destroyed) {
                  eventTriggered = !0, swiper.animating = !1;
                  for (var triggerEvents = ["webkitTransitionEnd", "transitionend"], i = 0; i < triggerEvents.length; i += 1) $wrapperEl.trigger(triggerEvents[i])
                }
              })
            }
          }
        },
        Coverflow = {
          setTranslate: function () {
            for (var swiperWidth = this.width, swiperHeight = this.height, slides = this.slides, $wrapperEl = this.$wrapperEl, slidesSizesGrid = this.slidesSizesGrid, params = this.params.coverflowEffect, isHorizontal = this.isHorizontal(), transform = this.translate, center = isHorizontal ? swiperWidth / 2 - transform : swiperHeight / 2 - transform, rotate = isHorizontal ? params.rotate : -params.rotate, translate = params.depth, i = 0, length = slides.length; i < length; i += 1) {
              var $slideEl = slides.eq(i),
                slideSize = slidesSizesGrid[i],
                offsetMultiplier = (center - $slideEl[0].swiperSlideOffset - slideSize / 2) / slideSize * params.modifier,
                rotateY = isHorizontal ? rotate * offsetMultiplier : 0,
                rotateX = isHorizontal ? 0 : rotate * offsetMultiplier,
                translateZ = -translate * Math.abs(offsetMultiplier),
                translateY = isHorizontal ? 0 : params.stretch * offsetMultiplier,
                translateX = isHorizontal ? params.stretch * offsetMultiplier : 0;
              Math.abs(translateX) < .001 && (translateX = 0), Math.abs(translateY) < .001 && (translateY = 0), Math.abs(translateZ) < .001 && (translateZ = 0), Math.abs(rotateY) < .001 && (rotateY = 0), Math.abs(rotateX) < .001 && (rotateX = 0);
              var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)";
              if ($slideEl.transform(slideTransform), $slideEl[0].style.zIndex = 1 - Math.abs(Math.round(offsetMultiplier)), params.slideShadows) {
                var $shadowBeforeEl = isHorizontal ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top"),
                  $shadowAfterEl = isHorizontal ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
                0 === $shadowBeforeEl.length && ($shadowBeforeEl = $('<div class="swiper-slide-shadow-' + (isHorizontal ? "left" : "top") + '"></div>'), $slideEl.append($shadowBeforeEl)), 0 === $shadowAfterEl.length && ($shadowAfterEl = $('<div class="swiper-slide-shadow-' + (isHorizontal ? "right" : "bottom") + '"></div>'), $slideEl.append($shadowAfterEl)), $shadowBeforeEl.length && ($shadowBeforeEl[0].style.opacity = 0 < offsetMultiplier ? offsetMultiplier : 0), $shadowAfterEl.length && ($shadowAfterEl[0].style.opacity = 0 < -offsetMultiplier ? -offsetMultiplier : 0)
              }
            }(Support.pointerEvents || Support.prefixedPointerEvents) && ($wrapperEl[0].style.perspectiveOrigin = center + "px 50%")
          },
          setTransition: function (duration) {
            this.slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration)
          }
        },
        components = [Device$1, Support$1, Browser$1, Resize, Observer$1, Virtual$1, Keyboard$1, {
          name: "mousewheel",
          params: {
            mousewheel: {
              enabled: !1,
              releaseOnEdges: !1,
              invert: !1,
              forceToAxis: !1,
              sensitivity: 1,
              eventsTarged: "container"
            }
          },
          create: function () {
            Utils.extend(this, {
              mousewheel: {
                enabled: !1,
                enable: Mousewheel.enable.bind(this),
                disable: Mousewheel.disable.bind(this),
                handle: Mousewheel.handle.bind(this),
                handleMouseEnter: Mousewheel.handleMouseEnter.bind(this),
                handleMouseLeave: Mousewheel.handleMouseLeave.bind(this),
                lastScrollTime: Utils.now()
              }
            })
          },
          on: {
            init: function () {
              this.params.mousewheel.enabled && this.mousewheel.enable()
            },
            destroy: function () {
              this.mousewheel.enabled && this.mousewheel.disable()
            }
          }
        }, {
          name: "navigation",
          params: {
            navigation: {
              nextEl: null,
              prevEl: null,
              hideOnClick: !1,
              disabledClass: "swiper-button-disabled",
              hiddenClass: "swiper-button-hidden",
              lockClass: "swiper-button-lock"
            }
          },
          create: function () {
            Utils.extend(this, {
              navigation: {
                init: Navigation.init.bind(this),
                update: Navigation.update.bind(this),
                destroy: Navigation.destroy.bind(this)
              }
            })
          },
          on: {
            init: function () {
              this.navigation.init(), this.navigation.update()
            },
            toEdge: function () {
              this.navigation.update()
            },
            fromEdge: function () {
              this.navigation.update()
            },
            destroy: function () {
              this.navigation.destroy()
            },
            click: function (e) {
              var ref = this.navigation,
                $nextEl = ref.$nextEl,
                $prevEl = ref.$prevEl;
              !this.params.navigation.hideOnClick || $(e.target).is($prevEl) || $(e.target).is($nextEl) || ($nextEl && $nextEl.toggleClass(this.params.navigation.hiddenClass), $prevEl && $prevEl.toggleClass(this.params.navigation.hiddenClass))
            }
          }
        }, {
          name: "pagination",
          params: {
            pagination: {
              el: null,
              bulletElement: "span",
              clickable: !1,
              hideOnClick: !1,
              renderBullet: null,
              renderProgressbar: null,
              renderFraction: null,
              renderCustom: null,
              progressbarOpposite: !1,
              type: "bullets",
              dynamicBullets: !1,
              dynamicMainBullets: 1,
              formatFractionCurrent: function (number) {
                return number
              },
              formatFractionTotal: function (number) {
                return number
              },
              bulletClass: "swiper-pagination-bullet",
              bulletActiveClass: "swiper-pagination-bullet-active",
              modifierClass: "swiper-pagination-",
              currentClass: "swiper-pagination-current",
              totalClass: "swiper-pagination-total",
              hiddenClass: "swiper-pagination-hidden",
              progressbarFillClass: "swiper-pagination-progressbar-fill",
              progressbarOppositeClass: "swiper-pagination-progressbar-opposite",
              clickableClass: "swiper-pagination-clickable",
              lockClass: "swiper-pagination-lock"
            }
          },
          create: function () {
            Utils.extend(this, {
              pagination: {
                init: Pagination.init.bind(this),
                render: Pagination.render.bind(this),
                update: Pagination.update.bind(this),
                destroy: Pagination.destroy.bind(this),
                dynamicBulletIndex: 0
              }
            })
          },
          on: {
            init: function () {
              this.pagination.init(), this.pagination.render(), this.pagination.update()
            },
            activeIndexChange: function () {
              this.params.loop ? this.pagination.update() : void 0 === this.snapIndex && this.pagination.update()
            },
            snapIndexChange: function () {
              this.params.loop || this.pagination.update()
            },
            slidesLengthChange: function () {
              this.params.loop && (this.pagination.render(), this.pagination.update())
            },
            snapGridLengthChange: function () {
              this.params.loop || (this.pagination.render(), this.pagination.update())
            },
            destroy: function () {
              this.pagination.destroy()
            },
            click: function (e) {
              this.params.pagination.el && this.params.pagination.hideOnClick && 0 < this.pagination.$el.length && !$(e.target).hasClass(this.params.pagination.bulletClass) && this.pagination.$el.toggleClass(this.params.pagination.hiddenClass)
            }
          }
        }, {
          name: "scrollbar",
          params: {
            scrollbar: {
              el: null,
              dragSize: "auto",
              hide: !1,
              draggable: !1,
              snapOnRelease: !0,
              lockClass: "swiper-scrollbar-lock",
              dragClass: "swiper-scrollbar-drag"
            }
          },
          create: function () {
            Utils.extend(this, {
              scrollbar: {
                init: Scrollbar.init.bind(this),
                destroy: Scrollbar.destroy.bind(this),
                updateSize: Scrollbar.updateSize.bind(this),
                setTranslate: Scrollbar.setTranslate.bind(this),
                setTransition: Scrollbar.setTransition.bind(this),
                enableDraggable: Scrollbar.enableDraggable.bind(this),
                disableDraggable: Scrollbar.disableDraggable.bind(this),
                setDragPosition: Scrollbar.setDragPosition.bind(this),
                onDragStart: Scrollbar.onDragStart.bind(this),
                onDragMove: Scrollbar.onDragMove.bind(this),
                onDragEnd: Scrollbar.onDragEnd.bind(this),
                isTouched: !1,
                timeout: null,
                dragTimeout: null
              }
            })
          },
          on: {
            init: function () {
              this.scrollbar.init(), this.scrollbar.updateSize(), this.scrollbar.setTranslate()
            },
            update: function () {
              this.scrollbar.updateSize()
            },
            resize: function () {
              this.scrollbar.updateSize()
            },
            observerUpdate: function () {
              this.scrollbar.updateSize()
            },
            setTranslate: function () {
              this.scrollbar.setTranslate()
            },
            setTransition: function (duration) {
              this.scrollbar.setTransition(duration)
            },
            destroy: function () {
              this.scrollbar.destroy()
            }
          }
        }, {
          name: "parallax",
          params: {
            parallax: {
              enabled: !1
            }
          },
          create: function () {
            Utils.extend(this, {
              parallax: {
                setTransform: Parallax.setTransform.bind(this),
                setTranslate: Parallax.setTranslate.bind(this),
                setTransition: Parallax.setTransition.bind(this)
              }
            })
          },
          on: {
            beforeInit: function () {
              this.params.parallax.enabled && (this.params.watchSlidesProgress = !0)
            },
            init: function () {
              this.params.parallax && this.parallax.setTranslate()
            },
            setTranslate: function () {
              this.params.parallax && this.parallax.setTranslate()
            },
            setTransition: function (duration) {
              this.params.parallax && this.parallax.setTransition(duration)
            }
          }
        }, {
          name: "zoom",
          params: {
            zoom: {
              enabled: !1,
              maxRatio: 3,
              minRatio: 1,
              toggle: !0,
              containerClass: "swiper-zoom-container",
              zoomedSlideClass: "swiper-slide-zoomed"
            }
          },
          create: function () {
            var swiper = this,
              zoom = {
                enabled: !1,
                scale: 1,
                currentScale: 1,
                isScaling: !1,
                gesture: {
                  $slideEl: void 0,
                  slideWidth: void 0,
                  slideHeight: void 0,
                  $imageEl: void 0,
                  $imageWrapEl: void 0,
                  maxRatio: 3
                },
                image: {
                  isTouched: void 0,
                  isMoved: void 0,
                  currentX: void 0,
                  currentY: void 0,
                  minX: void 0,
                  minY: void 0,
                  maxX: void 0,
                  maxY: void 0,
                  width: void 0,
                  height: void 0,
                  startX: void 0,
                  startY: void 0,
                  touchesStart: {},
                  touchesCurrent: {}
                },
                velocity: {
                  x: void 0,
                  y: void 0,
                  prevPositionX: void 0,
                  prevPositionY: void 0,
                  prevTime: void 0
                }
              };
            "onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out".split(" ").forEach(function (methodName) {
              zoom[methodName] = Zoom[methodName].bind(swiper)
            }), Utils.extend(swiper, {
              zoom: zoom
            })
          },
          on: {
            init: function () {
              this.params.zoom.enabled && this.zoom.enable()
            },
            destroy: function () {
              this.zoom.disable()
            },
            touchStart: function (e) {
              this.zoom.enabled && this.zoom.onTouchStart(e)
            },
            touchEnd: function (e) {
              this.zoom.enabled && this.zoom.onTouchEnd(e)
            },
            doubleTap: function (e) {
              this.params.zoom.enabled && this.zoom.enabled && this.params.zoom.toggle && this.zoom.toggle(e)
            },
            transitionEnd: function () {
              this.zoom.enabled && this.params.zoom.enabled && this.zoom.onTransitionEnd()
            }
          }
        }, {
          name: "lazy",
          params: {
            lazy: {
              enabled: !1,
              loadPrevNext: !1,
              loadPrevNextAmount: 1,
              loadOnTransitionStart: !1,
              elementClass: "swiper-lazy",
              loadingClass: "swiper-lazy-loading",
              loadedClass: "swiper-lazy-loaded",
              preloaderClass: "swiper-lazy-preloader"
            }
          },
          create: function () {
            Utils.extend(this, {
              lazy: {
                initialImageLoaded: !1,
                load: Lazy.load.bind(this),
                loadInSlide: Lazy.loadInSlide.bind(this)
              }
            })
          },
          on: {
            beforeInit: function () {
              this.params.lazy.enabled && this.params.preloadImages && (this.params.preloadImages = !1)
            },
            init: function () {
              this.params.lazy.enabled && !this.params.loop && 0 === this.params.initialSlide && this.lazy.load()
            },
            scroll: function () {
              this.params.freeMode && !this.params.freeModeSticky && this.lazy.load()
            },
            resize: function () {
              this.params.lazy.enabled && this.lazy.load()
            },
            scrollbarDragMove: function () {
              this.params.lazy.enabled && this.lazy.load()
            },
            transitionStart: function () {
              this.params.lazy.enabled && (this.params.lazy.loadOnTransitionStart || !this.params.lazy.loadOnTransitionStart && !this.lazy.initialImageLoaded) && this.lazy.load()
            },
            transitionEnd: function () {
              this.params.lazy.enabled && !this.params.lazy.loadOnTransitionStart && this.lazy.load()
            }
          }
        }, {
          name: "controller",
          params: {
            controller: {
              control: void 0,
              inverse: !1,
              by: "slide"
            }
          },
          create: function () {
            Utils.extend(this, {
              controller: {
                control: this.params.controller.control,
                getInterpolateFunction: Controller.getInterpolateFunction.bind(this),
                setTranslate: Controller.setTranslate.bind(this),
                setTransition: Controller.setTransition.bind(this)
              }
            })
          },
          on: {
            update: function () {
              this.controller.control && this.controller.spline && (this.controller.spline = void 0, delete this.controller.spline)
            },
            resize: function () {
              this.controller.control && this.controller.spline && (this.controller.spline = void 0, delete this.controller.spline)
            },
            observerUpdate: function () {
              this.controller.control && this.controller.spline && (this.controller.spline = void 0, delete this.controller.spline)
            },
            setTranslate: function (translate, byController) {
              this.controller.control && this.controller.setTranslate(translate, byController)
            },
            setTransition: function (duration, byController) {
              this.controller.control && this.controller.setTransition(duration, byController)
            }
          }
        }, {
          name: "a11y",
          params: {
            a11y: {
              enabled: !0,
              notificationClass: "swiper-notification",
              prevSlideMessage: "Previous slide",
              nextSlideMessage: "Next slide",
              firstSlideMessage: "This is the first slide",
              lastSlideMessage: "This is the last slide",
              paginationBulletMessage: "Go to slide {{index}}"
            }
          },
          create: function () {
            var swiper = this;
            Utils.extend(swiper, {
              a11y: {
                liveRegion: $('<span class="' + swiper.params.a11y.notificationClass + '" aria-live="assertive" aria-atomic="true"></span>')
              }
            }), Object.keys(a11y).forEach(function (methodName) {
              swiper.a11y[methodName] = a11y[methodName].bind(swiper)
            })
          },
          on: {
            init: function () {
              this.params.a11y.enabled && (this.a11y.init(), this.a11y.updateNavigation())
            },
            toEdge: function () {
              this.params.a11y.enabled && this.a11y.updateNavigation()
            },
            fromEdge: function () {
              this.params.a11y.enabled && this.a11y.updateNavigation()
            },
            paginationUpdate: function () {
              this.params.a11y.enabled && this.a11y.updatePagination()
            },
            destroy: function () {
              this.params.a11y.enabled && this.a11y.destroy()
            }
          }
        }, {
          name: "history",
          params: {
            history: {
              enabled: !1,
              replaceState: !1,
              key: "slides"
            }
          },
          create: function () {
            Utils.extend(this, {
              history: {
                init: History.init.bind(this),
                setHistory: History.setHistory.bind(this),
                setHistoryPopState: History.setHistoryPopState.bind(this),
                scrollToSlide: History.scrollToSlide.bind(this),
                destroy: History.destroy.bind(this)
              }
            })
          },
          on: {
            init: function () {
              this.params.history.enabled && this.history.init()
            },
            destroy: function () {
              this.params.history.enabled && this.history.destroy()
            },
            transitionEnd: function () {
              this.history.initialized && this.history.setHistory(this.params.history.key, this.activeIndex)
            }
          }
        }, {
          name: "hash-navigation",
          params: {
            hashNavigation: {
              enabled: !1,
              replaceState: !1,
              watchState: !1
            }
          },
          create: function () {
            Utils.extend(this, {
              hashNavigation: {
                initialized: !1,
                init: HashNavigation.init.bind(this),
                destroy: HashNavigation.destroy.bind(this),
                setHash: HashNavigation.setHash.bind(this),
                onHashCange: HashNavigation.onHashCange.bind(this)
              }
            })
          },
          on: {
            init: function () {
              this.params.hashNavigation.enabled && this.hashNavigation.init()
            },
            destroy: function () {
              this.params.hashNavigation.enabled && this.hashNavigation.destroy()
            },
            transitionEnd: function () {
              this.hashNavigation.initialized && this.hashNavigation.setHash()
            }
          }
        }, {
          name: "autoplay",
          params: {
            autoplay: {
              enabled: !1,
              delay: 3e3,
              waitForTransition: !0,
              disableOnInteraction: !0,
              stopOnLastSlide: !1,
              reverseDirection: !1
            }
          },
          create: function () {
            var swiper = this;
            Utils.extend(swiper, {
              autoplay: {
                running: !1,
                paused: !1,
                run: Autoplay.run.bind(swiper),
                start: Autoplay.start.bind(swiper),
                stop: Autoplay.stop.bind(swiper),
                pause: Autoplay.pause.bind(swiper),
                onTransitionEnd: function (e) {
                  swiper && !swiper.destroyed && swiper.$wrapperEl && e.target === this && (swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.autoplay.onTransitionEnd), swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.autoplay.onTransitionEnd), swiper.autoplay.paused = !1, swiper.autoplay.running ? swiper.autoplay.run() : swiper.autoplay.stop())
                }
              }
            })
          },
          on: {
            init: function () {
              this.params.autoplay.enabled && this.autoplay.start()
            },
            beforeTransitionStart: function (speed, internal) {
              this.autoplay.running && (internal || !this.params.autoplay.disableOnInteraction ? this.autoplay.pause(speed) : this.autoplay.stop())
            },
            sliderFirstMove: function () {
              this.autoplay.running && (this.params.autoplay.disableOnInteraction ? this.autoplay.stop() : this.autoplay.pause())
            },
            destroy: function () {
              this.autoplay.running && this.autoplay.stop()
            }
          }
        }, {
          name: "effect-fade",
          params: {
            fadeEffect: {
              crossFade: !1
            }
          },
          create: function () {
            Utils.extend(this, {
              fadeEffect: {
                setTranslate: Fade.setTranslate.bind(this),
                setTransition: Fade.setTransition.bind(this)
              }
            })
          },
          on: {
            beforeInit: function () {
              if ("fade" === this.params.effect) {
                this.classNames.push(this.params.containerModifierClass + "fade");
                var overwriteParams = {
                  slidesPerView: 1,
                  slidesPerColumn: 1,
                  slidesPerGroup: 1,
                  watchSlidesProgress: !0,
                  spaceBetween: 0,
                  virtualTranslate: !0
                };
                Utils.extend(this.params, overwriteParams), Utils.extend(this.originalParams, overwriteParams)
              }
            },
            setTranslate: function () {
              "fade" === this.params.effect && this.fadeEffect.setTranslate()
            },
            setTransition: function (duration) {
              "fade" === this.params.effect && this.fadeEffect.setTransition(duration)
            }
          }
        }, {
          name: "effect-cube",
          params: {
            cubeEffect: {
              slideShadows: !0,
              shadow: !0,
              shadowOffset: 20,
              shadowScale: .94
            }
          },
          create: function () {
            Utils.extend(this, {
              cubeEffect: {
                setTranslate: Cube.setTranslate.bind(this),
                setTransition: Cube.setTransition.bind(this)
              }
            })
          },
          on: {
            beforeInit: function () {
              if ("cube" === this.params.effect) {
                this.classNames.push(this.params.containerModifierClass + "cube"), this.classNames.push(this.params.containerModifierClass + "3d");
                var overwriteParams = {
                  slidesPerView: 1,
                  slidesPerColumn: 1,
                  slidesPerGroup: 1,
                  watchSlidesProgress: !0,
                  resistanceRatio: 0,
                  spaceBetween: 0,
                  centeredSlides: !1,
                  virtualTranslate: !0
                };
                Utils.extend(this.params, overwriteParams), Utils.extend(this.originalParams, overwriteParams)
              }
            },
            setTranslate: function () {
              "cube" === this.params.effect && this.cubeEffect.setTranslate()
            },
            setTransition: function (duration) {
              "cube" === this.params.effect && this.cubeEffect.setTransition(duration)
            }
          }
        }, {
          name: "effect-flip",
          params: {
            flipEffect: {
              slideShadows: !0,
              limitRotation: !0
            }
          },
          create: function () {
            Utils.extend(this, {
              flipEffect: {
                setTranslate: Flip.setTranslate.bind(this),
                setTransition: Flip.setTransition.bind(this)
              }
            })
          },
          on: {
            beforeInit: function () {
              if ("flip" === this.params.effect) {
                this.classNames.push(this.params.containerModifierClass + "flip"), this.classNames.push(this.params.containerModifierClass + "3d");
                var overwriteParams = {
                  slidesPerView: 1,
                  slidesPerColumn: 1,
                  slidesPerGroup: 1,
                  watchSlidesProgress: !0,
                  spaceBetween: 0,
                  virtualTranslate: !0
                };
                Utils.extend(this.params, overwriteParams), Utils.extend(this.originalParams, overwriteParams)
              }
            },
            setTranslate: function () {
              "flip" === this.params.effect && this.flipEffect.setTranslate()
            },
            setTransition: function (duration) {
              "flip" === this.params.effect && this.flipEffect.setTransition(duration)
            }
          }
        }, {
          name: "effect-coverflow",
          params: {
            coverflowEffect: {
              rotate: 50,
              stretch: 0,
              depth: 100,
              modifier: 1,
              slideShadows: !0
            }
          },
          create: function () {
            Utils.extend(this, {
              coverflowEffect: {
                setTranslate: Coverflow.setTranslate.bind(this),
                setTransition: Coverflow.setTransition.bind(this)
              }
            })
          },
          on: {
            beforeInit: function () {
              "coverflow" === this.params.effect && (this.classNames.push(this.params.containerModifierClass + "coverflow"), this.classNames.push(this.params.containerModifierClass + "3d"), this.params.watchSlidesProgress = !0, this.originalParams.watchSlidesProgress = !0)
            },
            setTranslate: function () {
              "coverflow" === this.params.effect && this.coverflowEffect.setTranslate()
            },
            setTransition: function (duration) {
              "coverflow" === this.params.effect && this.coverflowEffect.setTransition(duration)
            }
          }
        }];
      return void 0 === Swiper.use && (Swiper.use = Swiper.Class.use, Swiper.installModule = Swiper.Class.installModule), Swiper.use(components), Swiper
    }, "object" == typeof exports && void 0 !== module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : global.Swiper = factory()
  }, {}],
  11: [function (require, module, exports) {
    (function () {
      var MutationObserver, Util, WeakMap, getComputedStyle, getComputedStyleRX, bind = function (fn, me) {
          return function () {
            return fn.apply(me, arguments)
          }
        },
        indexOf = [].indexOf || function (item) {
          for (var i = 0, l = this.length; i < l; i++)
            if (i in this && this[i] === item) return i;
          return -1
        };
      Util = function () {
        function Util() {}
        return Util.prototype.extend = function (custom, defaults) {
          var key, value;
          for (key in defaults) value = defaults[key], null == custom[key] && (custom[key] = value);
          return custom
        }, Util.prototype.isMobile = function (agent) {
          return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(agent)
        }, Util.prototype.createEvent = function (event, bubble, cancel, detail) {
          var customEvent;
          return null == bubble && (bubble = !1), null == cancel && (cancel = !1), null == detail && (detail = null), null != document.createEvent ? (customEvent = document.createEvent("CustomEvent")).initCustomEvent(event, bubble, cancel, detail) : null != document.createEventObject ? (customEvent = document.createEventObject()).eventType = event : customEvent.eventName = event, customEvent
        }, Util.prototype.emitEvent = function (elem, event) {
          return null != elem.dispatchEvent ? elem.dispatchEvent(event) : event in (null != elem) ? elem[event]() : "on" + event in (null != elem) ? elem["on" + event]() : void 0
        }, Util.prototype.addEvent = function (elem, event, fn) {
          return null != elem.addEventListener ? elem.addEventListener(event, fn, !1) : null != elem.attachEvent ? elem.attachEvent("on" + event, fn) : elem[event] = fn
        }, Util.prototype.removeEvent = function (elem, event, fn) {
          return null != elem.removeEventListener ? elem.removeEventListener(event, fn, !1) : null != elem.detachEvent ? elem.detachEvent("on" + event, fn) : delete elem[event]
        }, Util.prototype.innerHeight = function () {
          return "innerHeight" in window ? window.innerHeight : document.documentElement.clientHeight
        }, Util
      }(), WeakMap = this.WeakMap || this.MozWeakMap || (WeakMap = function () {
        function WeakMap() {
          this.keys = [], this.values = []
        }
        return WeakMap.prototype.get = function (key) {
          var i, j, len, ref;
          for (i = j = 0, len = (ref = this.keys).length; j < len; i = ++j)
            if (ref[i] === key) return this.values[i]
        }, WeakMap.prototype.set = function (key, value) {
          var i, j, len, ref;
          for (i = j = 0, len = (ref = this.keys).length; j < len; i = ++j)
            if (ref[i] === key) return void(this.values[i] = value);
          return this.keys.push(key), this.values.push(value)
        }, WeakMap
      }()), MutationObserver = this.MutationObserver || this.WebkitMutationObserver || this.MozMutationObserver || (MutationObserver = function () {
        function MutationObserver() {
          "undefined" != typeof console && null !== console && console.warn("MutationObserver is not supported by your browser."), "undefined" != typeof console && null !== console && console.warn("WOW.js cannot detect dom mutations, please call .sync() after loading new content.")
        }
        return MutationObserver.notSupported = !0, MutationObserver.prototype.observe = function () {}, MutationObserver
      }()), getComputedStyle = this.getComputedStyle || function (el, pseudo) {
        return this.getPropertyValue = function (prop) {
          var ref;
          return "float" === prop && (prop = "styleFloat"), getComputedStyleRX.test(prop) && prop.replace(getComputedStyleRX, function (_, _char) {
            return _char.toUpperCase()
          }), (null != (ref = el.currentStyle) ? ref[prop] : void 0) || null
        }, this
      }, getComputedStyleRX = /(\-([a-z]){1})/g, this.WOW = function () {
        function WOW(options) {
          null == options && (options = {}), this.scrollCallback = bind(this.scrollCallback, this), this.scrollHandler = bind(this.scrollHandler, this), this.resetAnimation = bind(this.resetAnimation, this), this.start = bind(this.start, this), this.scrolled = !0, this.config = this.util().extend(options, this.defaults), null != options.scrollContainer && (this.config.scrollContainer = document.querySelector(options.scrollContainer)), this.animationNameCache = new WeakMap, this.wowEvent = this.util().createEvent(this.config.boxClass)
        }
        return WOW.prototype.defaults = {
          boxClass: "wow",
          animateClass: "animated",
          offset: 0,
          mobile: !0,
          live: !0,
          callback: null,
          scrollContainer: null
        }, WOW.prototype.init = function () {
          var ref;
          return this.element = window.document.documentElement, "interactive" === (ref = document.readyState) || "complete" === ref ? this.start() : this.util().addEvent(document, "DOMContentLoaded", this.start), this.finished = []
        }, WOW.prototype.start = function () {
          var box, j, len, ref, _this;
          if (this.stopped = !1, this.boxes = function () {
              var j, len, ref, results;
              for (results = [], j = 0, len = (ref = this.element.querySelectorAll("." + this.config.boxClass)).length; j < len; j++) box = ref[j], results.push(box);
              return results
            }.call(this), this.all = function () {
              var j, len, ref, results;
              for (results = [], j = 0, len = (ref = this.boxes).length; j < len; j++) box = ref[j], results.push(box);
              return results
            }.call(this), this.boxes.length)
            if (this.disabled()) this.resetStyle();
            else
              for (j = 0, len = (ref = this.boxes).length; j < len; j++) box = ref[j], this.applyStyle(box, !0);
          if (this.disabled() || (this.util().addEvent(this.config.scrollContainer || window, "scroll", this.scrollHandler), this.util().addEvent(window, "resize", this.scrollHandler), this.interval = setInterval(this.scrollCallback, 50)), this.config.live) return new MutationObserver((_this = this, function (records) {
            var k, len1, node, record, results;
            for (results = [], k = 0, len1 = records.length; k < len1; k++) record = records[k], results.push(function () {
              var l, len2, ref1, results1;
              for (results1 = [], l = 0, len2 = (ref1 = record.addedNodes || []).length; l < len2; l++) node = ref1[l], results1.push(this.doSync(node));
              return results1
            }.call(_this));
            return results
          })).observe(document.body, {
            childList: !0,
            subtree: !0
          })
        }, WOW.prototype.stop = function () {
          if (this.stopped = !0, this.util().removeEvent(this.config.scrollContainer || window, "scroll", this.scrollHandler), this.util().removeEvent(window, "resize", this.scrollHandler), null != this.interval) return clearInterval(this.interval)
        }, WOW.prototype.sync = function (element) {
          if (MutationObserver.notSupported) return this.doSync(this.element)
        }, WOW.prototype.doSync = function (element) {
          var box, j, len, ref, results;
          if (null == element && (element = this.element), 1 === element.nodeType) {
            for (results = [], j = 0, len = (ref = (element = element.parentNode || element).querySelectorAll("." + this.config.boxClass)).length; j < len; j++) box = ref[j], indexOf.call(this.all, box) < 0 ? (this.boxes.push(box), this.all.push(box), this.stopped || this.disabled() ? this.resetStyle() : this.applyStyle(box, !0), results.push(this.scrolled = !0)) : results.push(void 0);
            return results
          }
        }, WOW.prototype.show = function (box) {
          return this.applyStyle(box), box.className = box.className + " " + this.config.animateClass, null != this.config.callback && this.config.callback(box), this.util().emitEvent(box, this.wowEvent), this.util().addEvent(box, "animationend", this.resetAnimation), this.util().addEvent(box, "oanimationend", this.resetAnimation), this.util().addEvent(box, "webkitAnimationEnd", this.resetAnimation), this.util().addEvent(box, "MSAnimationEnd", this.resetAnimation), box
        }, WOW.prototype.applyStyle = function (box, hidden) {
          var delay, duration, iteration, _this;
          return duration = box.getAttribute("data-wow-duration"), delay = box.getAttribute("data-wow-delay"), iteration = box.getAttribute("data-wow-iteration"), this.animate((_this = this, function () {
            return _this.customStyle(box, hidden, duration, delay, iteration)
          }))
        }, WOW.prototype.animate = "requestAnimationFrame" in window ? function (callback) {
          return window.requestAnimationFrame(callback)
        } : function (callback) {
          return callback()
        }, WOW.prototype.resetStyle = function () {
          var box, j, len, ref, results;
          for (results = [], j = 0, len = (ref = this.boxes).length; j < len; j++) box = ref[j], results.push(box.style.visibility = "visible");
          return results
        }, WOW.prototype.resetAnimation = function (event) {
          var target;
          if (0 <= event.type.toLowerCase().indexOf("animationend")) return (target = event.target || event.srcElement).className = target.className.replace(this.config.animateClass, "").trim()
        }, WOW.prototype.customStyle = function (box, hidden, duration, delay, iteration) {
          return hidden && this.cacheAnimationName(box), box.style.visibility = hidden ? "hidden" : "visible", duration && this.vendorSet(box.style, {
            animationDuration: duration
          }), delay && this.vendorSet(box.style, {
            animationDelay: delay
          }), iteration && this.vendorSet(box.style, {
            animationIterationCount: iteration
          }), this.vendorSet(box.style, {
            animationName: hidden ? "none" : this.cachedAnimationName(box)
          }), box
        }, WOW.prototype.vendors = ["moz", "webkit"], WOW.prototype.vendorSet = function (elem, properties) {
          var name, results, value, vendor;
          for (name in results = [], properties) value = properties[name], elem["" + name] = value, results.push(function () {
            var j, len, ref, results1;
            for (results1 = [], j = 0, len = (ref = this.vendors).length; j < len; j++) vendor = ref[j], results1.push(elem["" + vendor + name.charAt(0).toUpperCase() + name.substr(1)] = value);
            return results1
          }.call(this));
          return results
        }, WOW.prototype.vendorCSS = function (elem, property) {
          var j, len, ref, result, style, vendor;
          for (result = (style = getComputedStyle(elem)).getPropertyCSSValue(property), j = 0, len = (ref = this.vendors).length; j < len; j++) vendor = ref[j], result = result || style.getPropertyCSSValue("-" + vendor + "-" + property);
          return result
        }, WOW.prototype.animationName = function (box) {
          var animationName;
          try {
            animationName = this.vendorCSS(box, "animation-name").cssText
          } catch (error) {
            animationName = getComputedStyle(box).getPropertyValue("animation-name")
          }
          return "none" === animationName ? "" : animationName
        }, WOW.prototype.cacheAnimationName = function (box) {
          return this.animationNameCache.set(box, this.animationName(box))
        }, WOW.prototype.cachedAnimationName = function (box) {
          return this.animationNameCache.get(box)
        }, WOW.prototype.scrollHandler = function () {
          return this.scrolled = !0
        }, WOW.prototype.scrollCallback = function () {
          var box;
          if (this.scrolled && (this.scrolled = !1, this.boxes = function () {
              var j, len, ref, results;
              for (results = [], j = 0, len = (ref = this.boxes).length; j < len; j++)(box = ref[j]) && (this.isVisible(box) ? this.show(box) : results.push(box));
              return results
            }.call(this), !this.boxes.length && !this.config.live)) return this.stop()
        }, WOW.prototype.offsetTop = function (element) {
          for (var top; void 0 === element.offsetTop;) element = element.parentNode;
          for (top = element.offsetTop; element = element.offsetParent;) top += element.offsetTop;
          return top
        }, WOW.prototype.isVisible = function (box) {
          var bottom, offset, top, viewBottom, viewTop;
          return offset = box.getAttribute("data-wow-offset") || this.config.offset, viewBottom = (viewTop = this.config.scrollContainer && this.config.scrollContainer.scrollTop || window.pageYOffset) + Math.min(this.element.clientHeight, this.util().innerHeight()) - offset, bottom = (top = this.offsetTop(box)) + box.clientHeight, top <= viewBottom && viewTop <= bottom
        }, WOW.prototype.util = function () {
          return null != this._util ? this._util : this._util = new Util
        }, WOW.prototype.disabled = function () {
          return !this.config.mobile && this.util().isMobile(navigator.userAgent)
        }, WOW
      }()
    }).call(this)
  }, {}],
  12: [function (require, module, exports) {
    "use strict";
    module.exports = function () {
      $.fn.extend({
        animateCss: function (animation_name, callback) {
          var animation_end = function (el) {
            var animations = {
              animation: "animationend",
              OAnimation: "oAnimationEnd",
              MozAnimation: "mozAnimationEnd",
              WebkitAnimation: "webkitAnimationEnd"
            };
            for (var t in animations)
              if (void 0 !== el.style[t]) return animations[t]
          }(document.createElement("div"));
          return this.addClass("animated " + animation_name).one(animation_end, function () {
            $(this).removeClass("animated " + animation_name), "function" == typeof callback && callback()
          }), this
        }
      })
    }
  }, {}],
  13: [function (require, module, exports) {
    "use strict";
    module.exports = function () {
      var UploadFile = {
        filteredList: [],
        _init: function () {
          this._cacheDom(), this._bindEvents()
        },
        _cacheDom: function () {
          this.$fileAvatar = $(".profile-avatar"), this.$fileInputs = this.$fileAvatar.find('.profile-avatar-field input[type="file"]'), this.$filePreview = this.$fileAvatar.find(".profile-avatar-preview img")
        },
        _bindEvents: function () {
          this.$fileInputs.each(function (index, input) {
            $(input).on("change", function (e) {
              var maxSize = $(e.target).attr("data-maxSize") || 1;
              this.filteredList = Array.from(e.target.files).filter(function (file) {
                return file.size <= 1024 * maxSize * 1024
              }), UploadFile._render(e.target, this.filteredList)
            })
          })
        },
        _render: function (target, files) {
          $(target).attr("id"), $(target).attr("data-maxFiles");
          for (var i = 0; i < files.length; i++) console.log(this._fileImage(files[i])), this.$filePreview.attr("src", this._fileImage(files[i]));
          $(target).is("[multiple]") && $(target).attr("data-maxFiles", Number($(target).attr("data-maxFiles")) - target.files.length)
        },
        _fileImage: function (file) {
          if (file.type.match(/image.*/)) return window.URL.createObjectURL(file)
        }
      };
      UploadFile._init()
    }
  }, {}],
  14: [function (require, module, exports) {
    "use strict";
    var Arabic = require("flatpickr/dist/l10n/ar.js").default.ar,
      English = require("flatpickr/dist/l10n/default.js");
    module.exports = function () {
      $(".times-of-work").each(function (index, element) {
        $(element).flatpickr({
          enableTime: !0,
          altInput: !0,
          altFormat: "F j, Y H:i",
          dateFormat: "Y-m-d H:i",
          locale: "rtl" === $("html").attr("dir") ? Arabic : English
        })
      })
    }
  }, {
    "flatpickr/dist/l10n/ar.js": 3,
    "flatpickr/dist/l10n/default.js": 4
  }],
  15: [function (require, module, exports) {
    "use strict";
    module.exports = function () {
      $(".location-search").each(function (index, item) {
        var autocomplete = new google.maps.places.Autocomplete($(item)[0], {
          types: [],
          componentRestrictions: {
            country: []
          }
        });
        $(item).keydown(function (e) {
          if (13 == e.which && $(".pac-container:visible").length) return !1
        }), google.maps.event.addListener(autocomplete, "place_changed", function () {
          autocomplete.getPlace().geometry || window.alert("Autocomplete's returned place contains no geometry")
        })
      })
    }
  }, {}],
  16: [function (require, module, exports) {
    "use strict";
    module.exports = function () {
      $("input.badges-input").not("input[readonly]").each(function (index, element) {
        var $badges_container = $(element).closest(".form-row").find(".badges-container"),
          $badges_add_more = $(element).closest(".form-row").find(".badges-add-more"),
          badges = [];
        $badges_add_more.on("click", function () {
          if ("" !== $(element).val()) {
            if (badges.includes($(element).val())) return !1;
            badges.push($(element).val()), $(element).val(""), $badges_container.append('\n\t\t\t\t\t\t<span class="badge badge-primary">' + badges[badges.length - 1] + '</span>\n\t\t\t\t\t\t<input name="' + $(element).attr("name") + '" type="' + $(element).attr("type") + '" value="' + badges[badges.length - 1] + '" hidden></input>\n\t\t\t\t\t')
          }
        })
      })
    }
  }, {}],
  17: [function (require, module, exports) {
    "use strict";
    require("jarallax/dist/jarallax.min.js"), module.exports = function () {
      $(".jarallax").each(function () {
        $(this).jarallax({
          speed: .5
        })
      })
    }
  }, {
    "jarallax/dist/jarallax.min.js": 5
  }],
  18: [function (require, module, exports) {
    "use strict";
    module.exports = function () {
      $(".stars-readOnly").each(function (index, item) {
        $(item).barrating({
          theme: "fontawesome-stars-o",
          initialRating: $(item).is("[data-init]") && "0" !== $(item).attr("data-init") ? Number($(item).attr("data-init")) : "null",
          readonly: !0,
          showSelectedRating: !0,
          hoverState: !1,
          silent: !0
        })
      }), $(".stars-input").each(function (index, item) {
        $(item).barrating({
          theme: "fontawesome-stars-o",
          initialRating: $(item).is("[data-init]") && "0" !== $(item).attr("data-init") ? Number($(item).attr("data-init")) : "null",
          readonly: !1,
          showSelectedRating: !0,
          hoverState: !0,
          silent: !1
        })
      })
    }
  }, {}],
  19: [function (require, module, exports) {
    "use strict";
    module.exports = function () {
      var $header = $("nav.navbar"),
        header_top = $header.height() / 2;
      $(window).on("scroll", function (e) {
        var w_scroll = $(this).scrollTop();
        header_top < w_scroll ? $header.addClass("scrolling") : $header.hasClass("scrolling") && $header.removeClass("scrolling"), w_scroll
      }), $(window).trigger("scroll")
    }
  }, {}],
  20: [function (require, module, exports) {
    "use strict";
    module.exports = function () {
      $(".show-password").each(function (index, item) {
        $(item).on("click", function () {
          var $input = $(item).siblings("input");
          if ("password" === $input.attr("type")) $input.attr("type", "text"), $(item).find(".fas.fa-eye").removeClass("fa-eye").addClass("fa-eye-slash");
          else {
            if ("text" !== $input.attr("type")) return !1;
            $input.attr("type", "password"), $(item).find(".fas.fa-eye-slash").removeClass("fa-eye-slash").addClass("fa-eye")
          }
        })
      })
    }
  }, {}],
  21: [function (require, module, exports) {
    "use strict";
    var _require = require("lodash"),
      capitalize = _require.capitalize,
      toLower = _require.toLower,
      isEqual = _require.isEqual;
    module.exports = function () {
      var options = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {
        enternce_direction: "left",
        exit_direction: "left",
        speed: "",
        animation: "slide"
      };
      ({
        _animation: {
          speed: toLower(options.speed),
          enternce: toLower(options.animation) + "In" + ("ltr" === $("html").attr("dir") ? capitalize(options.enternce_direction) : capitalize(options.exit_direction)) + " " + options.speed,
          exit: toLower(options.animation) + "Out" + ("ltr" === $("html").attr("dir") ? capitalize(options.exit_direction) : capitalize(options.enternce_direction)) + " " + options.speed
        },
        _init: function () {
          this._cach_dom(), this._bind_events()
        },
        _cach_dom: function () {
          this.$window = $(window), this.$body = $("body"), this.$menu = $(".overlay"), this.$bg_overlay = $(".side-open"), this.$open_icon = $(".menu-open"), this.$close_icon = this.$menu.find(".menu-close")
        },
        _bind_events: function () {
          var _this = this;
          this.$body.on("keyup", function (e) {
            isEqual(e.key, "Escape") && isEqual(e.which, 27) && _this._close_menu()
          }), this.$open_icon.on("click", this._open_menu.bind(this)), this.$close_icon.on("click", this._close_menu.bind(this)), this.$bg_overlay.on("click", this._close_menu.bind(this))
        },
        _open_menu: function (e) {
          this.$menu.hasClass("open") || this.$bg_overlay.hasClass("d-block") || (this.$bg_overlay.addClass("d-block").animateCss("fadeIn " + this._animation.speed), this.$menu.addClass("open").animateCss(this._animation.enternce))
        },
        _close_menu: function (e) {
          var _this = this;
          this.$menu.hasClass("open") && this.$bg_overlay.hasClass("d-block") && (this.$bg_overlay.animateCss("fadeOut " + this._animation.speed, function () {
            _this.$bg_overlay.removeClass("d-block")
          }), this.$menu.animateCss(this._animation.exit, function () {
            _this.$menu.removeClass(_this._animation.exit + " open")
          }))
        }
      })._init()
    }
  }, {
    lodash: 8
  }],
  22: [function (require, module, exports) {
    "use strict";
    var Swiper = require("swiper");
    module.exports = function () {
      $("#home-main") && $("#home-main").length && new Swiper("#home-main .swiper-container", {
        init: !0,
        direction: "horizontal",
        speed: 1e3,
        loop: !0,
        parallax: !0,
        grabCursor: !0,
        keyboard: {
          enabled: !0,
          onlyInViewport: !0
        },
        effect: "fade",
        fadeEffect: {
          crossFade: !0
        },
        navigation: {
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev"
        },
        pagination: {
          el: ".swiper-pagination",
          type: "bullets",
          clickable: !0,
          dynamicBullets: !0
        }
      }).init();
      $(".services-tab-slider") && $(".services-tab-slider").length && $(".services-tab-slider").each(function (index, item) {
        var my_swiper = new Swiper($(item), {
          init: !0,
          direction: "horizontal",
          speed: 1e3,
          loop: !0,
          parallax: !0,
          grabCursor: !0,
          centeredSlides: !0,
          slidesPerView: 5,
          spaceBetween: 20,
          breakpoints: {
            576: {
              slidesPerView: 1,
              spaceBetween: 10
            },
            768: {
              slidesPerView: 2,
              spaceBetween: 10
            },
            992: {
              slidesPerView: 3,
              spaceBetween: 15
            },
            1200: {
              slidesPerView: 4,
              spaceBetween: 20
            }
          },
          keyboard: {
            enabled: !0,
            onlyInViewport: !0
          },
          navigation: {
            nextEl: ".swiper-button-next",
            prevEl: ".swiper-button-prev"
          }
        });
        my_swiper.init(), $('a[data-toggle="pill"]').on("shown.bs.tab", function (e) {
          var paneTarget = $(e.target).attr("href"),
            $thePane = $(".tab-pane" + paneTarget);
          $thePane.index();
          0 < $thePane.find(".swiper-container").length && 0 === $thePane.find(".swiper-slide-active").length && my_swiper.update()
        })
      })
    }
  }, {
    swiper: 10
  }],
  23: [function (require, module, exports) {
    "use strict";
    window.$ = window.jQuery = require("jquery"), require("popper.js"), require("bootstrap"), require("jquery-bar-rating"), require("flatpickr");
    var $, WOW = require("wowjs").WOW,
      sideNav = require("./partials/sideNav"),
      swiperInit = require("./partials/swiperInit"),
      animateCssInit = require("./partials/animateCssInit"),
      navbarScrolling = require("./partials/navbarScrolling"),
      jarallaxInit = require("./partials/jarallaxInit"),
      jqueryBarRatingInit = require("./partials/jqueryBarRatingInit"),
      showPassword = require("./partials/showPassword"),
      googleMapLocation = require("./partials/googleMapLocation"),
      flatPickrInit = require("./partials/flatPickrInit"),
      inputBadges = require("./partials/inputBadges"),
      avatarFileUpload = require("./partials/avatarFileUpload");
    ($ = jQuery)(window).on("load", function () {
      animateCssInit(), $(".preloader").animateCss("fadeOut faster", function () {
        $(".preloader").removeClass("d-flex").addClass("d-none"), $("body").removeClass("preloader-shown")
      }), new WOW({
        live: !1
      }).init()
    }), $(document).ready(function () {
      $("body").addClass("preloader-shown"), sideNav({
        speed: "faster",
        animation: "fade",
        enternce_direction: "right",
        exit_direction: "right"
      }), navbarScrolling(), swiperInit(), jarallaxInit(), jqueryBarRatingInit(), showPassword(), flatPickrInit(), googleMapLocation(), inputBadges(), avatarFileUpload()
    })
  }, {
    "./partials/animateCssInit": 12,
    "./partials/avatarFileUpload": 13,
    "./partials/flatPickrInit": 14,
    "./partials/googleMapLocation": 15,
    "./partials/inputBadges": 16,
    "./partials/jarallaxInit": 17,
    "./partials/jqueryBarRatingInit": 18,
    "./partials/navbarScrolling": 19,
    "./partials/showPassword": 20,
    "./partials/sideNav": 21,
    "./partials/swiperInit": 22,
    bootstrap: 1,
    flatpickr: 2,
    jquery: 7,
    "jquery-bar-rating": 6,
    "popper.js": 9,
    wowjs: 11
  }]
}, {}, [23]);
